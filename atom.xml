<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHUNQIULFQ</title>
  
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chunqiublog.github.io/"/>
  <updated>2018-10-15T03:49:41.087Z</updated>
  <id>http://chunqiublog.github.io/</id>
  
  <author>
    <name>chunqiulfq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数 read()</title>
    <link href="http://chunqiublog.github.io/%E5%87%BD%E6%95%B0_read.html"/>
    <id>http://chunqiublog.github.io/函数_read.html</id>
    <published>2018-10-14T14:19:57.000Z</published>
    <updated>2018-10-15T03:49:41.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>注: 基于 <code>release 4.16 of the Linux man-pages project</code> 整理 <code>APUE</code> 中未进行说明或与 <code>Linux</code> 存在不同的内容.</em></p><ul><li>参考 <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener"><code>read(2)</code></a>.</li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li>支持 <code>lseek()</code> 操作的文件的读操作从文件偏移量位置开始, 文件偏移量会增加读取的位数. 当文件偏移量在文件结尾或超出文件结尾, 没有数据可读, <code>read()</code> 将返回 <code>0</code>.</li><li>如果 <code>count</code> 参数是 <code>0</code>, 读操作可以用于检测错误. 如果没有任何错误或 <code>read()</code> 操作没有检测到错误, <code>count</code> 参数为 <code>0</code> 的 <code>read()</code> 操作将返回 <code>0</code>, 并不会产生其他的影响.</li><li>根据 <code>POSIX.1</code>, 当 <code>count</code> 参数超过 <code>SSIZE_MAX</code> 时的行为有具体的实现定义; 在<a href="#注意">注意</a>中查看 <code>Linux</code> 中 <code>count</code> 的上限.</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>出错时返回 <code>-1</code>, <code>errno</code> 被设置为适合的值. 在这种情况下, 没有指定文件偏移量(如果有) 的变化.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><code>size_t</code> 和 <code>ssize_t</code> 分别是被<code>POSIX.1</code> 指定的无符号和有符号整型数据类型.</li><li>在 <code>Linux</code> 中, <code>read()</code>(和类似的系统调用) 一次最多传输 <code>0x7ffff000(2,147,479,552)</code> 个字节, 会返回实际传输的字节数. (无论是 <code>32</code> 位还是 <code>64</code> 位的系统这都是正确的.)</li><li>在 <code>NFS</code> 文件系统中, 读取少量数据可能只会在第一次读取时更新时间戳, 随后的调用可能不会. 这是客户端的缓存属性导致, 因为大多数 <code>NFS</code> 客户端将 <code>st_atime(last file access time)</code> 的更新留给了服务器, 当客户端从自身的缓存中读到了足够的数据时, 就不会从服务端读取, 也就不会导致服务端 <code>st_atime</code> 的更新. <code>UNIX</code> 语义可以通过关闭客户端的缓存属性使 <code>st_atime</code> 更新, 但是大多数情况下这种做法都会增加服务器负载, 降低性能.</li></ul><h3 id="BUGS"><a href="#BUGS" class="headerlink" title="BUGS"></a>BUGS</h3><ul><li><p>根据 <code>POSIX.1-2008/SUSv4 Section XSI 2.9.7</code> (普通文件的线程交互操作):</p><blockquote><p>当对普通文件或符号链接操作时, 以下所有函数应该遵守 <code>POSIX.1-2008</code> 中指定的效果相互原子化: …</p></blockquote></li><li><p>随后列出的 <code>API</code> 中包括 <code>read()</code> 和 <a href="http://man7.org/linux/man-pages/man2/readv.2.html" target="_blank" rel="noopener"><code>readv(2)</code></a>. 它们跨线程(和进程)操作的效果应该是原子化的更新文件文件偏移量. 但是, 在 <code>Linux 3.14</code> 之前的版本情况并非如此: 如果共享打开文件描述(参考 <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener"><code>open(2)</code></a> 的两个进程同时执行 <code>read()</code>(或  <a href="http://man7.org/linux/man-pages/man2/readv.2.html" target="_blank" rel="noopener"><code>readv(2)</code></a>), 那么 <code>I/O</code> 操作更新文件偏移量将不会遵守原子化的规则, 从而导致两个进程的读取操作可能(错误的) 获取到重叠的数据块. 这个问题在 <code>Linunx 3.14</code> 中被解决.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注: 基于 &lt;code&gt;release 4.16 of the Linux man-pages project&lt;/code&gt; 整理 &lt;code&gt;APUE&lt;/code&gt; 中未进行说明或与 &lt;code&gt;Linux&lt;/code&gt; 存在不同的内容.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/read.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; read(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="APUE" scheme="http://chunqiublog.github.io/tags/APUE/"/>
    
      <category term="文件I/O" scheme="http://chunqiublog.github.io/tags/%E6%96%87%E4%BB%B6I-O/"/>
    
  </entry>
  
  <entry>
    <title>函数 close()</title>
    <link href="http://chunqiublog.github.io/%E5%87%BD%E6%95%B0_close.html"/>
    <id>http://chunqiublog.github.io/函数_close.html</id>
    <published>2018-10-14T14:19:17.000Z</published>
    <updated>2018-10-15T03:46:07.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>注: 基于 <code>release 4.16 of the Linux man-pages project</code> 整理 <code>APUE</code> 中未进行说明或与 <code>Linux</code> 存在不同的内容.</em></p><ul><li>参考 <a href="http://man7.org/linux/man-pages/man2/close.2.html" target="_blank" rel="noopener"><code>close(2)</code></a>.</li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li>调用 <code>close()</code> 函数时, 如果 <code>fd</code> 参数是最后一个指向底层打开文件描述(参考 <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener"><code>open(2)</code></a>)的文件描述符, 资源关联的打开文件描述会被释放; 如果这个文件描述符是一个被使用 <a href="http://man7.org/linux/man-pages/man2/unlink.2.html" target="_blank" rel="noopener"><code>unlink(2)</code></a> 删除了文件名引用的文件最后的引用, 这个文件将被彻底删除.</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>成功关闭文件描述符并不保证数据已经成功保存到磁盘中, 因为内核使用缓冲区缓存来推迟写入. 通常, 文件系统在关闭一个文件时不会刷新缓冲区. 如果你需要确保数据物理的存储在底层磁盘上, 可以使用 <a href="http://man7.org/linux/man-pages/man2/fsync.2.html" target="_blank" rel="noopener"><code>fsync(2)</code></a>. (这将取决于磁盘硬件.)</li><li><code>close-on-exec</code> 文件描述符标志可以被用来确保成功调用 <a href="http://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="noopener"><code>execve(2)</code></a> 时自动关闭一个文件描述符; 详细描述参考 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a>.</li><li>关闭可能正在被同一进程的其他线程的系统调用使用的文件描述符可能是不明智的. 因为一个文件描述符可能会被重用, 这是一些可能导致意料之外副作用的隐蔽竞态条件.</li></ul><h4 id="处理-close-返回的错误"><a href="#处理-close-返回的错误" class="headerlink" title="处理 close() 返回的错误"></a>处理 <code>close()</code> 返回的错误</h4><ul><li><p>一个谨慎的程序员会去检查 <code>close()</code> 的返回值, 因为之前的 <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a> 操作产生的错误很可能只有在最后调用释放打开文件描述的 <code>close()</code> 时才会被通知. 当关闭一个文件时没有检查返回值可能会导致数据<em>无声的</em>丢失. 特别是在使用 <code>NFS</code> 或磁盘空间不足时可以观察到这种情况.</p></li><li><p>但是需要注意错误的返回应该仅用于诊断的目的(即, 向应用程序发出一个这里可能仍有待处理的 <code>I/O</code> 或可能存在 <code>I/O</code> 故障的警告) 或补救的目的(例如, 再次写文件或创建一个备份文件).</p></li><li><p>在一个错误的返回产生后重新尝试调用 <code>close()</code> 函数是一个错误的做法, 因为这可能会导致其他线程重用的文件描述符被关闭. 会出现这种情况是因为 <code>Linux</code> 内核<em>总是</em>在关闭操作的早期释放文件描述符以便可以重用; 可能返回错误的步骤(例如将数据刷新到文件系统或设备中)仅发生在关闭操作的后期.</p></li><li><p>其他类似的实现即使它们之后会通过 <code>close()</code> 返回一个错误也总是会关闭文件(除了 <code>EBADF</code> 的情况, 这意味着文件描述符是无效的). <code>POSIX.1</code> 标准目前在这一点上保持沉默, 但有计划在标准的下一个大版本中强制要求此行为.</p></li><li><p>一个谨慎的程序员想要知道是否存在 <code>I/O</code> 错误可能会在 <code>close()</code> 之前先调用 <a href="http://man7.org/linux/man-pages/man2/fsync.2.html" target="_blank" rel="noopener"><code>fsync(2)</code></a>.</p></li><li><p><code>EINTR</code> 是一个有些特殊的情况. 关于 <code>EINTR</code> 错误, <code>POSIX.1-2013</code> 规定:</p><blockquote><p>如果 <code>close()</code> 因为捕获信号而被中断, 它应该会返回 <code>-1</code> 并将 <code>errno</code> 设置为 <code>EINTR</code>, 这时文件描述符的状态是未定义的.</p></blockquote></li><li><p>在 <code>Linux</code> 和许多其他实现中采用 <code>EINTR</code> 像 <code>close()</code> 可能产生的其他错误一样保证文件描述符被关闭的行为. 然而, 另一种可能也是被运行的: 采用返回 <code>EINTR</code> 错误并保持文件描述符是打开状态的实现.(根据文档, <code>HP-UX</code> 中的 <code>close()</code> 是这样做的.) 然后调用者再次调用 <code>close()</code> 去关闭文件描述符, 避免文件描述符泄漏. 实现行为的差异为可移植程序带来了一个困难的障碍. 因为在许多实现中, 出现 <code>EINTR</code> 错误之后不能再次调用 <code>close()</code>; 而在至少一个的实现中, 出现 <code>EINTR</code> 错误之后必须再次调用 <code>close()</code>. 在 <code>POSIX.1</code> 标准的下一个大版本中有机会解决这个难题. </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注: 基于 &lt;code&gt;release 4.16 of the Linux man-pages project&lt;/code&gt; 整理 &lt;code&gt;APUE&lt;/code&gt; 中未进行说明或与 &lt;code&gt;Linux&lt;/code&gt; 存在不同的内容.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/close.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;close(2)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="APUE" scheme="http://chunqiublog.github.io/tags/APUE/"/>
    
      <category term="文件I/O" scheme="http://chunqiublog.github.io/tags/%E6%96%87%E4%BB%B6I-O/"/>
    
  </entry>
  
  <entry>
    <title>函数 lseek()</title>
    <link href="http://chunqiublog.github.io/function_lseek.html"/>
    <id>http://chunqiublog.github.io/function_lseek.html</id>
    <published>2018-10-14T14:19:09.000Z</published>
    <updated>2018-10-15T03:48:42.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>注: 基于 <code>release 4.16 of the Linux man-pages project</code> 整理 <code>APUE</code> 中未进行说明或与 <code>Linux</code> 存在不同的内容.</em></p><ul><li>参考 <a href="http://man7.org/linux/man-pages/man2/lseek.2.html" target="_blank" rel="noopener"><code>lseek(2)</code></a>.</li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li><code>lseek()</code> 运行将文件偏移量设置到文件结尾之外(但是这不会改变文件的大小). 如果在这之后数据被写入了这个位置, 则后续在这个间隙(“空洞(<code>hole</code>)”)的读操作将会返回空字节(<code>\0</code>), 直到数据实际被写入间隙.</li></ul><h4 id="寻找文件中的数据和空洞"><a href="#寻找文件中的数据和空洞" class="headerlink" title="寻找文件中的数据和空洞"></a>寻找文件中的数据和空洞</h4><ul><li>从 <code>3.1</code> 版本开始, <code>Linux</code> 开始支持以下 <code>whence</code> 参数的新增值:<ul><li><code>SEEK_DATA</code>: 将文件偏移量调整到文件中大于或等于 <code>offset</code> 参数的包含数据的下一个位置. 如果 <code>offset</code> 参数指向数据, 那么就把文件偏移量设置为 <code>offset</code> 参数.</li><li><code>SEEK_HOLE</code>: 将文件偏移量调整到文件中大于或等于 <code>offset</code> 参数的下一个空洞. 如果 <code>offset</code> 参数指向一个空洞中, 那么就把文件偏移量设置为 <code>offset</code> 参数. 如果 <code>offset</code> 参数后没有空洞了, 那么就把文件偏移量调整为文件结尾(即, 任何文件的结尾都隐含一个空洞).</li></ul></li><li>以上的情况在 <code>offset</code> 参数指向超过文件结尾时调用 <code>lseek()</code> 都会失败.</li><li>这些操作使得应用程序可以在一个稀疏分配的文件中映射到一个空洞. 这种操作对类似文件备份工具等应用程序非常有用, 如果文件备份工具有发现空洞的机制, 就可以通过保留空洞在创建备份时节省空间.</li><li>在这些操作中, 空洞是指一系列没有写入底层文件存储中的零. 但是文件系统不被强制要求在文件存储中反映空洞, 因此这些操作对映射的文件实际分配的存储空间没有保障机制(即, 文件系统是不会确保在文件映射到存储空间时存在空洞, 因为那一系列零可以被写入底层存储). (此外, 实际已经写入底层存储的一系列零可能不会被作为一个空洞被反馈.) 在最简单的实现中, 文件系统可以通过使 <code>SEEK_HOLE</code> 始终返回文件结尾的偏移量来支持 <code>SEEK_HOLE</code> 操作, 使 <code>SEEK_DATA</code> 始终返回 <code>offset</code> 参数来支持 <code>SEEK_DATA</code> 操作(即, 即使 <code>offset</code> 参数指向的位置是一个空洞, 也可以认为它是由一系列零的数据组成).</li><li>在 <code>CentOS Linux release 7.5.1804</code> 实测发现当一系列零被写入底层存储时不会被认为是一个空洞, 写入数据时以 <code>4096</code> 为一个块进行写入. 数据在紧跟一系列零时, 如果数据不满 <code>4096</code> 的倍数时, 会写入紧跟的零进行不全, 这部分零将不算是空洞的一部分. 而剩下的零至少要大于等于 <code>4096</code> 才会形成空洞. 所以空洞开始位置是 <code>4096</code> 的倍数, 结束位置减去开始位置大于等于 <code>4096</code>.</li><li>为了可以在 <code>&lt;unistd.h&gt;</code> 中获取到 <code>SEEK_DATA</code> 和 <code>SEEK_HOLE</code> 的定义, 必须定义 <code>_GNU_SOURCE</code> 特征测试宏.</li><li>以下的文件系统支持 <code>SEEK_DATA</code> 和 <code>SEEK_HOLE</code> 操作:<ul><li><code>Btrfs</code> (<code>Linux 3.1</code> 引入)</li><li><code>OCFS</code> (<code>Linux 3.2</code> 引入)</li><li><code>XFS</code> (<code>Linux 3.5</code> 引入)</li><li><code>ext4</code> (<code>Linux 3.8</code> 引入)</li><li><a href="http://man7.org/linux/man-pages/man5/tmpfs.5.html" target="_blank" rel="noopener"><code>tmpfs(5)</code></a> (<code>Linux 3.8</code> 引入)</li><li><code>NFS</code> (<code>Linux 3.18</code> 引入)</li><li><code>FUSE</code> (<code>Linux 4.5</code> 引入)</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><code>POSIX.1</code> 规定 <code>off_t</code> 类型是一个有符号整型.</li><li>一些设备不能使用 <code>lseek()</code>, <code>POSIX</code> 没有规定设备必须支持 <code>lseek()</code>.</li><li>在 <code>Linux</code> 上, 对管道文件, <code>FIFO</code>, <code>socket</code> 文件或终端设备使用 <code>lseek()</code> 会失败并生成 <code>ESPIPE</code> 错误.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注: 基于 &lt;code&gt;release 4.16 of the Linux man-pages project&lt;/code&gt; 整理 &lt;code&gt;APUE&lt;/code&gt; 中未进行说明或与 &lt;code&gt;Linux&lt;/code&gt; 存在不同的内容.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/lseek.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;lseek(2)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; lseek(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; offset, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; whence);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="APUE" scheme="http://chunqiublog.github.io/tags/APUE/"/>
    
      <category term="文件I/O" scheme="http://chunqiublog.github.io/tags/%E6%96%87%E4%BB%B6I-O/"/>
    
  </entry>
  
  <entry>
    <title>函数 open(), creat() 和 openat()</title>
    <link href="http://chunqiublog.github.io/%E5%87%BD%E6%95%B0open_creat%E5%92%8Copenat.html"/>
    <id>http://chunqiublog.github.io/函数open_creat和openat.html</id>
    <published>2018-10-07T04:14:38.000Z</published>
    <updated>2018-10-14T14:22:42.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>注: 基于 <code>release 4.16 of the Linux man-pages project</code> 整理 <code>APUE</code> 中未进行说明或与 <code>Linux</code> 存在不同的内容.</em></p><ul><li>参考: <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener"><code>open(2)</code></a>.</li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li>成功, 返回值是一个非负的整数作为文件描述符用来标识打开的文件, 该值是当前进程文件描述符未使用的最小值; 失败返回 -1.</li><li>默认情况下文件偏移量指向文件开始位置.</li><li>调用 <code>open()</code> 时会创建一个打开文件描述(<code>open file description</code>), 它是整个系统范围内打开文件表中的一项条目. 这个条目记录了当前文件偏移量和文件状态标志(见 <code>APUE 3rd</code> 图 <code>3-7</code>). 文件描述符是打开文件描述的引用; 当 <code>pathname</code> 在之后被删除或被修改指向其他文件, 这个文件描述符也不会受到影响. 对于打开文件描述的进一步介绍, 参考后文<a href="#注意">注意</a>.</li><li><code>UNIX</code> 系统中指定 <code>flags</code> 参数的标志中必选且只能选一种的访问模式: <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_EXEC</code>, <code>O_SEARCH</code>. 而 <code>Linux</code> 实现了 <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code> 三种访问模式(<code>O_PATH</code> 特例, 参考下文介绍).</li><li><p><code>UNIX</code> 系统中指定 <code>flags</code> 参数的剩余标志中, <code>Linux</code> 没有实现 <code>O_TTY_INIT</code> 和 <code>O_RSYNC</code> 标志, 新增了一些标志(只介绍新增的标志或 <code>APUE 3rd</code> 中介绍不全面的标志). <code>Linux</code> 将剩余的标志分为两种:</p><ul><li><p>文件创建标志: 影响打开操作本身的语义, 文件描述符标志.</p><ul><li>非新增标志:<ul><li><code>O_CLOEXEC</code>(<code>Linux 2.6.23</code> 引入):<ul><li>注意, 在一些多线程程序中使用此标志是必要的. 因为使用一个单独的 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> <code>F_SETFD</code> 操作去设置 <code>FD_CLOEXEC</code> 标志无法避免产生竞态条件, 即当一个线程打开一个文件描述符尝试使用 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> 去设置 <code>FD_CLOEXEC</code> 标志时而另一个线程同时使用 <a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener"><code>fork(2)</code></a> 和 <a href="http://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="noopener"><code>execve(2)</code></a>. 根据执行的顺序, 竞争有可能导致 <code>open()</code> 返回的文件描述符被无意泄漏给由 <a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener"><code>fork(2)</code></a> 创建的子进程执行的程序.</li><li>原则上来说, 这种竞争可能发生在任何创建文件描述符的系统调用中, 它们都应该设置执行时关闭(<code>close-on-exec</code>) 标志, 其余各种 <code>Linux</code> 系统调用也都提供了等同于 <code>O_CLOEXEC</code> 标志去处理这个问题(例如, <a href="http://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener"><code>socket(2)</code></a> 的 <code>SOCK_CLOEXEC</code> 标志.</li></ul></li><li><code>O_CREAT</code>:<ul><li>新建文件的所有者(<code>UID</code>) 被设置为当前进程的有效 <code>UID</code>(<code>euid</code>).</li><li>新建文件的所属组(<code>GID</code>) 被设置为当前进程的有效 <code>GID</code>(<code>egid</code>)(<code>System V</code> 语义) 或父目录的 <code>GID</code>(<code>BSD</code> 语义). 在 <code>Linux</code> 上, 具体的行为依赖于父目录的 <code>set-group-ID</code> 权限位是否被设置: 如果这个权限位被设置, 就应用 <code>BSD</code> 语义; 否则就应用 <code>System V</code> 语义. 在一些文件系统中, 具体的行为也依赖于 <a href="http://man7.org/linux/man-pages/man8/mount.8.html" target="_blank" rel="noopener"><code>mount(8)</code></a> 中描述的 <code>badgroups</code> 和 <code>sysvgroups</code> 挂载选项.</li><li><code>mode</code> 参数在 <code>flag</code> 参数中设置了 <code>O_CREAT</code> 和 <code>O_TMPFILE</code> 时必须设置.</li><li>使用 <code>open()</code> 创建一个只读文件可能会返回一个可读/写文件描述符(在 <code>centos release 6.5/7.5.1804</code> 上实测没有发现).</li></ul></li><li><code>O_TRUNC</code>:<ul><li>如果文件已存在并且是常规文件且访问权限允许写入(即，使用 <code>O_RDWR</code> 或 <code>O_WRONLY</code>), 文件的长度将被截断为 <code>0</code>. 如果文件是 <code>FIFO</code> 或终端设备文件, 就忽略 <code>O_TRUNC</code> 标志. 否则, <code>O_TRUNC</code> 的影响未定义.</li><li><code>O_RDONLY | O_TRUNC</code> 的效果(未定义) 是随着具体的实现变化的. 在许多系统上, 文件实际上已被截断.(<code>CentOS Linux release 7.5.1804</code> 上实测已截断.)</li></ul></li></ul></li><li><p>新增标志:</p><ul><li><p><code>O_TMPFILE</code> (<code>Linux 3.11</code> 引入):</p><ul><li>创建一个没有名字的临时文件.</li><li><code>pathname</code> 参数指定一个目录; 在这个目录的文件系统中会创建一个没有命名的 <code>inode</code>. 任何对生成文件的写操作都将会在最后文件描述符被关闭时丢弃, 除非为文件设置一个名字.</li><li><p>指定 <code>O_TMPFILE</code> 时必须指定 <code>O_RDWR</code> 或 <code>O_WRONLY</code> 之一, <code>O_EXCL</code> 为可选项. 如果没有指定 <code>O_EXCL</code>, 可以使用 <a href="http://man7.org/linux/man-pages/man2/linkat.2.html" target="_blank" rel="noopener"><code>linkat(2)</code></a> 将临时文件链接到文件系统, 使其成为永久文件, 使用如下代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">fd = open(<span class="string">"/path/to/dir"</span>, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File I/O on 'fd'... */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(path, PATH_MAX,  <span class="string">"/proc/self/fd/%d"</span>, fd);</span><br><span class="line">linkat(AT_FDCWD, path, AT_FDCWD, <span class="string">"/path/for/file"</span>, AT_SYMLINK_FOLLOW);</span><br></pre></td></tr></table></figure><p>在这种情况下, 通过 <code>open()</code> 的 <code>mode</code> 参数确定文件的权限, 就像使用 <code>O_CREAT</code> 一样.</p></li><li>为 <code>O_TMPFILE</code> 关联指定 <code>O_EXCL</code> 标志可以防止临时文件以上述方式链接到文件系统.(注意: 这种情况下 <code>O_EXCL</code> 的含义和其他情况下 <code>O_EXCL</code> 的含义是不同的.)</li><li>两种使用 <code>O_TMPFILE</code> 的主要情景是:<ol><li>改进 <a href="http://man7.org/linux/man-pages/man3/tmpfile.3.html" target="_blank" rel="noopener"><code>tmpfile(3)</code></a> 功能: 无竞争创建的临时文件:<ol><li>在关闭时自动删除.</li><li>永远不能通过任何路径访问.</li><li>不受符号链接攻击.</li><li>不需要调用者设计唯一的名称.</li></ol></li><li>创建一个原始不可见的文件, 然后填充数据并调整为具有适当的文件系统属性(<a href="http://man7.org/linux/man-pages/man2/fchown.2.html" target="_blank" rel="noopener"><code>fchown(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fchmod.2.html" target="_blank" rel="noopener"><code>fchmod(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fsetxattr.2.html" target="_blank" rel="noopener"><code>fsetxattr(2)</code></a> 等), 然后在完全形成的状态下原子行的链接到文件系统中(使用之前介绍的 <a href="http://man7.org/linux/man-pages/man2/linkat.2.html" target="_blank" rel="noopener"><code>linkat(2)</code></a>).</li></ol></li><li><code>O_TMPFILE</code> 需要底层文件系统支持; 只有一个 <code>Linux</code> 文件系统的一个子集提供支持. 在最初的实现中, <code>ext2</code>, <code>ext3</code>, <code>ext4</code>, <code>UDF</code>, <code>Minix</code> 和 <code>shmem</code> 文件系统提供支持. 随后添加了对其他文件系统的支持, 如 <code>XFS(Linux 3.15)</code>, <code>Btrfs(Linux 3.16)</code>, <code>F2FS(Linux 3.16)</code> 和 <code>ubifs(Linux 4.9)</code>.</li></ul></li></ul></li></ul></li><li><p>文件状态标志: 影响后续 <code>I/O</code> 操作的语义.</p><ul><li>非新增标志:<ul><li><code>O_APPEND</code>:<ul><li><strong>每次</strong> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a> 之前都会像使用 <a href="http://man7.org/linux/man-pages/man2/lseek.2.html" target="_blank" rel="noopener"><code>sleek(2)</code></a> 一样将文件偏移量移动到文件末尾. </li><li>文件偏移量的移动和写操作被作为一个<strong>原子操作</strong>来完成.</li><li>如果多进程同时追加数据到同一个文件, 可能导致 <code>NFS</code> 文件系统上的文件损坏. 这是因为 <code>NFS</code> 不支持在文件后追加的操作, 所以客户端内核必须模拟追加操作, 这(多进程追加操作)一定会产生竞态条件.</li></ul></li><li><code>O_DSYNC</code>:<ul><li>文件的写操作将完全符合同步 <code>I/O</code> 数据完整性实现(<code>synchronized I/O data integrity completion</code>)[^1] 的要求. 参考后文<a href="#注意">注意</a>.</li><li>在 <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a>(或类似写入操作)返回之前, 输出数据以及读取这些数据所需要的元数据都已经被写入底层硬件设备了(即, 就像在<strong>每个</strong> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a> 操作后都调用一次 <a href="http://man7.org/linux/man-pages/man2/fdatasync.2.html" target="_blank" rel="noopener"><code>fdatasync(2)</code></a>). 参考后文<a href="#注意">注意</a>.</li></ul></li><li><code>O_EXCL</code>:<ul><li>当该标志与 <code>O_CREAT</code> 一起被指定, 如果 <code>pathname</code> 参数是一个符号链接, 那么无论符号链接指向何处, <code>open()</code> 函数都会失败.</li><li>通常情况下, 如果不使用 <code>O_CREAT</code>, 那么 <code>O_EXCL</code> 的行为将是未定义的. 在 <code>Linux 2.6</code> 及以后版本, 如果 <code>pathname</code> 参数如果指向一个块设备,  <code>O_EXCL</code> 可以在没有 <code>O_CREAT</code> 的情况下使用. 如果这个块设备正在被系统使用(例如已经挂载), 那么 <code>open()</code> 将会失败, 并产生 <code>EBUSY</code> 错误.</li><li>在 <code>NFS</code> 中, <code>O_EXCL</code> 仅在 <code>NFSv3</code> 及以后版本运行在内核版本大于等于 <code>2.6</code> 的系统上时才会被支持.</li></ul></li><li><code>O_NOFOLLOW</code>:<ul><li>如果 <code>pathname</code> 参数是一个符号链接, 那么 <code>open()</code> 会出错并产生 <code>ELOOP</code> 错误.</li><li>注意: 这种情况下产生的 <code>ELOOP</code> 与因为在解析路径名前缀部分的组件发现太多符号链接而导致 <code>open()</code> 会出错而产生的 <code>ELOOP</code> 错误是无法区分的.</li></ul></li><li><code>O_NONBLOCK</code> 或 <code>O_NDELAY</code>:<ul><li>注意: 这个标志对普通文件或块设备不会生效; 无论是否设置 <code>O_NONBLOCK</code>, <code>I/O</code> 操作在将在需要设备活动时(暂时)阻塞. 因此在为常规文件和块设备指定此标志时, 应用程序不应依赖于阻塞行为. 有关FIFO(有名管道)的处理, 参考 <a href="http://man7.org/linux/man-pages/man7/fifo.7.html" target="_blank" rel="noopener"><code>fifo(7)</code></a>. </li><li><code>O_NONBLOCK</code> 一般用来为 <a href="http://man7.org/linux/man-pages/man2/ioctl.2.html" target="_blank" rel="noopener"><code>ioctl(2)</code></a> 提供一个设备的文件描述符.</li></ul></li><li><code>O_SYNC</code>:<ul><li>文件的写操作将完全符合同步 <code>I/O</code> 文件完整性实现(<code>synchronized I/O file integrity completion</code>)[^1] 的要求(对比 <code>O_DSYNC</code> 中的同步 <code>I/O</code> 数据完整性实现(<code>synchronized I/O data integrity completion</code>)[^1]). 参考后文<a href="#注意">注意</a>.</li><li>在 <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a>(或类似写入操作)返回之前, 输出数据和关联元数据都已经被写入底层硬件设备了(即, 就像在<strong>每个</strong> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a> 操作后都调用一次 <a href="http://man7.org/linux/man-pages/man2/fsync.2.html" target="_blank" rel="noopener"><code>fsync(2)</code></a>). 参考后文<a href="#注意">注意</a>.</li></ul></li></ul></li><li><p>新增标志:</p><ul><li><code>O_ASYNC</code>:<ul><li>启动信号驱动 <code>I/O</code>: 当返回的文件描述符变为可以输入或输出(也可能发生错误)时, 生成一个信号(默认为 <code>SIGIO</code>, 可以通过 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> 修改). </li><li>仅适用于终端, 伪终端, 套接字, 管道(<code>Linux 2.6</code> 引入) 和 <code>FIFO</code>( <code>Linux 2.6</code> 引入). 详细信息参阅 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a>.</li><li>当前存在 <code>BUG</code>, 调用 <code>open()</code> 指定 <code>O_ASYNC</code> 无法启动信号驱动 <code>I/O</code>, 需要使用 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> 去启动这个标志.</li></ul></li><li><code>O_DIRECT</code>(<code>Linux 2.4.10</code> 引入)[^1]:<ul><li>尝试文件 <code>I/O</code> 最小化缓存的效果.</li><li>通常这会降低性能, 但是在例如应用需要操作自己的缓存这种特定的情况下会有用.</li><li>文件 <code>I/O</code> 会直接操作用户空间的缓冲区. </li><li>该标志自身会完成数据同步传输的工作, 但是不能保证像 <code>O_SYNC</code> 一样传输数据和元数据. 为了确保同步 <code>I/O</code>, 在设置 <code>O_DIRECT</code> 时必须设置 <code>O_SYNC</code>.</li></ul></li><li><code>O_LARGEFILE</code>:<ul><li>允许打开文件大小使用 <code>off_t</code> 不能表示(但是可以使用 <code>off64_t</code> 表示)的文件.</li><li>为了使这个标志生效必须定义 <code>_LARGEFILE64_SOURCE</code> 宏(在包含任何头文件之前).</li><li>将 <code>_FILE_OFFSET_BITS</code> 功能测试宏设置为 <code>64</code> (而不是使用 <code>O_LARGEFILE</code>)是在 <code>32</code> 位系统上访问大文件更好的方式(参考 <code>feature_test_macros(7)</code>).[^2]</li></ul></li><li><code>O_NOATIME</code>(<code>Linux 2.6.8</code> 引入):<ul><li>当 <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener"><code>read(2)</code></a> 操作文件时, 不更新文件最后访问时间(<code>inode</code> 中的 <code>st_atime</code>).</li><li>只有以下两个条件中的一个成立时, 这个标志才能生效:<ol><li>当前进程有效 <code>UID</code>(<code>euid</code>) 与 文件的所有者 <code>UID</code> 相匹配.</li><li>调用进程在他的用户命名空间[^3][^4][^5]具有 <code>CAP_FOWNER</code> 能力[^6] 并且文件的 <code>UID</code> 在命名空间中存在映射.</li></ol></li><li>这个标志适用于所有或备份程序, 这时使用这个标志可以显著减少磁盘活动量. </li><li>这个标志可能不是在所有的文件系统上都生效, 例如使用 <code>NFS</code> 服务器会一直维护访问时间.</li></ul></li><li><p><code>O_PATH</code>(<code>Linux 2.6.39</code> 引入):</p><ul><li>获取的文件描述符可用于两个目的:<ol><li>指示文件系统树上的一个位置, 并执行纯粹文件描述符级别的操作.</li><li>文件本身没有被打开, 其余的文件操作(例如 <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener"><code>read(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener"><code>write(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fchmod.2.html" target="_blank" rel="noopener"><code>fchmod(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fchown.2.html" target="_blank" rel="noopener"><code>fchown(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fgetxattr.2.html" target="_blank" rel="noopener"><code>fgetxattr(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/ioctl.2.html" target="_blank" rel="noopener"><code>ioctl(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener"><code>mmap(2)</code></a>) 都会失败并生成 <code>EBADF</code> 错误.</li></ol></li><li>获取的文件描述符可以执行下列操作:<ol><li><a href="http://man7.org/linux/man-pages/man2/close.2.html" target="_blank" rel="noopener"><code>close(2)</code></a>.</li><li><a href="http://man7.org/linux/man-pages/man2/fchdir.2.html" target="_blank" rel="noopener"><code>fchdir(2)</code></a>, 当这个文件描述符表示一个目录时(<code>Linux 3.5</code> 引入).</li><li><a href="http://man7.org/linux/man-pages/man2/fstat.2.html" target="_blank" rel="noopener"><code>fstat(2)</code></a> (<code>Linux 3.6</code> 引入).</li><li><a href="http://man7.org/linux/man-pages/man2/fstatfs.2.html" target="_blank" rel="noopener"><code>fstatfs(2)</code></a> (<code>Linux 3.12</code> 引入).</li><li>复制文件描述符(<a href="http://man7.org/linux/man-pages/man2/dup.2.html" target="_blank" rel="noopener"><code>dup(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> <code>F_DUPFD</code>, 等).</li><li>获取和设置文件描述符标志(<a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> <code>F_GETFD</code> 和 <code>F_SETFD</code>).</li><li>使用 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> <code>F_GETFD</code> 查看文件状态标志: 返回的标志包括 <code>O_PATH</code> 位.</li><li>使用这个文件描述符作为 <code>openat()</code> 和其他 <code>*at()</code> 系统调用的 <code>dirfd</code> 参数. 即使这个文件描述符指向的不是一个目录也可以用于使用 <code>AT_EMPTY_PATH</code>(或通过 <code>procfs</code> 使用 <code>AT_SYMLINK_FOLLOW</code>) 的 <a href="http://man7.org/linux/man-pages/man2/linkat.2.html" target="_blank" rel="noopener"><code>linkat(2)</code></a>.</li><li>通过 <code>UNIX</code> 域套接字将文件描述符传递给其他进程(参考 <a href="http://man7.org/linux/man-pages/man7/unix.7.html" target="_blank" rel="noopener"><code>unix(7)</code></a> 中的 <code>SCM_RIGHTS</code>).</li></ol></li><li>当 <code>flag</code> 参数设置了 <code>O_PATH</code>, 除了 <code>O_CLOEXEC</code>, <code>O_DIRECTORY</code> 和 <code>O_NOFOLLOW</code> 以外的标志位将被忽略.</li><li>使用 <code>O_PATH</code> 表示打开文件或目录不需要检查对象本身的权限(但需要路径前缀的目录具有可执行权限). 而后续的操作可以对进件进行适合的权限检查(例如, <a href="http://man7.org/linux/man-pages/man2/fchdir.2.html" target="_blank" rel="noopener"><code>fchdir(2)</code></a>) 需要文件描述符指向的目录具有可执行权限). 相反的, 即使后续操作(例如, <a href="http://man7.org/linux/man-pages/man2/fchdir.2.html" target="_blank" rel="noopener"><code>fchdir(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fstat.2.html" target="_blank" rel="noopener"><code>fstat(2)</code></a>) 的执行不需要对这个对象具有可读权限, 使用 <code>O_RDONLY</code> 标志打开文件系统上的一个对象也需要调用者具有对这个对象的可读权限.</li><li>如果 <code>pathname</code> 参数是一个符号链接, 并且设置了 <code>O_NOFOLLOW</code> 标志, 这次调用将返回一个指向这个符号链接的文件描述符. 在调用 <a href="http://man7.org/linux/man-pages/man2/fchownat.2.html" target="_blank" rel="noopener"><code>fchownat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fstatat.2.html" target="_blank" rel="noopener"><code>fstatat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/linkat.2.html" target="_blank" rel="noopener"><code>linkat(2)</code></a> 和 <a href="http://man7.org/linux/man-pages/man2/readlinkat.2.html" target="_blank" rel="noopener"><code>readlink(2)</code></a> 路径相关参数为空时, 这个文件描述符可以作为 <code>dirfd</code> 参数用于对这个符号链接的操作.</li><li>如果 <code>pathname</code> 指向的是一个没有被触发的自动挂载节点, 这是没有任何文件系统挂载这个节点, 那么 <code>open()</code> 将返回指向自动挂载目录的文件描述符, 而不会触发挂载. 之后可以使用 <a href="http://man7.org/linux/man-pages/man2/fstatfs.2.html" target="_blank" rel="noopener"><code>fstatfs(2)</code></a> 来确定它是否实际上是未触发的自动挂载点(<code>.f_type == AUTOFS_SUPER_MAGIC</code>).</li><li><p><code>O_PATH</code> 对于普通文件的一种用法是提供一种等价于 <code>POSIX.1</code> 中 <code>O_EXEC</code> 标志的功能. 这允许我们在只有可执行权限却没有可读权限时打开一个文件, 然后执行这个文件. 这类似与下面的步骤:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[PATH_MAX];</span><br><span class="line">fd = open(<span class="string">"some_prog"</span>, O_PATH);</span><br><span class="line"><span class="built_in">snprintf</span>(buf, PATH_MAX, <span class="string">"/proc/self/fd/%d"</span>, fd);</span><br><span class="line">execl(buf, <span class="string">"some_prog"</span>, (<span class="keyword">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>一个使用 <code>O_PATH</code> 打开的文件描述符也可以作为 <a href="http://man7.org/linux/man-pages/man3/fexecve.3.html" target="_blank" rel="noopener"><code>fexecve(3)</code></a> 的参数进行传递.</p></li></ul></li></ul></li></ul></li></ul></li><li><p><code>creat()</code></p><ul><li>等价于 <code>flags</code> 参数为 <code>O_CREAT | O_WRONLY | O_TRUNC</code> 的 <code>open()</code> 函数.</li></ul></li><li><p><code>openat()</code></p><ul><li>用法参考 <code>APUE 3.3</code>.</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><code>open()</code> 可以打开一个指定的设备文件, 但是 <code>create()</code> 不能创建设备文件, 使用 <a href="http://man7.org/linux/man-pages/man2/mknod.2.html" target="_blank" rel="noopener"><code>mknod(2)</code></a> 替代.</li><li>如果是新创建文件, 它的 <code>st_atime</code>, <code>st_ctime</code>, <code>st_mtime</code> 属性(分别是 <code>time of last access</code>, <code>time of last status change</code>, <code>time of last modification</code>, 参考 <a href="http://man7.org/linux/man-pages/man2/stat.2.html" target="_blank" rel="noopener"><code>stat(2)</code></a>) 和它的父目录的 <code>st_ctime</code>, <code>st_mtime</code> 设置为当前时间. 除此之外, 如果文件在设置 <code>O_TRUNC</code> 标志时被修改, 它的 <code>st_ctime</code>, <code>st_mtime</code> 也被设置为当前时间.</li><li><code>/proc/[pid]/fd</code> 目录中的文件表示 <code>PID</code> 为 <code>pid</code> 的进程打开的文件描述符. <code>/proc/[pid]/fdinfo</code> 目录中的文件表示这些文件描述符的详细信息. 可以参考这些目录在 <a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener"><code>proc(5)</code></a> 中的进一步介绍.</li><li>打开文件描述(<code>Open file descriptions</code>)<ul><li>术语打开文件描述(<code>Open file description</code>) 是 <code>POSIX</code> 中规定的整个系统范围内打开文件表中的条目. 在其他的情境中, 这个对象也被称为 <code>open file object</code>, <code>file handle</code>, <code>open file table entry</code> 或被内核开发者称为 <code>struct file</code>.</li><li>当复制(使用 <a href="http://man7.org/linux/man-pages/man2/dup.2.html" target="_blank" rel="noopener"><code>dup(2)</code></a> 或类似方式) 一个文件描述符时, 副本和原始的文件描述符引用的是同一个打开文件描述, 这导致两个文件描述符共享文件偏移量和文件状态标志. 这样的共享也可发生在两个不同的进程中: 子进程通过 <a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener"><code>fork(2)</code></a> 复制了父进程的所有文件描述符, 副本和原始的文件描述符引用的是相同的打开文件描述. 每次调用 <code>open()</code> 会生成一个新的打开文件描述, 因此可能会有多个打开文件描述对应同一个文件 <code>inode</code>.(参考 <code>APUE</code> 中 <code>3.10</code>.)</li><li>在 <code>Linux</code> 中, 可以使用 <a href="http://man7.org/linux/man-pages/man2/kcmp.2.html" target="_blank" rel="noopener"><code>kcmp(2)</code></a> <code>KCMP_FILE</code> 操作去测试是否有两个文件描述符(在同一个进程或不同进程)指向了同一个打开文件描述.</li></ul></li><li>同步 <code>I/O</code>(<code>Synchronized I/O</code>)<ul><li>在 <code>POSIX.1-2008</code> 中 <code>synchronized I/O</code> 定义了不同的变种, 它定义了 <code>open()</code> 用于控制同步行为的 <code>O_SYNC</code>, <code>O_DSYNC</code> 和 <code>O_RSYNC</code> 标志. 无论具体的实现是否支持不同的同步行为, 它都至少必须支持普通文件的 <code>O_SYNC</code>.</li><li><code>Linux</code> 实现了 <code>O_SYNC</code> 和 <code>O_DSYNC</code>, 但是没有实现 <code>O_RSYNC</code>.(准确的说, <code>glibc</code> 中将 <code>O_RSYNC</code> 定义为与 <code>O_SYNC</code> 相同).</li><li><code>O_SYNC</code> 提供同步 <code>I/O</code> 文件完整性实现(<code>synchronized I/O file integrity completion</code>)[^1]: 这意味着写操作将会刷新数据和所有关联的元数据到底层硬件. <code>O_DSYNC</code> 提供同步 <code>I/O</code> 数据完整性实现(<code>synchronized I/O data integrity completion</code>)[^1]: 这意味着写操作将会刷新数据到底层硬件, 但是对于元数据只会刷新后续成功完成读操作所需要更新的元数据. 数据完整性实现可以减少不需要文件完整性实现保证的应用的磁盘操作次数.</li><li>要理解这两种不同实现的区别需要考虑两个文件元数据: 最后修改时间戳(<code>st_mtime</code>) 和文件长度. 所有的写操作都会更新最后修改时间戳, 但是只有在文件为追加写数据时才会改变文件长度. 成功完成一个读操作不需要确保最后修改时间戳是正确的, 但是文件长度需要. 因此 <code>O_DSYNC</code> 只需要保证刷新文件长度元数据的更新(而 <code>O_SYNC</code> 总是也需要刷新最后修改时间戳元数据).</li><li>在 <code>Linux 2.6.33</code> 之前, <code>Linux</code> 为 <code>open()</code> 只实现了 <code>O_SYNC</code> 标志. 然而当指定这个标志时, 大多数文件系统实际提供相当于同步 <code>I/O</code> 数据完整性实现(<code>synchronized I/O data integrity completion</code>)[^1] 的操作(即, <code>O_SYNC</code> 实际上实现了相当于 <code>O_SYNC</code> 的功能).</li><li>从 <code>Linux 2.6.33</code> 开始, 提供了正确的 <code>O_SYNC</code> 的支持. 然而为了确保二进制向后兼容, <code>O_DSYNC</code> 被定义为和就以前的 <code>O_SYNC</code> 相同的标志值, <code>O_SYNC</code> 被定义为一个包含 <code>O_DSYNC</code> 的新标志值(占两位). 这样可以确保使用新的头文件编译的应用程序在 <code>2.6.33</code> 之前的内核上至少可以使用 <code>O_DSYNC</code> 功能.</li></ul></li><li><code>C</code> 函数库和内核的差异<ul><li>从 <code>glibc 2.26</code> 开始, 使用 <code>openat()</code> 系统调用封装 <code>open()</code> 函数, 而不是使用内核的 <code>open()</code> 系统调用. 在某些架构中, <code>glibc 2.26</code> 之前的版本也是这样的.</li></ul></li><li><code>NFS</code><ul><li><code>NFS</code> 基础协议中存在许多不足之处, 其中包括 <code>O_SYNC</code> 和 <code>O_NDELAY</code>.</li><li>当 <code>NFS</code> 文件系统开启 <code>UID</code> 映射时, <code>open()</code> 函数可能会返回一个文件描述符, 但是会出现如 <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener"><code>read(2)</code></a> 请求被拒绝产生 <code>EACCES</code> 错误的情况. 这是因为客户端执行 <code>open()</code> 是会检查权限, 但是 <code>UID</code> 映射时由服务器在读操作和写操作请求时执行的.</li></ul></li><li>文件访问模式<ul><li>与在 <code>flags</code> 参数中能指定的其他值不同, 访问模式 <code>O_RDONLY</code>, <code>O_WRONLY</code> 和 <code>O_RDWR</code> 不能指定单独的位. 相反, 它们被一起定义在 <code>flags</code> 参数的低两位表示, 分别是 <code>0</code>, <code>1</code> 和 <code>2</code>. 也就是说 <code>O_RDONLY</code> 和 <code>O_WRONLY</code> 一起指定是一种逻辑错误, 与 <code>O_RDWR</code> 没有相同含义.</li><li>Linux在 <code>flags</code> 中保留特殊的非标准访问模式 <code>3</code> (二进制 <code>11</code>), 它意味着: 检查文件的读写权限并返回一个不能用于读操作或写操作的文件描述符. 某些 <code>Linux</code> 驱动程序使用这个非标准访问模式来返回仅用于特定设备的 <a href="http://man7.org/linux/man-pages/man2/ioctl.2.html" target="_blank" rel="noopener"><code>ioctl(2)</code></a> 操作的文件描述符.</li></ul></li><li><code>openat()</code> 和其他目录文件描述符 <code>APIs</code> 的基本原理<ul><li>加入目录文件描述符参数的 <code>openat()</code>, 其他系统调用和 <code>C</code> 库函数(即 <a href="http://man7.org/linux/man-pages/man2/execveat.2.html" target="_blank" rel="noopener"><code>execveat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/faccessat.2.html" target="_blank" rel="noopener"><code>faccessat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fanotify_mark.2.html" target="_blank" rel="noopener"><code>fanotify_mark(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fchmodat.2.html" target="_blank" rel="noopener"><code>fchmodat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fchownat.2.html" target="_blank" rel="noopener"><code>fchownat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/fstatat.2.html" target="_blank" rel="noopener"><code>fstatat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/futimesat.2.html" target="_blank" rel="noopener"><code>futimesat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/linkat.2.html" target="_blank" rel="noopener"><code>linkat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/mkdirat.2.html" target="_blank" rel="noopener"><code>mkdirat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/mknodat.2.html" target="_blank" rel="noopener"><code>mknodat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/name_to_handle_at.2.html" target="_blank" rel="noopener"><code>name_to_handle_at(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/readlinkat.2.html" target="_blank" rel="noopener"><code>readlinkat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/renameat.2.html" target="_blank" rel="noopener"><code>renameat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/statx.2.html" target="_blank" rel="noopener"><code>statx(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/symlinkat.2.html" target="_blank" rel="noopener"><code>symlinkat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/unlinkat.2.html" target="_blank" rel="noopener"><code>unlinkat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man2/utimensat.2.html" target="_blank" rel="noopener"><code>utimensat(2)</code></a>, <a href="http://man7.org/linux/man-pages/man3/mkfifoat.3.html" target="_blank" rel="noopener"><code>mkfifoat(3)</code></a> 和 <a href="http://man7.org/linux/man-pages/man3/scandirat.3.html" target="_blank" rel="noopener"><code>scandirat(3)</code></a>) 解决了它们之前旧接口存在的两个问题. 这里虽然是对 <code>openat()</code> 调用的说明, 但是其他接口的基本原理类似.</li><li>第一, <code>openat()</code> 可以使应用程序避免当使用 <code>open()</code> 函数打开一个工作目录以外的目录中的文件时产生的竞态条件. 这种竞态条件的产生是由于提供给 <code>open()</code> 函数的目录前缀的某些部件在调用 <code>open()</code> 函数时被并行修改了. 例如, 假设 <code>dir1/dir2/xxx</code> 文件已经存在, 我们希望创建 <code>dir1/dir2/xxx.dep</code> 文件. 问题是在进行文件是否存在的检查和创建文件两个步骤之间, <code>dir1</code> 或 <code>dir2</code>(可能是符号链接) 可以被改变指向一个不同的地点. 因此, 通过先打开目标目录的文件描述符, 然后再将这个文件描述符作为(举例) <a href="http://man7.org/linux/man-pages/man2/fstatat.2.html" target="_blank" rel="noopener"><code>fstatat(2)</code></a> 或 <code>openat()</code> 的 <code>dirfd</code> 参数使用就可以避免这种竞态. <code>dirfd</code> 文件描述符的使用也有以下的好处:<ul><li>文件描述符是使用目录的稳定引用, 即使使用的目录被改名也不会影响;</li><li>打开的文件描述符可以防止底层文件系统被卸载, 就好像像在文件系统上有一个进程当前的工作目录一样.</li></ul></li><li>第二, <code>openat()</code> 可以通过应用程序维护目录文件描述符实现每个线程一个”当前工作目录”.(这个功能也可以通过基于使用 <code>/proc/self/fd/dirfd</code> 的技巧获得, 但这种做法的效率较低.)</li></ul></li></ul><h3 id="BUGS"><a href="#BUGS" class="headerlink" title="BUGS"></a>BUGS</h3><ul><li>目前无法通过调用 <code>open()</code> 函数指定 <code>O_ASYNC</code> 标志的方式启动信号驱动 <code>I/O</code>; 应使用 <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank" rel="noopener"><code>fcntl(2)</code></a> 开启.</li><li>在尝试确定内核是否支持 <code>O_TMPFILE</code> 功能时, 必须检查两个不同的错误代码 <code>EISDIR</code> 和 <code>ENOENT</code>.</li><li>当在 <code>flags</code> 参数中指定了 <code>O_CREAT</code> 和 <code>O_DIRECTORY</code> 标志且 <code>pathname</code> 指定的文件不存在时, <code>open()</code> 函数将创建一个普通文件(即, 忽略 <code>O_DIRECTORY</code>)(在 <code>centos release 6.5/7.5.1804</code> 上实测生成的文件会具有 <code>setuid</code> 和 <code>setgid</code> 权限).</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.cnblogs.com/suzhou/p/5381738.html" target="_blank" rel="noopener">UNIX高级环境编程（14）文件IO - O_DIRECT和O_SYNC详解</a></li><li><a href="https://blog.csdn.net/do2jiang/article/details/5024427" target="_blank" rel="noopener">Linux下生成1TB的超大文件</a></li><li><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener"><code>namespace(7)</code></a></li><li><a href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html" target="_blank" rel="noopener"><code>user_namespaces(7)</code></a></li><li><a href="https://www.cnblogs.com/sparkdev/p/9462838.html" target="_blank" rel="noopener">Linux Namespace : User</a></li><li><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener"><code>capability(7)</code></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注: 基于 &lt;code&gt;release 4.16 of the Linux man-pages project&lt;/code&gt; 整理 &lt;code&gt;APUE&lt;/code&gt; 中未进行说明或与 &lt;code&gt;Linux&lt;/code&gt; 存在不同的内容.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&quot;http://man7.org/linux/man-pages/man2/open.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pathname, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pathname, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags, &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;creat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pathname, &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dirfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pathname, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dirfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pathname, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags, &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="APUE" scheme="http://chunqiublog.github.io/tags/APUE/"/>
    
      <category term="文件I/O" scheme="http://chunqiublog.github.io/tags/%E6%96%87%E4%BB%B6I-O/"/>
    
  </entry>
  
  <entry>
    <title>POSIX Threads Programming</title>
    <link href="http://chunqiublog.github.io/POSIX_Threads_Programming.html"/>
    <id>http://chunqiublog.github.io/POSIX_Threads_Programming.html</id>
    <published>2018-09-02T04:45:32.000Z</published>
    <updated>2018-10-07T04:07:59.857Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>翻译自: <a href="https://computing.llnl.gov/tutorials/pthreads" target="_blank" rel="noopener">POSIX Threads Programming</a></em></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于<code>UNIX</code> 系统, <code>IEEE POSIX 1003.1c</code> 标准已经规定了一个标准化的 <code>C</code> 语言线程编程接口. 遵循此标准的实现称为 <code>POSIX线程</code> 或 <code>Pthreads</code>.</p><p>本教程首先介绍使用Pthreads的概念, 动机和设计意图. 然后介绍 <code>Pthreads API</code> 中三大种类每一种示例程序: 线程管理, 互斥变量和条件变量. 示例代码始终被用来演示一个新的 <code>Pthreads</code> 程序员所需要的如何使用大多数 <code>Pthread</code>. 本教程最后讨论了 <code>LLNL</code> 细节以及如何将 <code>MPI</code> 与 <code>Pthreads</code> 混合使用. 还包括一个实验练习, 其中包含大量示例代码(C语言).</p><p>水平/先决条件: 本教程非常适合那些不熟悉<code>Pthreads</code>并行编程的人. 需要对 <code>C</code> 中的并行编程有基本的了解. 对于那些一般不熟悉并行编程的人来说, <a href="https://computing.llnl.gov/tutorials/parallel_comp" target="_blank" rel="noopener">EC3500: Introduction to Parallel Computing</a> 中的内容有所帮助.</p><a id="more"></a><h2 id="Pthreads-Overview-Pthreads-概述"><a href="#Pthreads-Overview-Pthreads-概述" class="headerlink" title="Pthreads Overview(Pthreads 概述)"></a><code>Pthreads Overview</code>(<code>Pthreads</code> 概述)</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程?"></a>什么是线程?</h3><ul><li>从技术上讲, 线程被定义为一个可以被操作系统调度运行的独立指令流. 但是这是什么意思?</li><li>对于软件开发者来说, 独立于其主程序运行的 <code>procedure(过程)</code> 的概念可能可以最好的描述一个线程.</li><li>更进一步来说, 假设一个一个主程序(a.out)有多个过程, 这些过程可以被操作系统调度的同时和/或独立运行. 这被称作一个 <code>multi-threaded</code> 程序.</li><li>这是如何完成的?</li><li>在理解线程之前, 首先需要理解 <code>UNIX</code> 进程. 进程由操作系统创建, 需要相当数量的开销负担. 进程包含有关程序资源和程序执行状态的信息如下:<ul><li>进程ID, 进程组ID, 用户ID, 用户组ID</li><li>环境变量</li><li>工作目录</li><li>寄存器</li><li>栈</li><li>堆</li><li>文件描述符</li><li>信号</li><li>动态库</li><li>进程间通信工具(如消息队列, 管道, 信号量或共享内存)</li></ul></li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/unix_process.gif" alt="UNIX PROCESS"></p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threads_within_a_unix_process.gif" alt="THREADS WITHIN A UNIX PROCESS"></p><ul><li>线程使用进程的资源并存在于进程中, 但是线程能够由操作系统调度并作为独立实体运行, 主要是因为线程只复制了使它们可以作为可执行代码存在的基本必需资源.</li><li>这种独立的控制流程能够完成是因为线程维持了它独有的:<ul><li>堆栈指针</li><li>寄存器</li><li>调度属性(例如策略或优先级)</li><li>一组待处理和阻止的信号</li></ul></li><li>总而言之, <code>UNIX</code> 环境中的一个线程:<ul><li>存在于一个进程中, 并使用该进程的资源.</li><li>只要线程的父进程存在且操作系统支持, 它就有自己独立的控制流程.</li><li>仅复制其可独立调度所需的基本资源.</li><li>可以与其他线程共享进程资源, 这些线程同样是独立地, 并且依赖于进程存在.</li><li>如果父进程死亡则死亡(or something similar).</li><li>是 <code>lightweight(轻量级)</code> 的, 因为大部分开销已经通过创建进程完成了.</li></ul></li><li>因为同一进程中的线程共享资源:<ul><li>所有其他线程将看到一个线程对共享系统资源(例如关闭文件)所做的更改.</li><li>具有相同值的两个指针指向相同的数据.</li><li>可以读取和写入相同的存储器位置, 因此需要程序员进行显式同步.</li></ul></li></ul><h3 id="什么是-Pthreads"><a href="#什么是-Pthreads" class="headerlink" title="什么是 Pthreads?"></a>什么是 <code>Pthreads</code>?</h3><ul><li>在历史上, 硬件供应商已经实现了他们自己专有的线程版本. 这些实现彼此差异很大使得程序员很难开发具有可移植性的线程应用程序.</li><li>为了充分利用线程提供的功能, 需要标准化的编程接口:<ul><li>对于 <code>UNIX</code> 系统, 该接口已由 <code>IEEE POSIX 1003.1c</code> 标准(1995)指定.</li><li>遵循此标准的实现称为 <code>POSIX</code> 线程或 <code>Pthreads</code>.</li><li>除了专有 <code>API</code> 之外，大多数硬件供应商现在都提供 <code>Pthreads</code>.</li></ul></li><li><code>POSIX</code> 标准(包括 <code>Pthreads</code> 规范)仍在不断发展和修订.</li><li>一些有用的链接:<ul><li><a href="standards.ieee.org/findstds/standard/1003.1-2008.html">standards.ieee.org/findstds/standard/1003.1-2008.html</a></li><li><a href="www.unix.org/version3/ieee_std.html">www.unix.org/version3/ieee_std.html</a></li><li><a href="www.unix.org/version3/ieee_std.html">www.unix.org/version3/ieee_std.html</a></li></ul></li><li><code>Pthread</code> 被定义为一组 <code>C</code> 语言类型和函数调用, 使用 <code>pthread.h</code> 头文件和一个线程库实现(尽管在某些实现中该库可能是另一个库的一部分, 例如 <code>libc</code>).</li></ul><h3 id="为什么选择-Pthreads"><a href="#为什么选择-Pthreads" class="headerlink" title="为什么选择 Pthreads?"></a>为什么选择 <code>Pthreads</code>?</h3><h4 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h4><ul><li>与创建和管理进程的成本相比, 可以创建一个具有更少操作系统开销的线程. 管理线程比管理进程需要更少的系统资源.</li><li>例如, 下表比较了 <code>fork()</code> 子函数和 <code>pthread_create()</code> 子函数的计时结果. 使用 <code>time</code> 程序计时反映了50000个进程/线程创建, 单位是秒, 没有使用编译优化.</li></ul><p>注意: 不要期望 <code>sys time</code> + <code>user time</code> 等于 <code>real time</code>, 因为这是具有多个 <code>CPUs/cores</code> 的 <code>SMP</code> 系统同时处理该问题.</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/fork_and_pthread.png" alt="fork() vs pthread_create()"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*==============================================================================</span></span><br><span class="line"><span class="comment">C Code for fork() creation test</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFORKS 50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid, j, status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NFORKS; j++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** error handling ***/</span></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"fork failed with error code= %d\n"</span>, pid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** this is the child of the fork ***/</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid ==<span class="number">0</span>) &#123;</span><br><span class="line">    do_nothing();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** this is the parent of the fork ***/</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    waitpid(pid, status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================================</span></span><br><span class="line"><span class="comment">C Code for pthread_create() test</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_nothing</span><span class="params">(<span class="keyword">void</span> *null)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;                      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc, i, j, detachstate;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NTHREADS; j++) &#123;</span><br><span class="line">  rc = pthread_create(&amp;tid, &amp;attr, do_nothing, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (rc) &#123;              </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the thread */</span></span><br><span class="line">  rc = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_join() is %d\n"</span>, rc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/fork_vs_thread.txt" target="_blank" rel="noopener">source</a></p><h4 id="高效的通信-数据交换"><a href="#高效的通信-数据交换" class="headerlink" title="高效的通信/数据交换"></a>高效的通信/数据交换</h4><ul><li>考虑在高性能计算环境中使用 <code>Pthreads</code> 的主要动机是为了实现最佳性能, 特别是当应用程序使用 <code>MPI</code> 进行节点间通信时, 通过使用 <code>Pthreads</code> 可以改善性能.</li><li>MPI</li><li>对于Pthreads, 可以不需要中间内存复制, 因为线程在单个进程中共享同一地址空间; 可以通过指针方便的实现高效的数据传递.</li><li>在最坏的情况下, <code>Pthreads</code> 通信速度更多的变成了缓存到 <code>CPU</code> 或内存到 <code>CPU</code> 的带宽问题, 但是这样的速度仍然远高于 <code>MPI</code> 共享内存通信的速度.</li><li>例如: 这里有一些过去和当前的对比数据如下所示:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/MPI_and_pthread.png" alt="MPI and Pthreads"></p><h4 id="其他常见原因"><a href="#其他常见原因" class="headerlink" title="其他常见原因"></a>其他常见原因</h4><ul><li>与非线程应用程序相比, 线程应用程序在以下几个方面提供了潜在的性能提升和实用优势:<ul><li>当进行 <code>I/O</code> 操作时使用 <code>CPU</code>: 例如, 一个程序可能有长时间 <code>I/O</code> 操作的部分, 当一个线程正在等待 <code>I/O</code> 系统调用完成时, 其他线程可以执行 <code>CPU</code> 密集型工作.</li><li>优先级/实时调度: 更重要的任务可以被调度取代或重大优先级更低的任务.</li><li>异步的事件处理: 可以交错执行有不确定频率和持续时间的服务事件的任务. 例如, <code>Web</code> 服务器既可以从先前的请求传输数据, 也可以管理新请求的到达.</li></ul></li><li>一个完美的例子是典型的 <code>Web</code> 浏览器, 其中许多交错任务可以同时发生, 并且任务可以在优先级上变化.</li><li>另一个很好的例子是现代操作系统, 线程得到了广泛使用, <code>MS Windows</code> 操作系统和使用线程的应用程序的屏幕截图如下所示:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Click_for_larger_image.jpg" alt="Click for larger image"></p><h3 id="设计线程程序"><a href="#设计线程程序" class="headerlink" title="设计线程程序"></a>设计线程程序</h3><h4 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h4><ul><li>在现代的多核机器上, <code>Pthreads</code> 非常适合并行编程. 适用于一般并发编程的都可以使用并发线程程序.</li><li>设计并行程序有很多注意事项, 例如:<ul><li>使用什么类型的并行编程模型?</li><li>问题分区</li><li>负载均衡</li><li>通信</li><li>数据依赖性</li><li>同步和竞争条件</li><li>内存问题</li><li><code>I/O</code> 问题</li><li>程序复杂性</li><li>程序员的努力/成本/时间</li><li>…</li></ul></li><li>这些问题超出了本教程涵盖的范围, 但是感兴趣的读者可以在<a href="https://computing.llnl.gov/tutorials/parallel_comp/" target="_blank" rel="noopener">Introduction to Parallel Computing</a>教程中快速了解概念.</li><li>通常, 为了能够利用 <code>Pthreads</code>, 程序必须能够组织成分散的可以并发执行的独立任务. 例如, 如果函数1和函数2可以被交替执行(实时交错和/或重叠), 它们将可以成为线程.</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/concurrent.gif" alt="concurrent"></p><ul><li>具有以下特征的程序可能非常适合 <code>Pthreads</code>:<ul><li>同时由多个任务执行的工作或操作的数据</li><li>因为长时间 <code>I/O</code> 产生的阻塞</li><li>一些地方消耗大量 <code>CPU</code> 周期, 其他地方不消耗(<code>CPU</code> 使用不均匀)</li><li>必须响应的异步事件</li><li>有些工作比其他工作更重要(优先中断)</li></ul></li><li>存在几种用于线程程序的常见模型<ul><li><code>Manager/worker</code>: 在一个线程(<code>manager</code>)中将工作分配给其他线程(<code>worker</code>). 通常, <code>manager</code> 处理所有输入和封装工作到其他任务中. 在 <code>manager/worker</code> 模式中至少有两种形式是常见的: 静态线程池和动态线程池.</li><li><code>Pipeline</code>: 任务被分解为一系列子操作, 每个子操作都是串行处理的, 但由不同的线程并行处理. 汽车装配线最能描述这种模型.</li><li><code>Peer</code>: 类似于 <code>manager/worker</code> 模型, </li></ul></li></ul><h4 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h4><ul><li>所有线程都可以访问相同的全局共享内存</li><li>线程也有自己的私有数据</li><li>程序员负责同步访问(保护)全局共享数据</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/shared_Memory_Model.gif" alt="Shared Memory Model"></p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul><li>线程安全: 简而言之, 指一个程序具有同时执行多个线程而不破坏共享数据或产生 <code>race conditions</code> 的能力.</li><li>例如, 假设你的应用程序创造几个线程, 每一个线程都调用同一个库函数:<ul><li>这个库函数访问或修改一个全局结构体或指针.</li><li>每一个线程可能会调用这个函数在同一时间去尝试修改这个全局结构体或指针.</li><li>如果函数不使用某种同步的修改方式来防止数据损坏, 那么这个它就不是线程安全的.</li></ul></li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread_Unsafe.gif" alt="Thread Unsafe"></p><ul><li>这意味着使用外部库函数如果不能 <code>100%</code> 确定它是线程安全的, 那么就需要抓住机会解决可能出现的问题.</li><li>建议: 如果应用程序使用没有明确保证线程安全的库或对象, 请务必小心. 如果对线程安全有疑问, 那么除非另有证明, 否则假设它不是线程安全的. 可以通过有序访问有疑问的函数等方式保证线程安全.</li></ul><h4 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h4><ul><li>尽管 <code>Pthreads API</code> 是 <code>ANSI/IEEE</code> 标准, 但是它的实现方式标准并未指定, 通常在不同平台会有所变化.</li><li>因此, 在一个平台上运行良好的程序, 在另一个平台上运行可能失败或产生错误.</li><li>例如, 允许的最大线程数和默认线程堆栈大小是设计程序时要考虑的两个重要限制.</li><li>本教程后面将详细讨论几个线程的限制.</li></ul><h2 id="The-Pthreads-API"><a href="#The-Pthreads-API" class="headerlink" title="The Pthreads API"></a><code>The Pthreads API</code></h2><ul><li><code>ANSI / IEEE POSIX 1003.1-1995</code> 标准中定义了最初的 <code>Pthreads API</code>. <code>POSIX</code> 标准(包括 <code>Pthreads</code> 规范)在不断发展和修订.</li><li>标准的副本可以从IEEE购买或从其他网站免费下载.</li><li>组成 <code>Pthreads API</code> 的函数可以被非正式的划分为四个类别:<ul><li>线程管理: 直接作用于线程的函数 - <code>creating</code>, <code>detaching</code>, <code>joining</code>, 等. 还包括设置/查询线程属性的函数(<code>joinable</code>, <code>scheduling</code>, 等).</li><li>互斥锁: 处理同步的函数, 被称为 <code>mutex</code>, 是 <code>mutual exclusion</code> 的缩写. 互斥函数提供 <code>creating</code>, <code>destroying</code>, <code>locking</code> 和 <code>unlocking</code> 互斥锁功能. 还包括用于设置或修改与互斥锁相关联属性的互斥锁属性函数.</li><li>条件变量: 解决共享互斥锁的线程之间的通信问题的函数. 这基于程序员指定的条件. 这一类包括基于指定条件变量的 <code>create</code>, <code>destroy</code>, <code>wait</code> 和 <code>signal</code> 函数. 还包括用于设置/查询条件变量属性的函数.</li><li>同步: 管理读写锁和同步屏障(barriers)的函数.</li></ul></li><li>命名约定: 线程库以 <code>pthread_</code> 开头作为标识. 如下有一些例子:</li></ul><table><thead><tr><th>Routine Prefix</th><th>Functional Group</th></tr></thead><tbody><tr><td>pthread_</td><td>线程本身和杂项的函数</td></tr><tr><td>pthread_attr_</td><td>线程属性对象</td></tr><tr><td>Pthread_mutex_</td><td>互斥锁</td></tr><tr><td>pthread_mutexattr_</td><td>互斥锁属性对象</td></tr><tr><td>pthread_cond_</td><td>环境变量</td></tr><tr><td>pthread_condattr_</td><td>环境变量属性对象</td></tr><tr><td>pthread_key_</td><td>用于特定线程的数据密钥</td></tr><tr><td>pthread_rwlock_</td><td>读写锁</td></tr><tr><td>pthread_barrier_</td><td>同步屏障</td></tr></tbody></table><ul><li>不透明对象的概念遍及API的设计. 基本调用用于创建或修改不透明对象 - 可以通过调用属性函数来修改和处理不透明对象.</li><li><code>Pthreads API</code> 包含大约100个子函数. 本教程将重点介绍其中的一部分 - 特别是那些对刚刚开始使用 <code>Pthreads</code> 的程序有用的内容.</li><li>为了可移植性, 在使用 <code>Pthreas</code> 库时应该将 <code>pthread.h</code> 包含在每个源文件中.</li><li>当前的 <code>POSIX</code> 标准仅针对 <code>C</code> 语言定义. <code>Fortran</code> 程序员可以使用 <code>C</code> 函数调用的封装. 一些 <code>Fortran</code> 编译器可能提供 <code>Fortran pthreads API</code>.</li><li>有很多关于Pthreads的优秀书籍. 其中一些列在本教程的<a href="#参考和更多信息">参考</a>部分中.</li></ul><h2 id="编译线程程序"><a href="#编译线程程序" class="headerlink" title="编译线程程序"></a>编译线程程序</h2><ul><li>下表列出了几个用于 <code>Pthreads</code> 代码的编译命令示例:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Compiling_Threaded_Programs.png" alt="Compiling Threaded Programs"></p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="创建和终止线程"><a href="#创建和终止线程" class="headerlink" title="创建和终止线程"></a>创建和终止线程</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul><li>最开始, <code>main()</code> 函数包含一个默认线程. 所有其他线程必须由程序员显式创建.</li><li><code>pthread_create</code> 创建一个新的线程并执行它. 这个函数可以在代码任何位置任意调用.</li><li><code>pthread_create</code> 参数:<ul><li><code>thread</code>: 输出参数, 新线程唯一的不透明标识符.</li><li><code>attr</code>: 可用于设置线程属性的不透明属性对象. 你可以指定一个线程属性对象或使用 <code>NULL</code> 的默认值.</li><li><code>start_routine</code>: 线程创建后执行的 <code>C</code> 函数.</li><li><code>arg</code>: 传递给 <code>start_routine</code> 的单个参数, 必须通过转换为 <code>void</code> 类型指针进行传递. 如果不传递参数, 可以使用 <code>NULL</code>.</li></ul></li><li>进程可以创建的最大线程数取决于系统设置. 尝试超出限制的程序可能会失败或产生错误的结果.</li><li>这里以 <code>Linux</code> 为例, 介绍查询和设置系统的线程限制. 下图演示查询默认线程(软)限制, 然后将最大进程(包括线程)数设置为硬限制, 验证设置是否成功.</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/process%28thread%29_num_limit.png" alt="Process(thread) Num Limit"></p><ul><li>一旦创建完成, 线程之间就是平等的, 并且可以创建其他线程. 线程之间没有隐含的层次结构或依赖关系.</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/peer_Threads.gif" alt="Peer Threads"></p><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><ul><li>在默认情况下, 使用某些属性创建一个线程. 这些属性可以被程序员通过线程属性对象修改.</li><li><code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 初始化/销毁线程属性对象.</li><li>之后使用其他函数查询/设置线程属性对象中的特定属性. 属性包括:<ul><li><code>Detached</code>(已分离)或 <code>joinable</code>(可合并)状态</li><li><code>Scheduling inheritance</code></li><li><code>Scheduling policy</code>(调度策略)</li><li><code>Scheduling parameters</code>(调度参数)</li><li><code>Scheduling contention scope</code></li><li>栈大小</li><li>栈地址</li><li><code>Stack guard (overflow) size</code></li></ul></li><li>其中一些属性将在后面讨论.</li></ul><h4 id="线程的绑定和调度"><a href="#线程的绑定和调度" class="headerlink" title="线程的绑定和调度"></a>线程的绑定和调度</h4><ul><li><strong>问题</strong>: 当一个线程被创建后, 你如何知道:<ul><li>操作系统何时调度它运行?</li><li>它将运行在哪个 <code>CPU/core</code>?</li></ul></li></ul><blockquote><p><em>答案: 除非你使用 <code>Pthreads</code> 调度机制, 否则线程的执行位置和时间将由操作系统和系统设置决定. 健壮的程序不应该依赖于以特定顺序或在特定 <code>CPU/core</code> 执行的线程.</em></p></blockquote><ul><li><code>Pthreads API</code> 提供了几个用于指定线程执行调度方式的函数. 例如, 可以将线程以 <code>FIFO</code>(先进先出), <code>RR</code>(循环), <code>OTHER</code>(操作系统确定) 等方式调度. 它还提供了设置线程调度优先级的功能.</li><li>本教程没有涉及这个话题, 但是在 <code>man page</code> 的 <a href="https://computing.llnl.gov/tutorials/pthreads/man/sched_setscheduler.txt" target="_blank" rel="noopener"><code>sched_setscheduler</code></a> 中有它 <code>工作原理</code> 的概述.</li><li><code>Pthreads API</code> 不提供将线程绑定到特定 <code>CPU/core</code> 的函数. 但系统的线程库可能提供了自己实现的这个功能 - 例如提供一个非标准的 <a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt" target="_blank" rel="noopener"><code>pthread_setaffinity_np</code></a> 函数. 请注意, 名称中的 <code>_np</code> 代表 <code>非便携式</code>.</li><li>此外, 操作系统自身也提供这种功能的方法, 例如 <code>Linux</code> 提供了 <a href="https://computing.llnl.gov/tutorials/pthreads/man/sched_setaffinity.txt" target="_blank" rel="noopener"><code>sched_setaffinity</code></a> 函数.</li></ul><h4 id="终止线程-amp-exit"><a href="#终止线程-amp-exit" class="headerlink" title="终止线程 &amp; exit()"></a>终止线程 &amp; <code>exit()</code></h4><ul><li>有几种方法可以终止一个线程:<ul><li>线程执行完启动函数正常退出, 它已经完成工作.</li><li>线程调用 <code>pthread_exit</code> 子函数 - 无论其工作是否完成都会退出.</li><li>线程由另一个线程通过 <code>pthread_cancel</code> 函数取消.</li><li>线程调用 <code>exec()</code> 整个进程将终止被替换为另一个进程; 调用 <code>exit()</code> 这个进程将终止.</li><li>主线程 <code>main()</code> 首先完成, 其他线程将在没有调用 <code>pthread_exit</code> 的情况下终止.</li></ul></li><li><code>pthread_exit()</code> 函数允许程序员指定一个可选的终止 <code>retval</code> 参数. 此可选参数通常返回到 <code>joining</code> 终止线程的线程中(稍后介绍).</li><li>除非想要传回可选参数, 否则在正常执行完成的子程序中, 可以省去调用 <code>pthread_exit()</code>.</li><li>清理: <code>pthread_exit()</code> 函数不会关闭文件; 在线程终止后, 线程内打开的任何文件都将保持打开状态.</li><li>在 <code>main()</code> 中调用 <code>pthread_exit()</code> 的讨论:<ul><li>如果你没有显式调用 <code>pthread_exit()</code>, 但是 <code>main()</code> 函数先于它创建的线程退出, 那么肯定存在问题. <code>main()</code> 创建的所有线程都将终止, 因为它已经退出, 不在支持其他线程.</li><li><code>main()</code> 可以通过在最后显式调用 <code>pthread_exit()</code>, <code>main()</code> 将阻塞并保持活跃状态以支持它创建的线程, 直到它们完成为止.</li></ul></li></ul><h4 id="示例-线程的创建和终止"><a href="#示例-线程的创建和终止" class="headerlink" title="示例: 线程的创建和终止"></a>示例: 线程的创建和终止</h4><ul><li>这是使用 <code>pthread_create()</code> 函数创建 5 个线程的简单示例代码. 每个线程输出 <code>Hello World!</code> 消息, 然后调用 <code>pthread_exit()</code> 退出.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program.  Demonstrates thread creation and</span></span><br><span class="line"><span class="comment">*   termination.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 08/09/11</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">   tid = (<span class="keyword">long</span>)threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello World! It's me, thread #%ld!\n"</span>, tid);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">long</span> t;</span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In main: creating thread %ld\n"</span>, t);</span><br><span class="line">     rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *)t);</span><br><span class="line">     <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello.out" target="_blank" rel="noopener">output</a></p><h3 id="将参数传递给线程"><a href="#将参数传递给线程" class="headerlink" title="将参数传递给线程"></a>将参数传递给线程</h3><ul><li><code>pthread_create()</code> 线程允许程序员将一个参数传递给线程的启动函数. 对于必须传递多个参数的情况, 可以创建一个包含所有参数的结构体, 在 <code>pthread_create()</code> 函数中传递这个结构体的指针实现.</li><li>所有参数必须通过引用传递并转换为 <code>(void *)</code> 类型.</li><li><strong>问题</strong>: 考虑在不确定线程是否启动和调度的情况下, 如何将数据安全的传递给新创建的线程?</li></ul><blockquote><p><em>答案: 确保所有的数据都是线程安全的 - 数据不能被其他线程更改. 接下来的三个示例说明什么是可以做的, 什么是不能做的.</em></p></blockquote><h4 id="线程参数传递示例"><a href="#线程参数传递示例" class="headerlink" title="线程参数传递示例"></a>线程参数传递示例</h4><ul><li>这个代码展示了如何将简单的整型传递给每一个参数. 使用唯一的数据结构变量调用线程, 以确保每个线程的参数在整个程序中保持不变.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg1.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program which demonstrates one safe way</span></span><br><span class="line"><span class="comment">*   to pass arguments to threads during thread creation.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 08/04/15</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *messages[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> taskid;</span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   taskid = (<span class="keyword">long</span>) threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %d: %s\n"</span>, taskid, messages[taskid]);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">long</span> taskids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc, t;</span><br><span class="line"></span><br><span class="line">    messages[<span class="number">0</span>] = <span class="string">"English: Hello World!"</span>;</span><br><span class="line">    messages[<span class="number">1</span>] = <span class="string">"French: Bonjour, le monde!"</span>;</span><br><span class="line">    messages[<span class="number">2</span>] = <span class="string">"Spanish: Hola al mundo"</span>;</span><br><span class="line">    messages[<span class="number">3</span>] = <span class="string">"Klingon: Nuq neH!"</span>;</span><br><span class="line">    messages[<span class="number">4</span>] = <span class="string">"German: Guten Tag, Welt!"</span>; </span><br><span class="line">    messages[<span class="number">5</span>] = <span class="string">"Russian: Zdravstvuyte, mir!"</span>;</span><br><span class="line">    messages[<span class="number">6</span>] = <span class="string">"Japan: Sekai e konnichiwa!"</span>;</span><br><span class="line">    messages[<span class="number">7</span>] = <span class="string">"Latin: Orbis, te saluto!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        taskids[t] = t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %d\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) taskids[t]);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg1.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg1.out" target="_blank" rel="noopener">output</a></p><ul><li>这个示例显示了如何通过结构体设置/传递多个参数. 每个线程都接收一个唯一的结构体实例.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg2.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program which demonstrates another safe way</span></span><br><span class="line"><span class="comment">*   to pass arguments to threads during thread creation.  In this case,</span></span><br><span class="line"><span class="comment">*   a structure is used to pass multiple arguments.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 01/29/09</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *messages[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span>thread_id;</span><br><span class="line">   <span class="keyword">int</span>  sum;</span><br><span class="line">   <span class="keyword">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">thread_data_array</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadarg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> taskid, sum;</span><br><span class="line">   <span class="keyword">char</span> *hello_msg;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> *<span class="title">my_data</span>;</span></span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line">   taskid = my_data-&gt;thread_id;</span><br><span class="line">   sum = my_data-&gt;sum;</span><br><span class="line">   hello_msg = my_data-&gt;message;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %d: %s  Sum=%d\n"</span>, taskid, hello_msg, sum);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> *taskids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc, t, sum;</span><br><span class="line"></span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    messages[<span class="number">0</span>] = <span class="string">"English: Hello World!"</span>;</span><br><span class="line">    messages[<span class="number">1</span>] = <span class="string">"French: Bonjour, le monde!"</span>;</span><br><span class="line">    messages[<span class="number">2</span>] = <span class="string">"Spanish: Hola al mundo"</span>;</span><br><span class="line">    messages[<span class="number">3</span>] = <span class="string">"Klingon: Nuq neH!"</span>;</span><br><span class="line">    messages[<span class="number">4</span>] = <span class="string">"German: Guten Tag, Welt!"</span>; </span><br><span class="line">    messages[<span class="number">5</span>] = <span class="string">"Russian: Zdravstvytye, mir!"</span>;</span><br><span class="line">    messages[<span class="number">6</span>] = <span class="string">"Japan: Sekai e konnichiwa!"</span>;</span><br><span class="line">    messages[<span class="number">7</span>] = <span class="string">"Latin: Orbis, te saluto!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        sum = sum + t;</span><br><span class="line">        thread_data_array[t].thread_id = t;</span><br><span class="line">        thread_data_array[t].sum = sum;</span><br><span class="line">        thread_data_array[t].message = messages[t];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %d\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) </span><br><span class="line">                            &amp;thread_data_array[t]);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg2.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg2.out" target="_blank" rel="noopener">output</a></p><ul><li>这个示例是不正确的参数传递方式. 传递变量 <code>t</code> 的地址会使所有线程可见并且共享内存地址空间.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg3.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This "hello world" Pthreads program demonstrates an unsafe (incorrect)</span></span><br><span class="line"><span class="comment">*   way to pass thread arguments at thread creation.  In this case, the</span></span><br><span class="line"><span class="comment">*   argument variable is changed by the main thread as it creates new threads.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 07/16/14</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> taskid;</span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   taskid = *(<span class="keyword">long</span> *)threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld\n"</span>, taskid);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) &amp;t);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg3.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg3.out" target="_blank" rel="noopener">output</a></p><h3 id="合并和分离线程"><a href="#合并和分离线程" class="headerlink" title="合并和分离线程"></a>合并和分离线程</h3><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> threadid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> threadid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="合并-Joining"><a href="#合并-Joining" class="headerlink" title="合并(Joining)"></a>合并(<code>Joining</code>)</h4><ul><li>“Joining” 是一种完成后的线程与其他线程同步的方式. 例如:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/joining.gif" alt="joining"></p><ul><li><code>pthread_join()</code> 子函数会阻塞当前的线程执行, 直到 <code>threadid</code> 指定的线程终止.</li><li>如果 <code>status</code> 参数在 <code>threadid</code> 指定的目标线程调用 <code>pthread_exit()</code> 中被设置, 那么程序员可以在目标线程终止时获取到 <code>status</code>.</li><li>一个合并的线程可以匹配一个 <code>pthread_join()</code> 调用. 尝试多次合并同一个线程是一个逻辑错误.</li><li>另外两种同步方式互斥和条件变量将在后面讨论.</li></ul><h4 id="是否为可合并的"><a href="#是否为可合并的" class="headerlink" title="是否为可合并的"></a>是否为可合并的</h4><ul><li>当一个线程被创建时, 它的其中一个属性的定义就是该线程是可合并的还是已分离的. 只有以可合并属性创建的线程才可以被合并. 如果一个线程以已分离属性创建, 那么它将永远不能被合并.</li><li><code>POSIX</code> 标准的最终草案规定默认情况下线程应该以可合并属性创建.</li><li>想要显式的以可合并或已分离属性创建一个线程, 要使用 <code>pthread_create()</code> 函数中的 <code>attr</code> 参数. 典型的 4 步流程是:<ol><li>声明一个 <code>pthread_attr_t</code> 数据类型的线程属性变量.</li><li>使用 <code>pthread_attr_init()</code> 初始化属性变量.</li><li>使用 <code>pthread_attr_setdetachstate()</code> 设置属性分离状态.</li><li>当设置完成时, 使用 <code>pthread_attr_destroy()</code> 释放使用的库资源.</li></ol></li></ul><h4 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h4><ul><li><code>pthread_detach()</code> 函数可以显式分离一个线程, 即使这个线程以可合并属性被创建.</li><li>没有作用相反的函数.</li></ul><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul><li>如果一个线程需要合并, 请考虑显式的以可合并属性创建它. 这样做到了可移植性, 因为并非所有实现方式都是默认以可合并属性创建线程.</li><li>如果你提前知道一个线程将永远不会需要合并到另一个线程, 请考虑使用已分离状态创建它. 这样可以释放一些系统资源.</li></ul><h4 id="线程合并示例"><a href="#线程合并示例" class="headerlink" title="线程合并示例"></a>线程合并示例</h4><ul><li>这个示例演示了如何使用 <code>Pthread join</code> 函数”等待”线程完成.</li><li>因为一些 <code>Pthread</code> 的实现可能不是默认使用可合并状态创建线程, 所以这个示例中的线程是显式的使用可合并状态去创建, 以便后面进行合并.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: join.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This example demonstrates how to "wait" for thread completions by using</span></span><br><span class="line"><span class="comment">*   the Pthread join routine.  Threads are explicitly created in a joinable</span></span><br><span class="line"><span class="comment">*   state for portability reasons. Use of the pthread_exit status argument is </span></span><br><span class="line"><span class="comment">*   also shown. Compare to detached.c</span></span><br><span class="line"><span class="comment">* AUTHOR: 8/98 Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED:  01/30/09</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">BusyWork</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">   <span class="keyword">double</span> result=<span class="number">0.0</span>;</span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %ld starting...\n"</span>,tid);</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      result = result + <span class="built_in">sin</span>(i) * <span class="built_in">tan</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %ld done. Result = %e\n"</span>,tid, result);</span><br><span class="line">   pthread_exit((<span class="keyword">void</span>*) t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread[NUM_THREADS];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="keyword">void</span> *status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize and set thread detached attribute */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NUM_THREADS; t++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: creating thread %ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (<span class="keyword">void</span> *)t); </span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free attribute and wait for the other threads */</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NUM_THREADS; t++) &#123;</span><br><span class="line">        rc = pthread_join(thread[t], &amp;status);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_join() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: completed join with thread %ld having a status of %ld\n"</span>,t,(<span class="keyword">long</span>)status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main: program completed. Exiting.\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/join.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/join.out" target="_blank" rel="noopener">output</a></p><h3 id="栈空间管理"><a href="#栈空间管理" class="headerlink" title="栈空间管理"></a>栈空间管理</h3><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstackaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstackaddr</span><span class="params">(<span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="防止栈空间出错"><a href="#防止栈空间出错" class="headerlink" title="防止栈空间出错"></a>防止栈空间出错</h4><ul><li><code>POSIX</code> 标准没有规定一个线程的栈空间大小, 它取决于 <code>POSIX</code> 的实现和系统设置的变化.</li><li>超出默认栈空间限制经常是很容易出现的, 产生的后果是: 程序终止和/或数据被破坏.</li><li>具有安全性和可移植性的程序不能依赖于默认的栈空间大小, 而是通过 <code>pthread_attr_setstacksize</code> 为每个线程显式分配足够的栈空间.</li><li><code>pthread_attr_getstackaddr</code> 和 <code>pthread_addrgetstackaddr</code> 函数可以由特定环境中运行的应用程序使用, 在该环境中线程栈空间必须在放某个特定的内存区域中.</li></ul><h4 id="LC-的一些实际例子"><a href="#LC-的一些实际例子" class="headerlink" title="LC 的一些实际例子"></a>LC 的一些实际例子</h4><ul><li>默认线程栈空间大小变化很大. 可以获取到的最大栈空间大小变化也很大, 且这也依赖于每个系统可以创建的线程数.</li><li>过去和现在的体系结构都显示出默认线程堆空间大小的广泛变化.</li></ul><table><thead><tr><th>系统体系结构</th><th>#CPUs</th><th>Memory(GB)</th><th>Default Size(bytes)</th></tr></thead><tbody><tr><td>Intel Xeon E5-2670</td><td>16</td><td>32</td><td>2,097,152</td></tr><tr><td>Intel Xeon 5660</td><td>12</td><td>24</td><td>2,097,152</td></tr><tr><td>AMD Opteron</td><td>8</td><td>16</td><td>2,097,152</td></tr><tr><td>Intel IA64</td><td>4</td><td>8</td><td>33,554,432</td></tr><tr><td>Intel IA32</td><td>2</td><td>4</td><td>2,097,152</td></tr><tr><td>IBM Power5</td><td>8</td><td>32</td><td>196,608</td></tr><tr><td>IBM Power4</td><td>8</td><td>16</td><td>196,608</td></tr><tr><td>IBM Power3</td><td>16</td><td>16</td><td>98,304</td></tr></tbody></table><h4 id="栈空间管理示例"><a href="#栈空间管理示例" class="headerlink" title="栈空间管理示例"></a>栈空间管理示例</h4><ul><li>这个示例演示了如何获取和设置一个线程的栈空间大小.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEGEXTRA 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dowork</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A[N][N];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">long</span> tid;</span><br><span class="line">    <span class="keyword">size_t</span> mystacksize;</span><br><span class="line"></span><br><span class="line">    tid = (<span class="keyword">long</span>)threadid;</span><br><span class="line">    pthread_attr_getstacksize (&amp;attr, &amp;mystacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld: stack size = %li bytes \n"</span>, tid, mystacksize);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">            A[i][j] = ((i*j)/<span class="number">3.452</span>) + (N-i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NTHREADS];</span><br><span class="line">    <span class="keyword">size_t</span> stacksize;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstacksize (&amp;attr, &amp;stacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Default stack size = %li\n"</span>, stacksize);</span><br><span class="line">    stacksize = <span class="keyword">sizeof</span>(<span class="keyword">double</span>)*N*N+MEGEXTRA;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Amount of stack needed per thread = %li\n"</span>,stacksize);</span><br><span class="line">    pthread_attr_setstacksize (&amp;attr, stacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Creating threads with stack size = %li bytes\n"</span>,stacksize);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NTHREADS; t++)&#123;</span><br><span class="line">        rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (<span class="keyword">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Created %ld threads.\n"</span>, t);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项函数"><a href="#杂项函数" class="headerlink" title="杂项函数"></a>杂项函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>pthread_self</code> 返回一个系统分配的唯一的当前调用线程的线程 <code>ID</code>(线程描述符).</li><li><code>pthread_equal</code> 对比两个线程 <code>ID</code>. 如果两个线程 <code>ID</code> 不同则返回 <code>0</code>, 否则返回一个非零整数.</li><li>注意: 对于这两个函数所使用的线程 <code>ID</code> 对象都是不透明的, 无法轻松检查. 因为线程 <code>ID</code> 是不透明的, 所以不应该使用 <code>C</code> 语言相等运算符 <code>==</code> 来比较两个线程 <code>ID</code> 或者将单个线程 <code>ID</code> 与另一个值进行比较.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</span><br></pre></td></tr></table></figure><ul><li><code>pthread_once</code> 在一个进程中只执行一次 <code>init_routine</code>. 由进程中的任何线程第一次调用该函数是执行给定的没有参数的 <code>init_routine</code>. 任何后续的调用都将是无效的.</li><li><code>init_routine</code> 函数通常是一个初始化的函数.</li><li><code>once_control</code> 参数是一个同步控制结构体，需要在调用 <code>pthread_once</code> 之前进行初始化. 例如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure><h2 id="线程练习一"><a href="#线程练习一" class="headerlink" title="线程练习一"></a>线程练习一</h2><h3 id="入门和线程管理函数"><a href="#入门和线程管理函数" class="headerlink" title="入门和线程管理函数"></a>入门和线程管理函数</h3><blockquote><p>概述:</p><ul><li>使用你的用户名和OTP令牌登录一个LC集群</li><li>将练习文件复制到家目录</li><li>熟悉 LC 的 <code>Pthreads</code> 环境</li><li>写一个简单的“Hello World” <code>Pthreads</code> 程序</li><li>成功编译程序</li><li>成功运行程序 - 使用几种不同的方式</li><li>查看, 编译, 运行和/或调试一些相关的 <code>Pthreads</code> 程序(已提供)</li></ul><p><a href="https://computing.llnl.gov/tutorials/pthreads/exercise.html#Exercise1" target="_blank" rel="noopener"><strong>在这里练习</strong></a></p></blockquote><h2 id="互斥变量"><a href="#互斥变量" class="headerlink" title="互斥变量"></a>互斥变量</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><code>Mutex</code> 是 <code>mutual exclusion</code> 的缩写. 互斥变量是实现线程同步和发生多次写入时保护共享数据的方法之一.</li><li>互斥变量的行为类似以”锁定”的方式保护对共享数据资源的访问, 一般称作互斥锁. 在 <code>Pthread</code> 中使用互斥的基本概念指在任何时间内只有一个线程能锁定(或拥有[^1])一个互斥变量. 因此, 即使多个线程试图锁定互斥锁, 只有一个线程会成功. 在拥有该互斥锁的线程解锁该互斥锁之前，没有其他线程可以拥有该互斥锁.</li><li>互斥锁可以用于防止”竞争(race)”条件. 涉及银行交易竞争条件没有进行同步的示例如下所示:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/race_conditions.png" alt="race conditions"></p><ul><li>在上面的示例中, 当线程使用共享数据资源时应该使用互斥锁来锁定”balance”.</li><li>通常, 拥有互斥锁的线程回去更新全局变量. 这是确保多个线程更新同一个变量时,一个安全的方法. 最终的结果与只有一个线程执行所有更新的结果是相同的. 正在更新的变量属于应该加锁的”关键部分”.</li><li>使用互斥锁的典型顺序如下:<ul><li>创建并初始化互斥变量</li><li>几个线程试图锁定互斥锁</li><li>只有一个成功, 该线程拥有互斥锁</li><li>拥有锁的线程执行一些操作</li><li>拥有者解锁互斥锁</li><li>另一个线程获取互斥锁并重复该过程</li><li>最后互斥锁被销毁</li></ul></li><li>当多个线程去竞争一个互斥锁时, 失败者将阻塞在 <code>lock</code> 调用处 - 通过 <code>trylock</code> 而不是 <code>lock</code> 可以做到非阻塞调用.</li><li>在保护共享数据时, 程序员的责任是确保每个需要使用互斥锁的线程都是这样做的. 例如, 如果4个线程正在更新同一个数据, 但只有一个线程使用了互斥锁, 那么数据仍然可能被破坏.</li></ul><h3 id="创建和销毁互斥锁"><a href="#创建和销毁互斥锁" class="headerlink" title="创建和销毁互斥锁"></a>创建和销毁互斥锁</h3><h4 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li><p>必须使用 <code>pthread_mutex_t</code> 类型声明互斥变量并且初始化后才能使用. 有两种方法可以初始化一个变量:</p><ol><li><p>静态, 声明时初始化. 例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p>动态, 使用 <code>pthread_mutex_init()</code> 函数初始化. 这个方法允许设置互斥对象属性 <code>attr</code>.</p></li></ol><p>互斥锁初始化后默认是解锁的.</p></li><li><p><code>pthread_mutex_init</code> 中的 <code>attr</code> 对象用于为互斥对象设置属性, 如果使用必须是 <code>pthread_mutexattr_t</code> 类型(可以指定为 <code>NULL</code> 以使用默认值). <code>Pthread</code> 标准定义了三个可选的互斥锁属性:</p><ul><li><code>Protocol</code>(协议): 指定用于防止互斥锁的优先级反转的协议.</li><li><code>prioceiling</code>: 指定已初始化的互斥锁的优先级上限.</li><li><code>Process-shared</code>: 指定互斥锁的进程共享.</li></ul><p>请注意, 不是所有实现都可以提供了这三个可选的互斥锁属性.</p></li><li><p><code>pthread_mutexattr_init</code> 和 <code>pthread_mutexattr_destroy</code> 函数分别用于创建和销毁互斥锁属性对象.</p></li><li><p>应该使用 <code>pthread_mutex_destroy</code> 来释放不再需要的互斥对象.</p></li></ul><h3 id="锁定和解锁互斥锁"><a href="#锁定和解锁互斥锁" class="headerlink" title="锁定和解锁互斥锁"></a>锁定和解锁互斥锁</h3><h4 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ul><li>线程使用 <code>pthread_mutex_lock()</code> 对指定参数 <code>mutex</code> 变量进行锁定. 如果这个互斥锁已经被其他线程锁定了, 那么调用这个函数的线程将会阻塞在这个调用处直到这个互斥锁被其他线程解锁.</li><li><code>pthread_mutex_trylock()</code> 会去尝试锁定一个互斥锁. 然而, 如果这个互斥锁已经锁定, 这个函数将立即返回一个”忙碌”的错误代码. 这个函数可能会被用来防止死锁条件, 例如在优先级倒置的情况下.</li><li><code>pthread_mutex_unlock</code> 被拥有互斥锁的线程调用会解锁这个互斥锁. 如果其他线程获取正在包含数据的互斥锁(处于被锁定), 那么在线程完成对被保护数据的访问后需要调用这个函数. 如果出现以下错误, <code>pthread_mutex_unlock</code> 将返回错误:<ul><li>如果互斥锁已经被解锁</li><li>如果互斥锁被另一个线程拥有</li></ul></li><li>互斥锁并没有什么”神奇”的. 事实上, 它类似于所有参与共享数据访问的线程之间的”绅士协议”. 程序员需要确保必要的线程都能正确的使用锁定和解锁调用. 以下方案演示了一个逻辑错误:</li></ul><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/error_lock_unlock.png" alt="Error lock and unlock"></p><ul><li><strong>问题</strong>: 当多个线程正在等待一个被锁定的互斥锁时, 那个线程在释放后将首先锁定这个互斥锁?</li></ul><blockquote><p><em>答案: 除非使用线程优先级调度(未被覆盖), 否则分配的权利将留给本机系统调度程序, 并且可能或多或少是随机的</em>.</p></blockquote><h3 id="使用互斥锁的示例"><a href="#使用互斥锁的示例" class="headerlink" title="使用互斥锁的示例"></a>使用互斥锁的示例</h3><ul><li>这个示例程序展示了在一个计算点积的线程程序中使用互斥变量.</li><li>主要的数据通过全局可访问的结构体提供给所有线程.</li><li>每个线程处理不同的一部分数据.</li><li>主线程等待所有线程完成计算, 然后打印结果总和.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: dotprod_mutex.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This example program illustrates the use of mutex variables </span></span><br><span class="line"><span class="comment">*   in a threads program. This version was obtained by modifying the</span></span><br><span class="line"><span class="comment">*   serial version of the program (dotprod_serial.c) which performs a </span></span><br><span class="line"><span class="comment">*   dot product. The main data is made available to all threads through </span></span><br><span class="line"><span class="comment">*   a globally accessible  structure. Each thread works on a different </span></span><br><span class="line"><span class="comment">*   part of the data. The main thread waits for all the threads to complete </span></span><br><span class="line"><span class="comment">*   their computations, and then it prints the resulting sum.</span></span><br><span class="line"><span class="comment">* SOURCE: Vijay Sonnad, IBM</span></span><br><span class="line"><span class="comment">* LAST REVISED: 01/29/09 Blaise Barney</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">The following structure contains the necessary information  </span></span><br><span class="line"><span class="comment">to allow the function "dotprod" to access its input data and </span></span><br><span class="line"><span class="comment">place its output into the structure.  This structure is </span></span><br><span class="line"><span class="comment">unchanged from the sequential version.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span>      *a;</span><br><span class="line">    <span class="keyword">double</span>      *b;</span><br><span class="line">    <span class="keyword">double</span>     sum; </span><br><span class="line">    <span class="keyword">int</span>     veclen; </span><br><span class="line">&#125; DOTDATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define globally accessible variables and a mutex */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMTHRDS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECLEN 100000</span></span><br><span class="line">DOTDATA dotstr; </span><br><span class="line"><span class="keyword">pthread_t</span> callThd[NUMTHRDS];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutexsum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The function dotprod is activated when the thread is created.</span></span><br><span class="line"><span class="comment">As before, all input to this routine is obtained from a structure </span></span><br><span class="line"><span class="comment">of type DOTDATA and all output from this function is written into</span></span><br><span class="line"><span class="comment">this structure. The benefit of this approach is apparent for the </span></span><br><span class="line"><span class="comment">multi-threaded program: when a thread is created we pass a single</span></span><br><span class="line"><span class="comment">argument to the activated function - typically this argument</span></span><br><span class="line"><span class="comment">is a thread number. All  the other information required by the </span></span><br><span class="line"><span class="comment">function is accessed from the globally accessible structure. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dotprod</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Define and use local variables for convenience */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, start, end, len ;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">double</span> mysum, *x, *y;</span><br><span class="line">    offset = (<span class="keyword">long</span>)arg;</span><br><span class="line"></span><br><span class="line">    len = dotstr.veclen;</span><br><span class="line">    start = offset*len;</span><br><span class="line">    end   = start + len;</span><br><span class="line">    x = dotstr.a;</span><br><span class="line">    y = dotstr.b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Perform the dot product and assign result</span></span><br><span class="line"><span class="comment">to the appropriate variable in the structure. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    mysum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=start; i&lt;end ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        mysum += (x[i] * y[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Lock a mutex prior to updating the value in the shared</span></span><br><span class="line"><span class="comment">structure, and unlock it upon updating.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    pthread_mutex_lock (&amp;mutexsum);</span><br><span class="line">    dotstr.sum += mysum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld did %d to %d:  mysum=%f global sum=%f\n"</span>,offset,start,end,mysum,dotstr.sum);</span><br><span class="line">    pthread_mutex_unlock (&amp;mutexsum);</span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">The main program creates threads which do all the work and then </span></span><br><span class="line"><span class="comment">print out result upon completion. Before creating the threads,</span></span><br><span class="line"><span class="comment">The input data is created. Since all threads update a shared structure, we</span></span><br><span class="line"><span class="comment">need a mutex for mutual exclusion. The main thread needs to wait for</span></span><br><span class="line"><span class="comment">all threads to complete, it waits for each one of the threads. We specify</span></span><br><span class="line"><span class="comment">a thread attribute value that allow the main thread to join with the</span></span><br><span class="line"><span class="comment">threads it creates. Note also that we free up handles  when they are</span></span><br><span class="line"><span class="comment">no longer needed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">double</span> *a, *b;</span><br><span class="line">    <span class="keyword">void</span> *status;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign storage and initialize values */</span></span><br><span class="line"></span><br><span class="line">    a = (<span class="keyword">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    b = (<span class="keyword">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;VECLEN*NUMTHRDS; i++) &#123;</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dotstr.veclen = VECLEN; </span><br><span class="line">    dotstr.a = a; </span><br><span class="line">    dotstr.b = b; </span><br><span class="line">    dotstr.sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutexsum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads to perform the dotproduct  */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUMTHRDS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Each thread works on a different set of data.</span></span><br><span class="line"><span class="comment">   * The offset is specified by 'i'. The size of</span></span><br><span class="line"><span class="comment">   * the data for each thread is indicated by VECLEN.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">        pthread_create(&amp;callThd[i], &amp;attr, dotprod, (<span class="keyword">void</span> *)i); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">/* Wait on the other threads */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUMTHRDS;i++) &#123;</span><br><span class="line">        pthread_join(callThd[i], &amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* After joining, print out the results and cleanup */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Sum =  %f \n"</span>, dotstr.sum);</span><br><span class="line">    <span class="built_in">free</span> (a);</span><br><span class="line">    <span class="built_in">free</span> (b);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutexsum);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/dotprod_serial.c" target="_blank" rel="noopener">Serial version source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/dotprod_mutex.c" target="_blank" rel="noopener">Pthreads version source</a></p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>条件变量为线程提供了另一种同步方式. 互斥锁通过控制对数据的线程访问来实现同步, 而条件变量允许线程根据数据的实际值进行同步.</li><li>如果没有条件变量, 程序员需要让线程去不断轮询(可能在关键部分)检查条件是否得到满足. 这可能是非常消耗资源的, 因为线程将在这个过程中持续忙碌. 条件变量是一种在不用轮询的情况下达到同一效果的方法.</li><li>条件变量始终与互斥锁一起使用.</li><li>使用条件变量的典型顺序如下所示:</li></ul><blockquote><p>Main Thread</p><ul><li>声明并初始化需要同步的全局数据/变量(例如“count”)</li><li>声明并初始化条件变量对象</li><li>声明并初始化关联的互斥锁</li><li>创建线程A和B来完成工作</li></ul><blockquote><p>Thread A</p><ul><li>工作直到必须发生某种情况(例如“计数”必须达到指定值)</li><li>锁定关联的互斥锁并检查全局变量的值</li><li>全局变量的值不满足条件, 调用 <code>pthread_cond_wait()</code> 阻塞在这里等待 <code>Thread B</code> 的信号. 注意: 对 <code>pthread_cond_wait()</code> 的调用会自动并原子的解锁与条件变量关联的互斥锁, 以便 <code>Thread B</code> 可以使用它</li><li>收到信号后, 线程会从阻塞状态被唤醒. 与条件变量关联的互斥锁会自动并原子的锁定</li><li>明确的解锁互斥锁</li><li>继续</li></ul></blockquote><blockquote><p>Thread B</p><ul><li>工作</li><li>锁定与条件变量关联的互斥锁</li><li>更改 <code>Thread A</code> 正在等待的全局变量的值</li><li>检查 <code>Thread A</code> 等待的全局变量的值, 如果它满足所需条件，则向 <code>Thread A</code> 发出信号</li><li>解锁互斥锁</li><li>继续</li></ul></blockquote><p><code>Thread A</code> 与 <code>Thread B</code> 并行运行.</p><p>Main Thread</p><p>​    合并/继续</p></blockquote><h3 id="创建和销毁条件变量"><a href="#创建和销毁条件变量" class="headerlink" title="创建和销毁条件变量"></a>创建和销毁条件变量</h3><h4 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><ul><li><p>必须使用 <code>pthread_cond_t</code> 类型声明条件变量并且初始化后才能使用. 有两种方法可以初始化条件变量:</p><ol><li><p>静态, 声明时初始化. 例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> myconvar = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p>动态, 使用 <code>pthread_cond_init()</code> 函数初始化. 创建的条件变量的 <code>ID</code> 通过 <code>condition</code> 参数返回给调用线程. 这个方法允许设置条件变量对象属性 <code>attr</code>.</p></li></ol></li><li><p>可选的参数 <code>attr</code> 对象用于设置条件变量属性. 条件变量只定义了一个属性: <code>process-shared</code>, 它允许条件变量被其他进程中的线程看到. 如果使用属性对象, 它必须是 <code>pthread_condattr_t</code> 类型(可以指定为 <code>NULL</code> 以使用默认值).</p><p>请注意, 并非所有实现都提供了 <code>process-shared</code> 属性.</p></li><li><p><code>pthread_condattr_init</code> 和 <code>pthread_condattr_destroy</code> 函数用于创建和销毁条件变量属性对象.</p></li><li><p>应该使用 <code>pthread_cond_destroy</code> 来释放不再需要的条件变量.</p></li></ul><h3 id="条件变量等待和发信号"><a href="#条件变量等待和发信号" class="headerlink" title="条件变量等待和发信号"></a>条件变量等待和发信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>pthread_cond_wait()</code> 在收到达到规定条件的信号之前会一直阻塞调用线程. 这个函数应该在锁定互斥锁后调用, 它会在等待时自动释放互斥锁. 当收到信号后会线程会被唤醒, 互斥锁将会被自动锁定以供线程使用. 然后程序员负责在线程处理完成后解锁互斥锁.</p><p><strong>建议</strong>: 调用 <code>pthread_cond_wait()</code> 时使用 <code>WHILE</code> 循环而不是 <code>IF</code> 语句(可以参考下面示例中的 <code>watch_count</code> 函数)来检查等待的条件, 这样可以帮助处理几个潜在的问题, 例如:</p><ul><li>如果多个线程在等待同一个唤醒信号, 当收到信号时, 它们将轮流获取互斥锁, 然后它们中的任何一个线程都可以修改它们等待条件.</li><li>如果线程由于程序错误而收到错误的信号.</li><li>线程库允许在不违反标准的情况下向等待的线程发出虚假唤醒.</li></ul></li><li><p><code>pthread_cond_signal()</code> 函数用于发送信号给(或唤醒)另一个正在使用条件变量等待的线程. 必须在与 <code>pthread_cond_wait()</code> 参数 <code>mutex</code> 相同的互斥锁锁定后才能调用它, 同时为了 <code>pthread_cond_wait()</code> 自动加锁能够执行完成必须要对参数 <code>mutex</code> 相同的互斥锁进行解锁.</p></li><li><p>如果多个线程处于阻塞等待状态, 那么应该使用 <code>pthread_cond_broadcast()</code> 函数而不是 <code>pthread_cond_signal()</code>.</p></li><li><p>在调用 <code>pthread_cond_wait()</code> 之前调用 <code>pthread_cond_signal()</code> 是一个逻辑错误.</p></li></ul><blockquote><p><strong>警告</strong>: 当使用这些函数时, 必须正确锁定和解锁相关联的互斥锁变量. 例如:</p><ul><li>调用 <code>pthread_cond_wait()</code> 之前没有锁定互斥锁可能导致它<strong>不</strong>被阻塞.</li><li>调用 <code>pthread_cond_signal</code> 后没有解锁互斥锁可能不允许对应的 <code>pthread_cond_wait</code> 函数完成(它将保持阻塞状态).</li></ul></blockquote><h3 id="使用条件变量的示例"><a href="#使用条件变量的示例" class="headerlink" title="使用条件变量的示例"></a>使用条件变量的示例</h3><ul><li>这个简单的示例代码演示了几个 <code>Pthread</code> 条件变量相关函数的使用.</li><li><code>main</code> 函数创建了三个线程.</li><li>其中两个线程执行工作并更新 <code>count</code> 变量.</li><li>第三个线程等待, 直到 <code>count</code> 变量达到指定值.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: condvar.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   Example code for using Pthreads condition variables.  The main thread</span></span><br><span class="line"><span class="comment">*   creates three threads.  Two of those threads increment a "count" variable,</span></span><br><span class="line"><span class="comment">*   while the third thread watches the value of "count".  When "count" </span></span><br><span class="line"><span class="comment">*   reaches a predefined limit, the waiting thread is signaled by one of the</span></span><br><span class="line"><span class="comment">*   incrementing threads. The waiting thread "awakens" and then modifies</span></span><br><span class="line"><span class="comment">*   count. The program continues until the incrementing threads reach</span></span><br><span class="line"><span class="comment">*   TCOUNT. The main program prints the final value of count.</span></span><br><span class="line"><span class="comment">* SOURCE: Adapted from example code in "Pthreads Programming", B. Nichols</span></span><br><span class="line"><span class="comment">*   et al. O'Reilly and Associates. </span></span><br><span class="line"><span class="comment">* LAST REVISED: 03/07/17  Blaise Barney</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCOUNT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_LIMIT 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>     count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_threshold_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">inc_count</span><span class="params">(<span class="keyword">void</span> *t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; TCOUNT; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">    Check the value of count and signal waiting thread when condition is</span></span><br><span class="line"><span class="comment">    reached.  Note that this occurs while mutex is locked. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (count == COUNT_LIMIT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d  Threshold reached. "</span>,</span><br><span class="line">                   my_id, count);</span><br><span class="line">            pthread_cond_signal(&amp;count_threshold_cv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Just sent signal.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d, unlocking mutex\n"</span>, </span><br><span class="line">               my_id, count);</span><br><span class="line">        pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do some work so threads can alternate on mutex lock */</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">watch_count</span><span class="params">(<span class="keyword">void</span> *t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Starting watch_count(): thread %ld\n"</span>, my_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Lock mutex and wait for signal.  Note that the pthread_cond_wait routine</span></span><br><span class="line"><span class="comment">  will automatically and atomically unlock mutex while it waits. </span></span><br><span class="line"><span class="comment">  Also, note that if COUNT_LIMIT is reached before this routine is run by</span></span><br><span class="line"><span class="comment">  the waiting thread, the loop will be skipped to prevent pthread_cond_wait</span></span><br><span class="line"><span class="comment">  from never returning.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">    <span class="keyword">while</span> (count &lt; COUNT_LIMIT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Count= %d. Going into wait...\n"</span>, my_id,count);</span><br><span class="line">        pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Condition signal received. Count= %d\n"</span>, my_id,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Updating the value of count...\n"</span>, my_id);</span><br><span class="line">    count += <span class="number">125</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld count now = %d.\n"</span>, my_id, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Unlocking mutex.\n"</span>, my_id);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, rc; </span><br><span class="line">    <span class="keyword">long</span> t1=<span class="number">1</span>, t2=<span class="number">2</span>, t3=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize mutex and condition variable objects */</span></span><br><span class="line">    pthread_mutex_init(&amp;count_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init (&amp;count_threshold_cv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For portability, explicitly create threads in a joinable state */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">0</span>], &amp;attr, watch_count, (<span class="keyword">void</span> *)t1);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">1</span>], &amp;attr, inc_count, (<span class="keyword">void</span> *)t2);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">2</span>], &amp;attr, inc_count, (<span class="keyword">void</span> *)t3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all threads to complete */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n"</span>, </span><br><span class="line">            NUM_THREADS, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up and exit */</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    pthread_mutex_destroy(&amp;count_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;count_threshold_cv);</span><br><span class="line">    pthread_exit (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/condvar.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/condvar.out" target="_blank" rel="noopener">output</a></p><h2 id="Pthreads的监控，调试和性能分析工具"><a href="#Pthreads的监控，调试和性能分析工具" class="headerlink" title="Pthreads的监控，调试和性能分析工具"></a>Pthreads的监控，调试和性能分析工具</h2><p>略</p><h2 id="LLNL特定信息和建议"><a href="#LLNL特定信息和建议" class="headerlink" title="LLNL特定信息和建议"></a>LLNL特定信息和建议</h2><p>略</p><h2 id="未涵盖的主题"><a href="#未涵盖的主题" class="headerlink" title="未涵盖的主题"></a>未涵盖的主题</h2><p>Pthreads API有几个功能本教程未涉及. 这些列在下面. 有关详细信息, 请参考<a href="#`Pthread` 库函数参考"><code>Pthread</code> 库函数参考</a>部分.</p><ul><li>线程调度<ul><li>线程调度方式不同实现将导致线程的运行方式上有所不同. 在大多数情况下, 默认机制就足够了.</li><li><code>Pthreads API</code> 提供了显式设置线程调度策略和优先级的函数, 这些策略和优先级可能会覆盖默认机制.</li><li><code>API</code> 不需要特定的实现来支持这些功能.</li></ul></li><li><code>Keys</code>: 线程特定数据(<code>TSD</code>)<ul><li>当线程调用不同的函数或从不同的函数中返回时, 线程堆空间上的本地数据不断创建和销毁.</li><li>为了保留堆空间上的数据, 你通常需要将其作为参数从一个函数传递到下一个函数, 或者将数据存储在与线程关联的一个全局变量中.</li><li><code>Pthread</code> 提供了另一种通过 <code>Keys</code> 实现这个目的的方法, 这种方法可能更方便, 更多用途.</li></ul></li><li>用于处理“优先级倒置”问题的互斥锁 <code>Protocol</code> 属性和互斥锁优先级管理.</li><li>条件变量共享 - 跨进程</li><li>线程取消(<code>Thread Cancellation</code>)</li><li>线程和信号</li><li>同步构造 - 屏障(<code>barriers</code>)和锁定</li></ul><h2 id="线程练习二"><a href="#线程练习二" class="headerlink" title="线程练习二"></a>线程练习二</h2><h3 id="互斥锁-条件变量和带Pthreads的混合MPI"><a href="#互斥锁-条件变量和带Pthreads的混合MPI" class="headerlink" title="互斥锁, 条件变量和带Pthreads的混合MPI"></a>互斥锁, 条件变量和带Pthreads的混合MPI</h3><blockquote><p>概述:</p><ul><li>使用你的用户名和OTP令牌登录一个LC集群</li><li>将练习文件复制到家目录</li><li>熟悉 LC 的 <code>Pthreads</code> 环境</li><li>写一个简单的“Hello World” <code>Pthreads</code> 程序</li><li>成功编译程序</li><li>成功运行程序 - 使用几种不同的方式</li><li>查看, 编译, 运行和/或调试一些相关的 <code>Pthreads</code> 程序(已提供)</li></ul><p><a href="https://computing.llnl.gov/tutorials/pthreads/exercise.html#Exercise2" target="_blank" rel="noopener"><strong>在这里练习</strong></a></p></blockquote><h2 id="参考和更多信息"><a href="#参考和更多信息" class="headerlink" title="参考和更多信息"></a>参考和更多信息</h2><ul><li>作者: <a href="mailto:blaiseb@llnl.gov" target="_blank" rel="noopener">Blaise Barney</a>, Livermore Computing.</li><li><code>POSIX</code> 标准: <a href="http://www.unix.org/version3/ieee_std.html" target="_blank" rel="noopener">www.unix.org/version3/ieee_std.html</a></li><li><code>Pthreads Programming</code>. B. Nichols et al. O’Reilly and Associates.</li><li><code>Programming With POSIX Threads</code>. D. Butenhof. Addison Wesley</li><li><code>Programming With Threads</code>. S. Kleiman et al. Prentice Hall</li></ul><h2 id="Pthread-库函数参考"><a href="#Pthread-库函数参考" class="headerlink" title="Pthread 库函数参考"></a><code>Pthread</code> 库函数参考</h2><p>为方便起见, 下面提供了按字母顺序排列的Pthread函数列表, 并链接到了相应的手册页.</p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_atfork.txt" target="_blank" rel="noopener">pthread_atfork</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_destroy.txt" target="_blank" rel="noopener">pthread_attr_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getdetachstate.txt" target="_blank" rel="noopener">pthread_attr_getdetachstate</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getguardsize.txt" target="_blank" rel="noopener">pthread_attr_getguardsize</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getinheritsched.txt" target="_blank" rel="noopener">pthread_attr_getinheritsched</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedparam.txt" target="_blank" rel="noopener">pthread_attr_getschedparam</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedpolicy.txt" target="_blank" rel="noopener">pthread_attr_getschedpolicy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getscope.txt" target="_blank" rel="noopener">pthread_attr_getscope</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstack.txt" target="_blank" rel="noopener">pthread_attr_getstack</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstackaddr.txt" target="_blank" rel="noopener">pthread_attr_getstackaddr</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstacksize.txt" target="_blank" rel="noopener">pthread_attr_getstacksize</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_init.txt" target="_blank" rel="noopener">pthread_attr_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setdetachstate.txt" target="_blank" rel="noopener">pthread_attr_setdetachstate</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setguardsize.txt" target="_blank" rel="noopener">pthread_attr_setguardsize</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setinheritsched.txt" target="_blank" rel="noopener">pthread_attr_setinheritsched</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedparam.txt" target="_blank" rel="noopener">pthread_attr_setschedparam</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedpolicy.txt" target="_blank" rel="noopener">pthread_attr_setschedpolicy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setscope.txt" target="_blank" rel="noopener">pthread_attr_setscope</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstack.txt" target="_blank" rel="noopener">pthread_attr_setstack</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstackaddr.txt" target="_blank" rel="noopener">pthread_attr_setstackaddr</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstacksize.txt" target="_blank" rel="noopener">pthread_attr_setstacksize</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_destroy.txt" target="_blank" rel="noopener">pthread_barrier_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_init.txt" target="_blank" rel="noopener">pthread_barrier_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_wait.txt" target="_blank" rel="noopener">pthread_barrier_wait</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_destroy.txt" target="_blank" rel="noopener">pthread_barrierattr_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_getpshared.txt" target="_blank" rel="noopener">pthread_barrierattr_getpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_init.txt" target="_blank" rel="noopener">pthread_barrierattr_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_setpshared.txt" target="_blank" rel="noopener">pthread_barrierattr_setpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cancel.txt" target="_blank" rel="noopener">pthread_cancel</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_pop.txt" target="_blank" rel="noopener">pthread_cleanup_pop</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_push.txt" target="_blank" rel="noopener">pthread_cleanup_push</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_broadcast.txt" target="_blank" rel="noopener">pthread_cond_broadcast</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt" target="_blank" rel="noopener">pthread_cond_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt" target="_blank" rel="noopener">pthread_cond_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_signal.txt" target="_blank" rel="noopener">pthread_cond_signal</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_timedwait.txt" target="_blank" rel="noopener">pthread_cond_timedwait</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_wait.txt" target="_blank" rel="noopener">pthread_cond_wait</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt" target="_blank" rel="noopener">pthread_condattr_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getclock.txt" target="_blank" rel="noopener">pthread_condattr_getclock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getpshared.txt" target="_blank" rel="noopener">pthread_condattr_getpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt" target="_blank" rel="noopener">pthread_condattr_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setclock.txt" target="_blank" rel="noopener">pthread_condattr_setclock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setpshared.txt" target="_blank" rel="noopener">pthread_condattr_setpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt" target="_blank" rel="noopener">pthread_create</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_detach.txt" target="_blank" rel="noopener">pthread_detach</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_equal.txt" target="_blank" rel="noopener">pthread_equal</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_exit.txt" target="_blank" rel="noopener">pthread_exit</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getconcurrency.txt" target="_blank" rel="noopener">pthread_getconcurrency</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getcpuclockid.txt" target="_blank" rel="noopener">pthread_getcpuclockid</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getschedparam.txt" target="_blank" rel="noopener">pthread_getschedparam</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getspecific.txt" target="_blank" rel="noopener">pthread_getspecific</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_join.txt" target="_blank" rel="noopener">pthread_join</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_create.txt" target="_blank" rel="noopener">pthread_key_create</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_delete.txt" target="_blank" rel="noopener">pthread_key_delete</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_kill.txt" target="_blank" rel="noopener">pthread_kill</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_destroy.txt" target="_blank" rel="noopener">pthread_mutex_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_getprioceiling.txt" target="_blank" rel="noopener">pthread_mutex_getprioceiling</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_init.txt" target="_blank" rel="noopener">pthread_mutex_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_lock.txt" target="_blank" rel="noopener">pthread_mutex_lock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_setprioceiling.txt" target="_blank" rel="noopener">pthread_mutex_setprioceiling</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_timedlock.txt" target="_blank" rel="noopener">pthread_mutex_timedlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_trylock.txt" target="_blank" rel="noopener">pthread_mutex_trylock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt" target="_blank" rel="noopener">pthread_mutex_unlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_destroy.txt" target="_blank" rel="noopener">pthread_mutexattr_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprioceiling.txt" target="_blank" rel="noopener">pthread_mutexattr_getprioceiling</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprotocol.txt" target="_blank" rel="noopener">pthread_mutexattr_getprotocol</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getpshared.txt" target="_blank" rel="noopener">pthread_mutexattr_getpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_gettype.txt" target="_blank" rel="noopener">pthread_mutexattr_gettype</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt" target="_blank" rel="noopener">pthread_mutexattr_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprioceiling.txt" target="_blank" rel="noopener">pthread_mutexattr_setprioceiling</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprotocol.txt" target="_blank" rel="noopener">pthread_mutexattr_setprotocol</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setpshared.txt" target="_blank" rel="noopener">pthread_mutexattr_setpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_settype.txt" target="_blank" rel="noopener">pthread_mutexattr_settype</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_once.txt" target="_blank" rel="noopener">pthread_once</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_destroy.txt" target="_blank" rel="noopener">pthread_rwlock_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_init.txt" target="_blank" rel="noopener">pthread_rwlock_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_rdlock.txt" target="_blank" rel="noopener">pthread_rwlock_rdlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedrdlock.txt" target="_blank" rel="noopener">pthread_rwlock_timedrdlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedwrlock.txt" target="_blank" rel="noopener">pthread_rwlock_timedwrlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_tryrdlock.txt" target="_blank" rel="noopener">pthread_rwlock_tryrdlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_trywrlock.txt" target="_blank" rel="noopener">pthread_rwlock_trywrlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_unlock.txt" target="_blank" rel="noopener">pthread_rwlock_unlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_wrlock.txt" target="_blank" rel="noopener">pthread_rwlock_wrlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_destroy.txt" target="_blank" rel="noopener">pthread_rwlockattr_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_getpshared.txt" target="_blank" rel="noopener">pthread_rwlockattr_getpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_init.txt" target="_blank" rel="noopener">pthread_rwlockattr_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_setpshared.txt" target="_blank" rel="noopener">pthread_rwlockattr_setpshared</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_self.txt" target="_blank" rel="noopener">pthread_self</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcancelstate.txt" target="_blank" rel="noopener">pthread_setcancelstate</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcanceltype.txt" target="_blank" rel="noopener">pthread_setcanceltype</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setconcurrency.txt" target="_blank" rel="noopener">pthread_setconcurrency</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedparam.txt" target="_blank" rel="noopener">pthread_setschedparam</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedprio.txt" target="_blank" rel="noopener">pthread_setschedprio</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setspecific.txt" target="_blank" rel="noopener">pthread_setspecific</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_sigmask.txt" target="_blank" rel="noopener">pthread_sigmask</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_destroy.txt" target="_blank" rel="noopener">pthread_spin_destroy</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_init.txt" target="_blank" rel="noopener">pthread_spin_init</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_lock.txt" target="_blank" rel="noopener">pthread_spin_lock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_trylock.txt" target="_blank" rel="noopener">pthread_spin_trylock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_unlock.txt" target="_blank" rel="noopener">pthread_spin_unlock</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_testcancel.txt" target="_blank" rel="noopener">pthread_testcancel</a></p><p>[^1]: 译者注: 这里拥有的意思是当一个互斥变量被锁定时, 锁定的线程占有这个互斥变量的使用权, 其他线程无法使用.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;翻译自: &lt;a href=&quot;https://computing.llnl.gov/tutorials/pthreads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POSIX Threads Programming&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于&lt;code&gt;UNIX&lt;/code&gt; 系统, &lt;code&gt;IEEE POSIX 1003.1c&lt;/code&gt; 标准已经规定了一个标准化的 &lt;code&gt;C&lt;/code&gt; 语言线程编程接口. 遵循此标准的实现称为 &lt;code&gt;POSIX线程&lt;/code&gt; 或 &lt;code&gt;Pthreads&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;本教程首先介绍使用Pthreads的概念, 动机和设计意图. 然后介绍 &lt;code&gt;Pthreads API&lt;/code&gt; 中三大种类每一种示例程序: 线程管理, 互斥变量和条件变量. 示例代码始终被用来演示一个新的 &lt;code&gt;Pthreads&lt;/code&gt; 程序员所需要的如何使用大多数 &lt;code&gt;Pthread&lt;/code&gt;. 本教程最后讨论了 &lt;code&gt;LLNL&lt;/code&gt; 细节以及如何将 &lt;code&gt;MPI&lt;/code&gt; 与 &lt;code&gt;Pthreads&lt;/code&gt; 混合使用. 还包括一个实验练习, 其中包含大量示例代码(C语言).&lt;/p&gt;
&lt;p&gt;水平/先决条件: 本教程非常适合那些不熟悉&lt;code&gt;Pthreads&lt;/code&gt;并行编程的人. 需要对 &lt;code&gt;C&lt;/code&gt; 中的并行编程有基本的了解. 对于那些一般不熟悉并行编程的人来说, &lt;a href=&quot;https://computing.llnl.gov/tutorials/parallel_comp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EC3500: Introduction to Parallel Computing&lt;/a&gt; 中的内容有所帮助.&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="翻译" scheme="http://chunqiublog.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="线程" scheme="http://chunqiublog.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用户堆栈扩展</title>
    <link href="http://chunqiublog.github.io/%E7%94%A8%E6%88%B7%E5%A0%86%E6%A0%88%E6%89%A9%E5%B1%95.html"/>
    <id>http://chunqiublog.github.io/用户堆栈扩展.html</id>
    <published>2018-02-13T05:10:01.000Z</published>
    <updated>2018-10-07T04:13:06.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在 <code>越界访问</code> 中, 对于 <code>do_page_fault()</code> 的分析只进行了部分, 只分析了 <code>find_vma</code> 返回 <code>vma</code> 紧邻其上的区间不是栈区的处理情况. 这里分析一下如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况.</p><a id="more"></a><p>&emsp;&emsp;当系统为一个进程分配的栈空间已经被使用完, 栈顶指针 <code>%esp</code> 已经指向已映射的栈区区间的开始地址(栈自顶而下分配空间)时, 如果出现新的函数调用, 就需要先将函数的参数入栈到 <code>%esp - 4</code> 的位置, 但是由于栈区区间已经到达开始地址, 再向下就是还没有映射的空洞. 在访问 <code>%esp - 4</code> 时, 就会发生一次页面出错异常.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/i386/mm/fault.c [do_page_fault()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间</span></span><br><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="comment">// 用户程序越界访问系统空间</span></span><br><span class="line"><span class="keyword">if</span> (!vma)</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="comment">// vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中</span></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_start &lt;= address)</span><br><span class="line"><span class="keyword">goto</span> good_area;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VM_GROWSDOWN 表示当前 vma 处于栈区</span></span><br><span class="line"><span class="comment">// 紧邻其上的不是是一个栈区区间, 当前的空间没有建立映射或映射已经被销毁</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射的空洞紧邻其上的是一个栈区区间</span></span><br><span class="line"><span class="comment">// 处于用户模式</span></span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * accessing the stack below %esp is always a bug.</span></span><br><span class="line"><span class="comment"> * The "+ 32" is there due to some instructions (like</span></span><br><span class="line"><span class="comment"> * pusha) doing post-decrement on the stack and that</span></span><br><span class="line"><span class="comment"> * doesn't show up until later..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 访问 %esp 所指向的栈顶之下的空间总是一个 bug.</span></span><br><span class="line"><span class="comment"> * 由于一些指令(如 pusha)会使 %esp 做递减, 并在更下面的位置,</span></span><br><span class="line"><span class="comment"> * 所以会 "+ 32"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在参数入栈时一次入栈最多通过 pusha 入栈 32 个字节</span></span><br><span class="line"><span class="comment">// 所以如果访问的位置超出 32 个字节说明访问的页面出错异常不是堆栈扩展造成的</span></span><br><span class="line"><span class="keyword">if</span> (address + <span class="number">32</span> &lt; regs-&gt;esp)</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本次页面出错异常是堆栈扩展造成的</span></span><br><span class="line"><span class="comment">// 扩展堆栈: expand_stack 建立页面映射并扩展栈区</span></span><br><span class="line"><span class="keyword">if</span> (expand_stack(vma, address))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;出现页面出错异常在 <code>vma</code> 排除其他三种情况(<code>if (!vma)</code>, <code>if (vma-&gt;vm_start &lt;= address)</code>, <code>if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</code>)后, 剩下的就是如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. 这时也分为两种可能:</p><blockquote><ul><li>由于栈区空间被使用完, 栈空间自顶向下扩展时产生的页面出错异常.</li><li>由于内存非法越界访问, 访问的地址落入栈空间与堆空间的空洞中.</li></ul></blockquote><p>&emsp;&emsp;区分这两种可能是使用访问地址的位置进行判断. 栈空间扩展都是先参数入栈, 然后再开辟栈帧. 当参数入栈时, 通常是一次压入 <code>4</code> 个字节, 这时访问的虚拟地址为 <code>%esp - 4</code>, 但在 <code>i386</code> CPU 中有一个 <code>pusha</code> 指令, 一次可以将 <code>32</code> 个字节(8 个 32 位寄存器的内容)压入栈空间. 所以如果是栈区扩展产生的页面出错异常那么访问的虚拟地址就会在 <code>%esp - 32</code> 及其以上的区域, 否则访问的地址就会低于 <code>%esp - 32</code>, 出现这种情况的处理方式与 <code>越界访问</code> 中的处理方式相同.</p><p>&emsp;&emsp;当确认页面出错异常为扩展栈空间的要求时, 就要开始从当前空洞的顶部为栈空间扩展: 建立页面映射, 并将之并入栈区区间(<code>if (expand_stack(vma, address))</code>).</p><h2 id="扩展栈区"><a href="#扩展栈区" class="headerlink" title="扩展栈区"></a>扩展栈区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm.h [do_page_fault() &gt; expand_stack()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* vma is the first one with  address &lt; vma-&gt;vm_end,</span></span><br><span class="line"><span class="comment"> * and even  address &lt; vma-&gt;vm_start. Have to extend vma.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数 vma 是第一个 address &lt; vma-&gt;vm_end 甚至 address &lt; vma-&gt;vm_start 的区间. </span></span><br><span class="line"><span class="comment"> * 必须扩展 vma</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">// 将栈区自顶向下扩展</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expand_stack</span><span class="params">(struct vm_area_struct * vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> grow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将地址按照页面边界对齐</span></span><br><span class="line">address &amp;= PAGE_MASK;</span><br><span class="line"><span class="comment">// 获取扩展页面数</span></span><br><span class="line">grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="comment">// 进程栈空间的大小超过了限制的最大值或进程可用存储区超过了限制的最大长度</span></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_end - address &gt; current-&gt;rlim[RLIMIT_STACK].rlim_cur ||</span><br><span class="line">    ((vma-&gt;vm_mm-&gt;total_vm + grow) &lt;&lt; PAGE_SHIFT) &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展栈区</span></span><br><span class="line">vma-&gt;vm_start = address;</span><br><span class="line">vma-&gt;vm_pgoff -= grow;</span><br><span class="line">vma-&gt;vm_mm-&gt;total_vm += grow;</span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_LOCKED)</span><br><span class="line">vma-&gt;vm_mm-&gt;locked_vm += grow;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于系统资源有限, 所以进程对各种资源的使用有限制. 每个进程的 <code>task_struct</code> 结构中都有一个 <code>rlim</code> 结构数组规定了每种资源分配的使用限制. 代码中的 <code>RLIMIT_STACK</code> 限制了栈的最大大小, <code>RLIMIT_AS</code> 限制了进程可用存储区的最大长度(字节). 如果扩展以后栈区大小超过了限制的最大值或者动态分配的页面总量超过了可用于该进程的资源限制, 就不能再扩展了, 返回一个 <code>-ENOMEM</code> 的出错代码.</p><p>&emsp;&emsp;<code>expand_stack()</code> 函数扩展栈区以<strong>页面</strong>为单位进行扩展, 只是改变栈区的 <code>vm_area_struct</code> 结构, 并未建立起新扩展的页面对物理内存的映射.</p><p>&emsp;&emsp;从 <code>expand_stack()</code> 函数中正确返回, 会进入 <code>do_page_fault()</code> 函数的 <code>good_vma</code> 中, 表示访问的地址在一个 <code>vma</code> 中, 这里会根据 <code>error_code</code> 判断页面出错异常出错原因.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/i386/mm/fault.c [do_page_fault()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles page faults.  It determines the address,</span></span><br><span class="line"><span class="comment"> * and the problem, and then passes it off to one of the appropriate</span></span><br><span class="line"><span class="comment"> * routines.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * error_code:</span></span><br><span class="line"><span class="comment"> *bit 0 == 0 means no page found, 1 means protection fault</span></span><br><span class="line"><span class="comment"> *bit 1 == 0 means read, 1 means write</span></span><br><span class="line"><span class="comment"> *bit 2 == 0 means kernel, 1 means user-mode</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 错误代码:</span></span><br><span class="line"><span class="comment"> *  bit 0 == 0 表示未找到页面, 1 表示保护错误</span></span><br><span class="line"><span class="comment"> *  bit 1 == 0 表示读取, 1 表示写入</span></span><br><span class="line"><span class="comment"> *  bit 2 == 0 表示内核, 1 表示用户模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 处理页面错误异常(缺页中断)</span></span><br><span class="line"><span class="comment">// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本</span></span><br><span class="line"><span class="comment">// error_code           指明映射失败原因</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_page_fault</span><span class="params">(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;出现页面出错异常是由于需要压栈, 即数据写入(<code>error_code</code> 中 <code>bit 1 == 1</code>). 已经扩展了 <code>vm_area_struct</code> 但是没有建立物理页面的映射, 即物理页面不存在(<code>error_code</code> 中 <code>bit 0 == 0</code>).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/i386/mm/fault.c [do_page_fault()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment"> * we can handle it..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对于这次内存访问, 我们有一个好的 vm_area_struct, 因此我们可以处理它..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">good_area:</span><br><span class="line">info.si_code = SEGV_ACCERR;</span><br><span class="line">write = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">/* 3: write, present */</span> <span class="comment">/* 出错指令为读操作, 物理页面在内存中 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_VERIFY_AREA</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;cs == KERNEL_CS)</span><br><span class="line">printk(<span class="string">"WP fault at %08lx\n"</span>, regs-&gt;eip);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">/* write, not present */</span> <span class="comment">/* 出错指令为写操作, 物理页面不在内存中 */</span></span><br><span class="line"><span class="comment">// 检查当前 vma 是否可写</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">write++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">/* read, present */</span> <span class="comment">/* 出错指令为读操作, 物理页面在内存中 */</span></span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">/* read, not present */</span> <span class="comment">/* 出错指令为读操作, 物理页面不在内存中 */</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If for any reason at all we couldn't handle the fault,</span></span><br><span class="line"><span class="comment"> * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment"> * the fault.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果因为任何原因我们无法处理错误, 请确保我们优雅的退出, 而不是无休止的重复处理错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (handle_mm_fault(mm, vma, address, write)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> do_sigbus;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> out_of_memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Did it hit the DOS screen memory VA from vm86 mode?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 处理与 VM86 模式及 VGA 的图像存储区相关的特殊情况</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;eflags &amp; VM_MASK) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> bit = (address - <span class="number">0xA0000</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">32</span>)</span><br><span class="line">tsk-&gt;thread.screen_bitmap |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">&#125;</span><br><span class="line">up(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以 <code>switch (error_code &amp; 3)</code> 时会进入 <code>case 2:</code> 分支检查当前 <code>vm_area_struct</code> 是否可写, 不可写与 <code>越界访问</code> 处理方式相同. 可写进入 <code>handle_mm_fault()</code> 函数.</p><h2 id="建立映射"><a href="#建立映射" class="headerlink" title="建立映射"></a>建立映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c [do_page_fault() &gt; handle_mm_fault()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By the time we get here, we already hold the mm semaphore</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当我们到达这里, 我们已经有了 mm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 处理页面映射过程中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_mm_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct * vma,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">int</span> write_access)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前虚拟地址所在的 pgd_t 指针</span></span><br><span class="line">pgd = pgd_offset(mm, address);</span><br><span class="line"><span class="comment">// 获取当前虚拟地址所在的 pmd_t 指针</span></span><br><span class="line">pmd = pmd_alloc(pgd, address);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果虚拟地址所在 pmd_t 指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (pmd) &#123;</span><br><span class="line"><span class="comment">// 获取当前虚拟地址所在的 pte_t 指针</span></span><br><span class="line"><span class="keyword">pte_t</span> * pte = pte_alloc(pmd, address);</span><br><span class="line"><span class="comment">// 如果虚拟地址所在 pte_t 指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (pte)</span><br><span class="line">ret = handle_pte_fault(mm, vma, address, write_access, pte);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;先获取虚拟地址所在的页目录项指针. 页目录总是存在的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; pgd_offset()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to find an entry in a page-table-directory. */</span></span><br><span class="line"><span class="comment">/* 在页目录中查找虚拟地址所在的页目录项 */</span></span><br><span class="line"><span class="comment">// 获取页目录中虚拟地址所在下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pgd_index(address) ((address &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pgd_offset(address) pgd_index(address)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页目录中虚拟地址所在的页目录项的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pgd_offset(mm, address) ((mm)-&gt;pgd+pgd_index(address))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后获取虚拟地址所在的中间目录项指针. 由于 <code>i386</code> CPU 中没有使用 <code>PMD</code>, 所以把页目录项当做只有一个表项的 <code>PMD</code>, 所以 <code>pmd_alloc()</code> 绝对不会执行失败. 所以 <code>handle_mm_fault()</code> 中的 <code>pmd</code> 绝对不会为 <code>0</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgalloc-2level.h [do_page_fault() &gt; handle_mm_fault() &gt; pmd_alloc()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中间目录中查找虚拟地址所在的中间目录项</span></span><br><span class="line"><span class="comment">// i386 中没有启用 PMD, 把页目录项当做只有一个表项的 PMD</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> pmd_t * <span class="title">pmd_alloc</span><span class="params">(<span class="keyword">pgd_t</span> *pgd, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!pgd)</span><br><span class="line">BUG();</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">pmd_t</span> *) pgd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其次获取虚拟地址所在的页表项指针. 中间目录项指针有可能指向一个存在的页表, 可以直接获取页表项指针; 也有可能中间目录项为空, 页表不存在, 需要在 <code>getnew</code> 中申请一个新的页表. <strong>一个页表与一个物理页面大小相同, 内核中对页面表的分配作了一些优化. 当释放一个页表时, 内核将释放的页表保存在页表缓存池中, 而不直接释放物理内存页面. 只有在缓存池已满的情况下才真正将页表所占用的物理内存页面释放</strong>. 如果页表缓存池中有页表, 就直接获取, 如果没有则使用 <code>get_pte_slow()</code> 获取页表, 这时如果物理内存页面用完, 则需要将长时间没有使用的物理内存页面交换到磁盘上去, 获取页表的速度会很慢.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgalloc.h [do_page_fault() &gt; handle_mm_fault() &gt; pte_alloc()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页表中查找虚拟地址所在的页表项</span></span><br><span class="line"><span class="comment">// 如果页表不存在则创建页表</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> pte_t * <span class="title">pte_alloc</span><span class="params">(<span class="keyword">pmd_t</span> * pmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取虚拟地址所在物理页面指针在页表中的下标</span></span><br><span class="line">address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 pmd_t 是否为空</span></span><br><span class="line"><span class="keyword">if</span> (pmd_none(*pmd))</span><br><span class="line"><span class="keyword">goto</span> getnew;</span><br><span class="line"><span class="comment">// 判断中间目录项权限是否正确</span></span><br><span class="line"><span class="keyword">if</span> (pmd_bad(*pmd))</span><br><span class="line"><span class="keyword">goto</span> fix;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">pte_t</span> *)pmd_page(*pmd) + address;</span><br><span class="line"><span class="comment">// 获取一个新的页表</span></span><br><span class="line">getnew:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从页表缓存池中获取一页页表</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) get_pte_fast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判读是否缓存池已空</span></span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> get_pte_slow(pmd, address); <span class="comment">// 获取页表, 返回给定偏移量位置的页表项指针</span></span><br><span class="line"><span class="comment">// 将获取的页表绑定到中间目录项中</span></span><br><span class="line">set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(page)));</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">pte_t</span> *)page + address;</span><br><span class="line">&#125;</span><br><span class="line">fix:</span><br><span class="line">__handle_bad_pmd(pmd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后就是映射到物理页面本身了, 对应到栈区扩展的情况, 物理内存页面还没有分配, 所以物理页面不在内存中, 一定会进入 <code>if (!pte_present(entry))</code>, 对应的页表项也一定会为空, 一定会进入 <code>if (pte_none(entry))</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines also need to handle stuff like marking pages dirty</span></span><br><span class="line"><span class="comment"> * and/or accessed for architectures that don't do it in hardware (most</span></span><br><span class="line"><span class="comment"> * RISC architectures).  The early dirtying is also good on the i386.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这些程序也需要处理如硬件体系结构(大部分为 RISC 体系结构)无法做到的设置页面脏和/或已访问.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is also a hook called "update_mmu_cache()" that architectures</span></span><br><span class="line"><span class="comment"> * with external mmu caches can use to update those (ie the Sparc or</span></span><br><span class="line"><span class="comment"> * PowerPC hashed page tables that act as extended TLBs).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note the "page_table_lock". It is to protect against kswapd removing</span></span><br><span class="line"><span class="comment"> * pages from under us. Note that kswapd only ever _removes_ pages, never</span></span><br><span class="line"><span class="comment"> * adds them. As such, once we have noticed that the page is not present,</span></span><br><span class="line"><span class="comment"> * we can drop the lock early.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The adding of pages is protected by the MM semaphore (which we hold),</span></span><br><span class="line"><span class="comment"> * so we don't need to worry about a page being suddenly been added into</span></span><br><span class="line"><span class="comment"> * our VM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">struct vm_area_struct * vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> write_access, <span class="keyword">pte_t</span> * pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need the page table lock to synchronize with kswapd</span></span><br><span class="line"><span class="comment"> * and the SMP-safe atomic PTE updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">spin_lock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">entry = *pte;</span><br><span class="line"><span class="comment">// 判断 PTE 的 P 标志位和第 8 位是否设置(查看物理页面是否在内存中)</span></span><br><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it truly wasn't present, we know that kswapd</span></span><br><span class="line"><span class="comment"> * and the PTE updates will not touch it later. So</span></span><br><span class="line"><span class="comment"> * drop the lock.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果它确实不存在, 我们知道 kswapd 和 PTE 更新不会稍后不会触及它.</span></span><br><span class="line"><span class="comment"> * 因此解锁.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"><span class="comment">// 判断 PTE 是否为 0, 是则表示映射还未建立, 否表示映射已经建立</span></span><br><span class="line"><span class="keyword">if</span> (pte_none(entry))</span><br><span class="line"><span class="keyword">return</span> do_no_page(mm, vma, address, write_access, pte);</span><br><span class="line"><span class="comment">// 如果页表项不为空, 说明物理页面在磁盘上</span></span><br><span class="line"><span class="keyword">return</span> do_swap_page(mm, vma, address, pte, pte_to_swp_entry(entry), write_access);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write_access) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line"><span class="keyword">return</span> do_wp_page(mm, vma, address, pte, entry);</span><br><span class="line"></span><br><span class="line">entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line">entry = pte_mkyoung(entry);</span><br><span class="line">establish_pte(vma, address, pte, entry);</span><br><span class="line">spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>vm_area_struct</code> 中存在一个 <code>vm_operations_struct</code> 结构体(<code>数据结构</code> 中介绍), 这个结构实际上是一个函数跳转表, 结构中通常是一些与文件操作有关的函数指针, 这样, <strong>当通过 <code>mmap()</code> 将一块虚存区间与一个已打开的文件(包括设备)建立映射后, 就可以通对这些函数的操作转化成对文件操作, 或者进行一些必要的对文件的附加操作. 另一方面, 物理页面的盘区交换显然也和文件操作有关</strong>. 所以为特定的虚存空间预先指定一些操作是很有必要的.</p><p>&emsp;&emsp;其中 <code>nopage</code> 用于物理内存页面的分配. <strong>为什么物理内存页面的分配与文件操作有关</strong>? 因为这对文件共享很有意义. 当多个进程将同一个文件映射到各自的虚存空间中时, 内存中通常只会保存一份物理页面就可以. 只有当一个进程需要写入该文件时, 才有必要另外复制一份独立的副本, 称为 <code>copy on write</code> 或者 <code>COW</code>(后面进程中关于 <code>fork()</code> 的内容详细介绍).</p><p>&emsp;&emsp;由于这里是栈区扩展, 与文件系统或页面共享没有关系, 所以不会指定 <code>nopage</code> 操作, 会进入 <code>do_anonymous_page()</code> 函数处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_no_page() tries to create a new page mapping. It aggressively</span></span><br><span class="line"><span class="comment"> * tries to share with existing pages, but makes a separate copy if</span></span><br><span class="line"><span class="comment"> * the "write_access" parameter is true in order to avoid the next</span></span><br><span class="line"><span class="comment"> * page fault.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * do_no_page() 尝试创建一个新的页面映射. 它积极尝试与已存在的页面共享, 但是如果 write_access 参数为 true,</span></span><br><span class="line"><span class="comment"> * 为了避免再次出现页面错误, 它会创建单独的副本.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As this is called only for pages that do not currently exist, we</span></span><br><span class="line"><span class="comment"> * do not need to flush old virtual caches or the TLB.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 仅针对当前不存在的页面调用这个函数, 因此我们不需要刷新就得虚拟缓存或 TLB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called with the MM semaphore held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_no_page</span><span class="params">(struct mm_struct * mm, struct vm_area_struct * vma,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">int</span> write_access, <span class="keyword">pte_t</span> *page_table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> * <span class="title">new_page</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前区间没有定义 vm_operation_struct 的函数操作或者没有定义 vm_operation_struct 中缺页时的操作 nopage</span></span><br><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage)</span><br><span class="line"><span class="keyword">return</span> do_anonymous_page(mm, vma, page_table, write_access, address);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;进入 <code>do_anonymous_page()</code> 函数后, 如果引发异常的是读操作就会将页表项指向一个始终为 <code>0</code> 的<strong>只读</strong>的全局共享物理内存页面; 如果是写操作就会获取一个新的物理页面, 将页表项指向<strong>可写</strong>的物理内存页面.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only needs the MM semaphore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_anonymous_page</span><span class="params">(struct mm_struct * mm, struct vm_area_struct * vma, <span class="keyword">pte_t</span> *page_table, <span class="keyword">int</span> write_access, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">// 将页表项指向一个始终为 0 的只读的全局共享物理内存页面 mk_pte: 设置页表项中的权限位</span></span><br><span class="line"><span class="keyword">pte_t</span> entry = pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot));</span><br><span class="line"><span class="comment">// 如果出现异常的指令是写操作</span></span><br><span class="line"><span class="keyword">if</span> (write_access) &#123;</span><br><span class="line"><span class="comment">// 获取一个物理页面</span></span><br><span class="line">page = alloc_page(GFP_HIGHUSER);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">clear_user_highpage(page, addr);</span><br><span class="line"><span class="comment">// 将页表项指向可写的物理内存页面 page</span></span><br><span class="line">entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)));</span><br><span class="line">mm-&gt;rss++;</span><br><span class="line">flush_page_to_ram(page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将页表项的值填入一个页表项中.</span></span><br><span class="line">set_pte(page_table, entry);</span><br><span class="line"><span class="comment">/* No need to invalidate - it was non-present before */</span></span><br><span class="line">    <span class="comment">// i386 的 MMU 在 CPU 中, 不需要这个功能, 这里为空函数</span></span><br><span class="line">update_mmu_cache(vma, addr, entry);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">/* Minor fault */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;只要是只读页面, 开始时都会不管其虚拟地址是什么, 直接映射向同一个始终为 <code>0</code> 物理页面 <code>empty_zero_page</code>. 只有是可写页面时才会分配新的独立物理内存.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page() &gt; ZERO_PAGE()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZERO_PAGE is a global shared page that is always zero: used</span></span><br><span class="line"><span class="comment"> * for zero-mapped memory areas etc..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ZERO_PAGE 是一个始终为 0 的全局共享页面: 用于零映射内存区域等..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> empty_zero_page[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 获取一个全局共享的初始化为 0 的物理页面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;栈区扩展是由于写操作异常引起的, 所以会调用 <code>alloc_page()</code> 为其分配新的物理内存页面, 并将分配的物理页面及权限写入页表项中. 至此映射建立完成, 逐层退出函数.</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>&emsp;&emsp;<strong>当 CPU 从一次页面出错异常处理返回到用户空间时, 将会先重新执行因映射失败而中断的那条指令, 然后才会继续向下执行, 这是异常处理的特殊性. 中断以及自陷(<code>trap</code> 指令) 发生时, CPU 都会将下一条指令, 也就是接下去本来要执行的指令的地址入栈作为恢复中断服务的返回地址. 而当异常发生时, CPU 将因无法完成(例如除以 0, 映射失败等) 而夭折的指令本身的地址(而不是下一条指令的地址)压入栈, 当从异常处理返回时继续刚刚没有完成的指令. 这个过程是在 <code>CPU</code> 内部电路中实现的, 不需要软件干预</strong>. 从这个意义上来讲, <code>缺页中断</code> 正确的说法应该是 <code>缺页异常</code>.</p><p><em>本文整理自《Linux内核源代码情景分析》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在 &lt;code&gt;越界访问&lt;/code&gt; 中, 对于 &lt;code&gt;do_page_fault()&lt;/code&gt; 的分析只进行了部分, 只分析了 &lt;code&gt;find_vma&lt;/code&gt; 返回 &lt;code&gt;vma&lt;/code&gt; 紧邻其上的区间不是栈区的处理情况. 这里分析一下如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况.&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="内存管理" scheme="http://chunqiublog.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>越界访问</title>
    <link href="http://chunqiublog.github.io/%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE.html"/>
    <id>http://chunqiublog.github.io/越界访问.html</id>
    <published>2018-02-07T14:49:53.000Z</published>
    <updated>2018-10-07T04:13:12.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;页式存储管理机制通过页目录和页表将每个线性地址映射到物理地址. 但是在这个过程中可能存在一些问题导致映射失败, 这时 CPU 就会产生 <code>页面出错异常(Page Fault Exception)</code>, 也成 <code>缺页中断</code>, 进而执行预定的页面异常处理程序, 使应用程序从产生异常的指令处恢复执行或进行善后处理. 产生 <code>页面出错异常(Page Fault Exception)</code> 的原因有:</p><a id="more"></a><blockquote><ul><li>访问的 <code>pgd_t</code> 或 <code>pte_t</code> 为空. 这可能是还未映射或映射已经撤销导致的.</li><li>物理页面被交换出内存.</li><li>指令的访问方式与页面要求的权限不符. 如修改只读页面.</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/i386/mm/fault.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles page faults.  It determines the address,</span></span><br><span class="line"><span class="comment"> * and the problem, and then passes it off to one of the appropriate</span></span><br><span class="line"><span class="comment"> * routines.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * error_code:</span></span><br><span class="line"><span class="comment"> *bit 0 == 0 means no page found, 1 means protection fault</span></span><br><span class="line"><span class="comment"> *bit 1 == 0 means read, 1 means write</span></span><br><span class="line"><span class="comment"> *bit 2 == 0 means kernel, 1 means user-mode</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 错误代码:</span></span><br><span class="line"><span class="comment"> *  bit 0 == 0 表示未找到页面, 1 表示保护错误</span></span><br><span class="line"><span class="comment"> *  bit 1 == 0 表示读取, 1 表示写入</span></span><br><span class="line"><span class="comment"> *  bit 2 == 0 表示内核, 1 表示用户模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 处理页面错误异常(缺页中断)</span></span><br><span class="line"><span class="comment">// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本</span></span><br><span class="line"><span class="comment">// error_code           指明映射失败原因</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_page_fault</span><span class="params">(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 当前出现异常进程的 task_struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="comment">// 当前出现异常进程用户空间 mm_struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="comment">// 当前出现异常进程的出错区间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span>;</span></span><br><span class="line"><span class="comment">// 当前出现异常进程访问的出错地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> fixup;</span><br><span class="line"><span class="keyword">int</span> write;</span><br><span class="line"><span class="keyword">siginfo_t</span> info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the address */</span> <span class="comment">/* 获取出错地址 */</span></span><br><span class="line">__asm__(<span class="string">"movl %%cr2,%0"</span>:<span class="string">"=r"</span> (address));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 task_struct</span></span><br><span class="line">tsk = current;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment"> * 'reference' page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment"> * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment"> * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment"> * nothing more.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (address &gt;= TASK_SIZE)</span><br><span class="line"><span class="keyword">goto</span> vmalloc_fault;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 mm_struct </span></span><br><span class="line">mm = tsk-&gt;mm;</span><br><span class="line">info.si_code = SEGV_MAPERR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we're in an interrupt or have no user</span></span><br><span class="line"><span class="comment"> * context, we must not take the fault..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果我们处于中断或没有用户上下文环境的情况下, 我们绝不能处理这种错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// in_interrupt() 返回非零, 说明映射失败发生在某个中断/异常处理程序中, 与当前出现异常进程无关.</span></span><br><span class="line"><span class="comment">// mm 为空, 说明当前出现异常进程的映射还没有建立, 与该进程无关. 说明映射发生在某个 in_interrupt() 程序无法检测的某个中断/异常处理程序中.</span></span><br><span class="line"><span class="keyword">if</span> (in_interrupt() || !mm)</span><br><span class="line"><span class="keyword">goto</span> no_context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量, 锁住 mm_struct 及其下属的 vm_area_struct, 防止其他进程打扰.</span></span><br><span class="line">down(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间</span></span><br><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="comment">// 用户程序越界访问系统空间</span></span><br><span class="line"><span class="keyword">if</span> (!vma)</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="comment">// vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中</span></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_start &lt;= address)</span><br><span class="line"><span class="keyword">goto</span> good_area;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// VM_GROWSDOWN 表示当前 vma 处于栈区</span></span><br><span class="line">    <span class="comment">// 紧邻其上的不是是一个栈区区间, 当前异常虚拟地址所在的空间没有建立映射或映射已经被销毁</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * accessing the stack below %esp is always a bug.</span></span><br><span class="line"><span class="comment"> * The "+ 32" is there due to some instructions (like</span></span><br><span class="line"><span class="comment"> * pusha) doing post-decrement on the stack and that</span></span><br><span class="line"><span class="comment"> * doesn't show up until later..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (address + <span class="number">32</span> &lt; regs-&gt;esp)</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (expand_stack(vma, address))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment"> * we can handle it..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">good_area:</span><br><span class="line">info.si_code = SEGV_ACCERR;</span><br><span class="line">write = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">/* 3: write, present */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_VERIFY_AREA</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;cs == KERNEL_CS)</span><br><span class="line">printk(<span class="string">"WP fault at %08lx\n"</span>, regs-&gt;eip);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">/* write, not present */</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">write++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">/* read, present */</span></span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">/* read, not present */</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))</span><br><span class="line"><span class="keyword">goto</span> bad_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If for any reason at all we couldn't handle the fault,</span></span><br><span class="line"><span class="comment"> * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment"> * the fault.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (handle_mm_fault(mm, vma, address, write)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> do_sigbus;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> out_of_memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Did it hit the DOS screen memory VA from vm86 mode?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;eflags &amp; VM_MASK) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> bit = (address - <span class="number">0xA0000</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">32</span>)</span><br><span class="line">tsk-&gt;thread.screen_bitmap |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">&#125;</span><br><span class="line">up(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Something tried to access memory that isn't in our memory map..</span></span><br><span class="line"><span class="comment"> * Fix it, but check if it's kernel or user first..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 尝试访问的内存不在内存映射(vm_area_struct)之中..</span></span><br><span class="line"><span class="comment"> * 首先检查当前出现异常进程属于用户还是内核, 然后修复..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bad_area:</span><br><span class="line"><span class="comment">// 对于 mm_struct 及其下属 vm_area_struct 的使用完成, 信号量解锁</span></span><br><span class="line">up(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">bad_area_nosemaphore:</span><br><span class="line"><span class="comment">/* User mode accesses just cause a SIGSEGV */</span> <span class="comment">/* 用户模块访问只会导致 SIGSEGV */</span></span><br><span class="line"><span class="comment">// 用户模式</span></span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 设置当前出现异常进程的 task_struct</span></span><br><span class="line">tsk-&gt;thread.cr2 = address;</span><br><span class="line">tsk-&gt;thread.error_code = error_code;</span><br><span class="line">tsk-&gt;thread.trap_no = <span class="number">14</span>;</span><br><span class="line"><span class="comment">// 向当前出现异常进程发送一个强制 SIGSEGV 信号, 产生 Segment Fault</span></span><br><span class="line">info.si_signo = SIGSEGV;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* info.si_code has been set above */</span></span><br><span class="line">info.si_addr = (<span class="keyword">void</span> *)address;</span><br><span class="line">force_sig_info(SIGSEGV, &amp;info, tsk);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pentium F0 0F C7 C8 bug workaround.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_data.f00f_bug) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">nr = (address - idt) &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr == <span class="number">6</span>) &#123;</span><br><span class="line">do_invalid_op(regs, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">no_context:</span><br><span class="line"><span class="comment">/* Are we prepared to handle this kernel fault?  */</span></span><br><span class="line"><span class="keyword">if</span> ((fixup = search_exception_table(regs-&gt;eip)) != <span class="number">0</span>) &#123;</span><br><span class="line">regs-&gt;eip = fixup;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Oops. The kernel tried to access some bad page. We'll have to</span></span><br><span class="line"><span class="comment"> * terminate things with extreme prejudice.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">bust_spinlocks();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (address &lt; PAGE_SIZE)</span><br><span class="line">printk(KERN_ALERT <span class="string">"Unable to handle kernel NULL pointer dereference"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">printk(KERN_ALERT <span class="string">"Unable to handle kernel paging request"</span>);</span><br><span class="line">printk(<span class="string">" at virtual address %08lx\n"</span>,address);</span><br><span class="line">printk(<span class="string">" printing eip:\n"</span>);</span><br><span class="line">printk(<span class="string">"%08lx\n"</span>, regs-&gt;eip);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"movl %%cr3,%0"</span>:<span class="string">"=r"</span> (page));</span><br><span class="line">page = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) __va(page))[address &gt;&gt; <span class="number">22</span>];</span><br><span class="line">printk(KERN_ALERT <span class="string">"*pde = %08lx\n"</span>, page);</span><br><span class="line"><span class="keyword">if</span> (page &amp; <span class="number">1</span>) &#123;</span><br><span class="line">page &amp;= PAGE_MASK;</span><br><span class="line">address &amp;= <span class="number">0x003ff000</span>;</span><br><span class="line">page = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) __va(page))[address &gt;&gt; PAGE_SHIFT];</span><br><span class="line">printk(KERN_ALERT <span class="string">"*pte = %08lx\n"</span>, page);</span><br><span class="line">&#125;</span><br><span class="line">die(<span class="string">"Oops"</span>, regs, error_code);</span><br><span class="line">do_exit(SIGKILL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We ran out of memory, or some other thing happened to us that made</span></span><br><span class="line"><span class="comment"> * us unable to handle the page fault gracefully.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">out_of_memory:</span><br><span class="line">up(&amp;mm-&gt;mmap_sem);</span><br><span class="line">printk(<span class="string">"VM: killing process %s\n"</span>, tsk-&gt;comm);</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span>)</span><br><span class="line">do_exit(SIGKILL);</span><br><span class="line"><span class="keyword">goto</span> no_context;</span><br><span class="line"></span><br><span class="line">do_sigbus:</span><br><span class="line">up(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send a sigbus, regardless of whether we were in kernel</span></span><br><span class="line"><span class="comment"> * or user mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tsk-&gt;thread.cr2 = address;</span><br><span class="line">tsk-&gt;thread.error_code = error_code;</span><br><span class="line">tsk-&gt;thread.trap_no = <span class="number">14</span>;</span><br><span class="line">info.si_code = SIGBUS;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = BUS_ADRERR;</span><br><span class="line">info.si_addr = (<span class="keyword">void</span> *)address;</span><br><span class="line">force_sig_info(SIGBUS, &amp;info, tsk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Kernel mode? Handle exceptions or die */</span></span><br><span class="line"><span class="keyword">if</span> (!(error_code &amp; <span class="number">4</span>))</span><br><span class="line"><span class="keyword">goto</span> no_context;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">vmalloc_fault:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Synchronize this task's top level page-table</span></span><br><span class="line"><span class="comment"> * with the 'reference' page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> offset = __pgd_offset(address);</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd, *pgd_k;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd, *pmd_k;</span><br><span class="line"></span><br><span class="line">pgd = tsk-&gt;active_mm-&gt;pgd + offset;</span><br><span class="line">pgd_k = init_mm.pgd + offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pgd_present(*pgd)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pgd_present(*pgd_k))</span><br><span class="line"><span class="keyword">goto</span> bad_area_nosemaphore;</span><br><span class="line">set_pgd(pgd, *pgd_k);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pmd = pmd_offset(pgd, address);</span><br><span class="line">pmd_k = pmd_offset(pgd_k, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pmd_present(*pmd) || !pmd_present(*pmd_k))</span><br><span class="line"><span class="keyword">goto</span> bad_area_nosemaphore;</span><br><span class="line">set_pmd(pmd, *pmd_k);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码开始时使用汇编获取 <code>address</code> 是因为 <code>i386</code> CPU 产生 <code>页面出错异常(Page Fault Exception)</code> 时, 会将访问产生这个错误的虚拟地址放入控制寄存器 <code>CR2</code> 中. 由于 <code>C</code> 语言没有直接读取 <code>CR2</code> 的语句, 所以需要使用汇编进行获取.</p><p>&emsp;&emsp;对于获取到的 <code>vma</code> 的分析:</p><blockquote><ul><li>进程的内存布局代码段, 数据段, bss段, 堆等自底向上分布, 栈区自顶向下发展, 所以结束地址最高的区间为栈区, 如果访问异常的虚拟地址比最高区间的结束地址还高(<code>find_vma</code> 返回 <code>NULL</code>, <code>if (!vma)</code>), 说明其处于高 1G 的系统空间中.</li><li>如果访问异常的虚拟地址大于等于当前区间的其实地址(<code>if (vma-&gt;vm_start &lt;= address)</code>), 说明异常发生在当前区间.</li><li>如果访问异常的虚拟地址不在系统空间, 也不再任何一个区间, 说明其处于一个内存映射的空洞中:<ul><li><code>VM_GROWSDOWN</code> 表示一个区间处于栈区, 如果内存映射的空洞紧邻其上的是一个栈区区间说明空洞是栈区一下的空洞, 这个空洞是供动态分配使用(通过系统调用 <code>brk()</code>)但是还没有分配出去的空间.</li><li>如果紧邻其上的区间没有设置 <code>VM_GROWSDOWN</code>, 说明空洞是因为一个没有建立映射区间或映射区间已经被销毁的空间.</li></ul></li></ul></blockquote><p>&emsp;&emsp;每次从中断/异常处理程序中返回之前, 都要检查当前进程是否有信号(或称软中断)需要处理, 在 <code>vma</code> 处于最后一种情况时需要处理 <code>SIGSEGV</code> 信号. 内核会根据这些待处理信号的性质以及进程本身的选择进行处理. 有些信号是强制执行, 有些是按照进程设置处理. <code>SIGSEGV</code> 信号需要强制执行, 会是该进程产生 <code>Segment Fault</code>, 然后使进程退出.</p><p><em>本文整理自《Linux内核源代码情景分析》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;页式存储管理机制通过页目录和页表将每个线性地址映射到物理地址. 但是在这个过程中可能存在一些问题导致映射失败, 这时 CPU 就会产生 &lt;code&gt;页面出错异常(Page Fault Exception)&lt;/code&gt;, 也成 &lt;code&gt;缺页中断&lt;/code&gt;, 进而执行预定的页面异常处理程序, 使应用程序从产生异常的指令处恢复执行或进行善后处理. 产生 &lt;code&gt;页面出错异常(Page Fault Exception)&lt;/code&gt; 的原因有:&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="内存管理" scheme="http://chunqiublog.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://chunqiublog.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
    <id>http://chunqiublog.github.io/数据结构.html</id>
    <published>2018-01-27T18:30:46.000Z</published>
    <updated>2018-10-07T04:12:59.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="页面映射结构"><a href="#页面映射结构" class="headerlink" title="页面映射结构"></a>页面映射结构</h2><p>&emsp;&emsp;页目录 <code>PGD</code>, 中间目录 <code>PMD</code>, 页表 <code>PT</code> 分别是由表项 <code>pgd_t</code>, <code>pmd_t</code> 以及 <code>pte_t</code> 构成的数组.</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/page.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这些用于 C 类型检查..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_X86_PAE <span class="comment">// 三层映射 PAE 模式</span></span></span><br><span class="line"><span class="comment">// PT 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte_low, pte_high; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line"><span class="comment">// PMD 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="comment">// PGD 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br><span class="line"><span class="comment">// 计算 pte 的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pte_val(x)((x).pte_low | ((unsigned long long)(x).pte_high &lt;&lt; 32))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// 两层映射</span></span></span><br><span class="line"><span class="comment">// PT 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte_low; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line"><span class="comment">// PMD 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="comment">// PGD 表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br><span class="line"><span class="comment">// 计算 pte 的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pte_val(x)((x).pte_low)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_MASKPAGE_MASK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面状态信息和访问权限结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgprot; &#125; <span class="keyword">pgprot_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;32 位地址时, <code>pgd_t</code>, <code>pmd_t</code> 和 <code>pte_t</code> 实际上就是长整型. 36 位地址时, 则是 <code>long long</code> 整型. <strong>不直接定义成整型是因为这样可以让 <code>gcc</code> 在编译时加以更严格的类型检查</strong>.</p><p>&emsp;&emsp;所有的物理页面都是 4K 边界对齐, 因此这些表项作为页面的指针一定是 4K 的倍数, 所以指针实际只需要高 20 位, 这高 20 位也可以看做物理页面的下标序号. 所以这些表项的低 12 位就被用于记录页面的状态信息和访问权限. 内核中并没有在表项中定义相关的位段, 而是单独定义用来说明页面保护的结构 <code>pgprot_t</code>. 对 <code>pgprot_t</code> 中位段说明如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PRESENT0x001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_RW0x002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_USER0x004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PWT0x008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PCD0x010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_ACCESSED0x020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_DIRTY0x040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PSE0x080<span class="comment">/* 4 MB (or 2MB) page, Pentium+, if present.. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_GLOBAL0x100<span class="comment">/* Global TLB entry PPro+ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 pte_t 中第 8 位, Intel 手册指定这一位保留不用, 所以对 MMU 不起作用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PROTNONE0x080<span class="comment">/* If not present */</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>pgprot_t</code> 设置 <code>pte</code> 低 12 位, 所以总是小于 <code>0x1000</code>, <code>pte</code> 中的指针部分总是大于等于 <code>0x1000</code>, 将二者合在一起就得到实际用于 <code>PT</code> 中的表项.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable-2level.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 pte_t 设置 pgprot_t 权限</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __mk_pte(page_nr,pgprot) __pte(((page_nr) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>当 <code>PTE</code> 为 <code>0</code> 时, 表示这个表项所代表的虚拟内存页面没有建立映射. 在映射过程中 <code>MMU</code> 会首先检查 P 标志位, 即 <code>_PAGE_PRESENT</code>, 表示映射的页面是否在内存中. 只有当 P 标志位为 <code>1</code> 时, <code>MMU</code> 才会完成映射的全过程; 如果 <code>PTE</code> 不为 <code>0</code>, P 标志位为 <code>0</code> 时, 表示映射已经建立, 但是所映射的物理页面不在内存中, 会产生一次缺页异常</strong>.</p><h2 id="物理内存管理结构"><a href="#物理内存管理结构" class="headerlink" title="物理内存管理结构"></a>物理内存管理结构</h2><h3 id="page-结构"><a href="#page-结构" class="headerlink" title="page 结构"></a><code>page</code> 结构</h3><p>&emsp;&emsp;在内核中有个全局的 <code>mem_map</code> 指针, 指向一个 <code>page</code> 结构体的数组, 每个 <code>page</code> 代表一个物理页面, 整个数组代表系统中的所有物理页面. <code>PTE</code> 不仅仅低 12 位为 0 时对于硬件是物理页面的地址, 同时它的高 20 位对于软件也代表这个数组的下标.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable-2level.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 PTE 获取 PTE 指向的物理页面的 page 指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pte_page(x)(mem_map+((unsigned long)(((x).pte_low &gt;&gt; PAGE_SHIFT))))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to keep the most commonly accessed fields in single cache lines</span></span><br><span class="line"><span class="comment"> * here (16 bytes or greater).  This ordering should be particularly</span></span><br><span class="line"><span class="comment"> * beneficial on 32-bit processors.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 尝试在单个缓存线中保留最常访问的字段(16 字节或更大). 这一点对 32 位处理器应该特别有利.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first line is data used in page cache lookup, the second line</span></span><br><span class="line"><span class="comment"> * is used for linear searches (eg. clock algorithm scans). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 第一行是用于页面缓存的查找的数据, 第二行是用于线性搜索(如时钟算法扫描).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 物理页面结构体, 代表一个物理页面</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line"><span class="comment">// 当页面内容来自一个文件时, index 表示该页面在文件中的序号</span></span><br><span class="line"><span class="comment">// 当页面的内容被交换到磁盘上, index 表示页面的去向</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next_hash</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">/* atomic flags, some possibly updated asynchronously */</span> <span class="comment">/* 原子标志, 有可能异步更新 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> age;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pprev_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">buffers</span>;</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">virtual</span>; <span class="comment">/* non-NULL if kmapped */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> *<span class="title">zone</span>;</span></span><br><span class="line">&#125; <span class="keyword">mem_map_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>page</code> 结构中各个成分的次序是有讲究的, 目的是尽量使得联系紧密的若干成分在执行是被装填入高速缓存的同一缓冲线(16个字节)中. 系统在初始化时会创建一个由 <code>page</code>(或 <code>mem_map_t</code>) 组成的 <code>mem_map</code> 数组, 每个 <code>page</code> 代表系统中的一个物理页面, 物理页面初始地址的高 20 位就是对应 <code>page</code> 的下标.</p><h3 id="zone-struct-结构"><a href="#zone-struct-结构" class="headerlink" title="zone_struct 结构"></a><code>zone_struct</code> 结构</h3><p>&emsp;&emsp;<code>mem_map</code> 中的所有物理页面被划分成 <code>ZONE_DMA</code> 和 <code>ZONE_NORMAL</code> 两个管理区(也有可能存在第三个 <code>ZONE_HIGHMEM</code>). <strong><code>ZONE_DMA</code> 中管理的是专供 <code>DMA</code> 使用的内存页</strong>.</p><blockquote><p>为什么供 <code>DMA</code> 使用的页面要单独加以管理?</p><ul><li><code>DMA</code> 使用的页面需要进行磁盘 I/O, 单独管理防止内存页面全部被分配出去无法进行页面与盘区的交换.</li><li>在 <code>i386</code> 中 <code>MMU</code> 存在于 CPU 中, <code>DMA</code> 不经过 <code>MMU</code> 的地址映射, 外设直接访问物理内存, 但是部分外设访问物理内存地址较小.</li><li><code>DMA</code> 所需的内存当超过 4K 时, 需要连续的物理内存页面, 无法使用 <code>MMU</code> 提供的连续的虚拟内存页面.</li></ul></blockquote><p>&emsp;&emsp;每个管理区由 <code>none_struct</code> 结构创建, 一旦创建成功, 每个物理页面就永久属于一个管理区. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mmzone.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free memory management - zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 空闲内存管理 - zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free_area_struct 链接的最大内存块为 2 ^ MAX_ORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ORDER 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">free_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>*<span class="built_in">map</span>;</span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Commonly accessed fields:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 常用字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">spinlock_t</span>lock;</span><br><span class="line">    <span class="comment">// 当前管理区在 mem_map 中的起始位置(页面序号)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>offset;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>free_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>inactive_clean_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>inactive_dirty_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>pages_min, pages_low, pages_high;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * free areas of different sizes</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 不同大小的空闲空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">inactive_clean_list</span>;</span></span><br><span class="line">    <span class="comment">// 数组中每个成员都是由双向链表连接起来的内存块的链表指针, 每个成员中内存块都是由 2 ^ n 个物理页面组成(1 &lt;= n &lt;= MAX_ORDER, MAX_ORDER = 10).</span></span><br><span class="line"><span class="keyword">free_area_t</span>free_area[MAX_ORDER];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rarely used fields:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 很少使用的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>*name;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>size;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Discontig memory support fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 指向当前 node 节点的管理结构 pglist_data(下一小节介绍)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>*<span class="title">zone_pgdat</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>zone_start_paddr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>zone_start_mapnr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>*<span class="title">zone_mem_map</span>;</span></span><br><span class="line">&#125; <span class="keyword">zone_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理区类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZONE_DMA0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZONE_NORMAL1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZONE_HIGHMEM2</span></span><br><span class="line"><span class="comment">// 管理区最大数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NR_ZONES3</span></span><br></pre></td></tr></table></figure><h3 id="pglist-data-结构"><a href="#pglist-data-结构" class="headerlink" title="pglist_data 结构"></a><code>pglist_data</code> 结构</h3><p>&emsp;&emsp;计算机内存系统存在两种结构.</p><blockquote><ul><li><strong><code>均质存储结构(Uniform Memory Architecture)</code> 指计算机中所有物理内存地位均等, 访问任意物理内存消耗时间相同, 简称 <code>UMA</code>.</strong> </li><li><strong><code>非均质存储结构(Non-Uniform Memory Architecture)</code> 指计算机中物理内存地址虽然是连续的, 但是却分为不同的模块, 访问速度不同, 消耗的时间也不同, 简称 <code>NUMA</code>.</strong></li></ul></blockquote><p>&emsp;&emsp;在真实的计算机系统中, 绝对的 <code>UMA</code> 是不存在的. 真正的系统会存在不同的内存模块, 如多级高速缓存, <code>RAM</code>, <code>ROM</code>, 显存等. Linux 内核从 <code>2.4.0</code> 版本开始支持 <code>NUMA</code>. <strong>在 <code>NUMA</code> 结构的系统中, 分配连续多个物理内存页面要求分配在质地相同的区间(称为 <code>node</code>, 即 <code>节点</code>)</strong>. 这里的 <code>node</code> 对应到 Linux 系统中就是 <code>pglist_data</code> 结构. 这时 <code>mem_map</code> 数组将不再管理整个物理内存, 而是管理当前 <code>node</code> 中的物理页面. 而 <code>zone_struct</code> 则表示当前 <code>node</code> 中的管理区. 在 <code>zone_struct</code> 和 <code>mem_map</code> 之上则是 <code>pglist_data</code> 结构, 管理整个存储节点.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mmzone.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * One allocation request operates on a zonelist. A zonelist</span></span><br><span class="line"><span class="comment"> * is a list of zones, the first one is the 'goal' of the</span></span><br><span class="line"><span class="comment"> * allocation, the other zones are fallback zones, in decreasing</span></span><br><span class="line"><span class="comment"> * priority.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一个分配请求在一个 zonelist(管理区列表) 上运行. 一个 zonelist 是 zone 的列表,</span></span><br><span class="line"><span class="comment"> * 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Right now a zonelist takes up less than a cacheline. We never</span></span><br><span class="line"><span class="comment"> * modify it apart from boot-up, and only a few indices are used,</span></span><br><span class="line"><span class="comment"> * so despite the zonelist table being relatively big, the cache</span></span><br><span class="line"><span class="comment"> * footprint of this construct is very small.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 现在一个 zonelist 占用的空间比一个缓存线小.</span></span><br><span class="line"><span class="comment"> * 除非在启动时, 否则我们从不修改它, 并且只有少数索引被使用, 因此尽管 zonelist 表相对较大(0x100(256) 项),</span></span><br><span class="line"><span class="comment"> * 但是构造它的缓存空间是非常小的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zonelist_struct</span> &#123;</span></span><br><span class="line"><span class="comment">// zone_struct 管理区, 类型相同(猜测), 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低.</span></span><br><span class="line"><span class="keyword">zone_t</span> * zones [MAX_NR_ZONES+<span class="number">1</span>]; <span class="comment">// NULL delimited</span></span><br><span class="line"><span class="keyword">int</span> gfp_mask;</span><br><span class="line">&#125; <span class="keyword">zonelist_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zonelist 数组最大长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_GFPINDEX0x100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="comment">// 当前 node 的 zone_struct 管理区, 最大为 3 个</span></span><br><span class="line"><span class="keyword">zone_t</span> node_zones[MAX_NR_ZONES];</span><br><span class="line"><span class="comment">// zonelist 表, 规定最多 0x100(256) 中内存分配策略</span></span><br><span class="line"><span class="keyword">zonelist_t</span> node_zonelists[NR_GFPINDEX];</span><br><span class="line"><span class="comment">// 指向当前 node 的 mem_map 数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *valid_addr_bitmap;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_paddr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_mapnr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_size;</span><br><span class="line"><span class="keyword">int</span> node_id;</span><br><span class="line"><span class="comment">// 单向链表, 指向下一个 pglist_data 节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_next</span>;</span></span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h2 id="虚拟内存管理结构"><a href="#虚拟内存管理结构" class="headerlink" title="虚拟内存管理结构"></a>虚拟内存管理结构</h2><h3 id="vm-area-struct-结构"><a href="#vm-area-struct-结构" class="headerlink" title="vm_area_struct 结构"></a><code>vm_area_struct</code> 结构</h3><p>&emsp;&emsp;在虚拟内存中, 以进程为基础分为两个部分: <code>系统空间</code> 和 <code>用户空间</code>. <code>系统空间</code> 为所有进程共享; <code>用户空间</code> 为每个进程私有. 其中 <code>用户空间</code> 中的各个部分未必是连续的, 通常形成许多分散的虚拟内存区间. Linux 内核中 <code>vm_area_struct</code> 就表示这些虚拟内存区间, 使用单链表将所有区间连接, 同时为了提高搜索效率, 在区间数量增大到 <strong>32</strong> 时(&gt;=), 会创建 AVL 树. 在Linux内核中 <code>vm_area_struct</code> 的变量名常常是 <code>vma</code>. <code>vm_area_struct</code> 的划分不仅仅取决于地址的连续性, 还要求同一 <code>vm_area_struct</code> 中的虚拟内存具有相同访问权限(<code>vm_page_prot</code>)和其他一些属性(<code>vm_flags</code>).</p><p>&emsp;&emsp;同时 <code>vm_area_struct</code> 还会与磁盘文件发生交互:</p><blockquote><ul><li><code>盘去交换(swap)</code>: 指在物理内存页面不够分配时, 一些长时间不用的内存交换到磁盘上, 腾出物理页面以供应急. 这就是一般意义上的 <code>&quot;按需调度&quot;页式虚存管理(demand paging)</code>.</li><li>系统调用 <code>mmap()</code>: 可以将一个打开的文件映射到用户空间中, 使进程像访问内存中的字符数组一样访问文件中的数据.</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前 vm_area_struct 所在进程用户空间的管理结构 mm_struct(下一小节介绍)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span><span class="comment">/* VM area parameters */</span></span><br><span class="line"><span class="comment">// vm_area_struct 起始地址, 包含在 vm_area_struct 中</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;</span><br><span class="line"><span class="comment">// vm_area_struct 结束地址, 不包含在 vm_area_struct 中</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line"><span class="comment">// 单链表, 每个进程的 vm_area_struct 按照地址高低依次链接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vm_area_struct 访问权限</span></span><br><span class="line"><span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line"><span class="comment">// vm_area_struct 属性</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* AVL tree of VM areas per task, sorted by address */</span></span><br><span class="line"><span class="comment">// AVL 树, 每个进程的 vm_area_struct 按照地址高低组成 AVL 树, 便于查找</span></span><br><span class="line"><span class="keyword">short</span> vm_avl_height;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vm_avl_left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vm_avl_right</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment"> * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists,</span></span><br><span class="line"><span class="comment"> * for shm areas, the list of attaches, otherwise unused.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 记录, 管理 vm_area_struct 与磁盘文件交互</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next_share</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> **<span class="title">vm_pprev_share</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 vm_area_struct 操作执行函数指针, 包括打开, 关闭, 缺页时建立映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;<span class="comment">/* offset in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_raend;</span><br><span class="line"><span class="keyword">void</span> * vm_private_data;<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// vma 打开操作</span></span><br><span class="line"><span class="keyword">void</span> (*open)(struct vm_area_struct * area);</span><br><span class="line">    <span class="comment">// vma 关闭操作</span></span><br><span class="line"><span class="keyword">void</span> (*close)(struct vm_area_struct * area);</span><br><span class="line">    <span class="comment">// vma 中产生缺页异常时建立映射操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> * (*<span class="title">nopage</span>)(<span class="title">struct</span> <span class="title">vm_area_struct</span> * <span class="title">area</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">address</span>, <span class="title">int</span> <span class="title">write_access</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mm-struct-结构"><a href="#mm-struct-结构" class="headerlink" title="mm_struct 结构"></a><code>mm_struct</code> 结构</h3><p>&emsp;&emsp;在 <code>vm_area_struct</code> 结构中存在指向 <code>mm_struct</code> 结构的指针, <code>mm_struct</code> 是整个进程用户空间的管理结构, 在内核中的变量名常常为<code>mm</code>, 比 <code>vm_area_struct</code> 更高一个层次, 对 <code>vm_area_struct</code> 进行管理. 每一个进程控制块即 <code>task_struct</code> 结构中都有一个指向当前进程 <code>mm_struct</code> 结构的指针. 虽然每个进程都只有一个 <code>mm_struct</code> 结构, 但是一个 <code>mm_struct</code> 结构可以被多个进程共用, 如 <code>vfork()</code> 的父子进程共享一个 <code>mm_struct</code> 结构.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span><span class="comment">/* list of VMAs */</span> <span class="comment">/* vma 链表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_avl</span>;</span><span class="comment">/* tree of VMAs */</span> <span class="comment">/* vma AVL 树 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span><span class="comment">/* last find_vma result */</span> <span class="comment">/* find_vma 返回的结果 ,即上一次访问的 vma */</span></span><br><span class="line"><span class="comment">// pgd 指针</span></span><br><span class="line"><span class="keyword">pgd_t</span> * pgd;</span><br><span class="line"><span class="comment">// atomic_t 原子操作整数</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_users;<span class="comment">/* How many users with user space? */</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_count;<span class="comment">/* How many references to "struct mm_struct" (users count as 1) */</span></span><br><span class="line"><span class="keyword">int</span> map_count;<span class="comment">/* number of VMAs */</span> <span class="comment">/* 当前 mm_struct 中 vma 的数量 */</span></span><br><span class="line"><span class="comment">// P, V 操作信号量. 使对 mm_struct 及下属 vm_area_struct 的访问互斥</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line"><span class="comment">// 类似 mmap_sem</span></span><br><span class="line"><span class="keyword">spinlock_t</span> page_table_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span><span class="comment">/* List of all active mm's */</span> <span class="comment">/* 所有存活 mm_struct 组成的链表 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码段, 数据段起始地址和终止地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rss, total_vm, locked_vm;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_vm_mask;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swap_cnt;<span class="comment">/* number of pages to swap on next pass */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swap_address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line"><span class="keyword">mm_context_t</span> context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CPU 实际进行的映射并不涉及 <code>mm_struct</code> 结构, 而是像 <code>地址映射</code> 中讲的那样通过 <code>PGD</code> 和 <code>PT</code> 进行, 但是 <code>mm_struct</code> 结构描述了这种映射.</p><p>&emsp;&emsp;通过 <code>mm_struct</code> 结构查找给定虚拟地址所在的 <code>vma</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span></span><br><span class="line"><span class="comment">/* 查找满足 addr &lt; vm_end 的 vma, 没有则返回 NULL */</span></span><br><span class="line"><span class="comment">// 给出一个虚拟地址, 查找对应用户空间 mm 中第一个虚拟地址大于其结束地址的 vma</span></span><br><span class="line"><span class="comment">// 返回 NULL 表示该虚拟地址所在区间还未创建</span></span><br><span class="line"><span class="function">struct vm_area_struct * <span class="title">find_vma</span><span class="params">(struct mm_struct * mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mm) &#123;</span><br><span class="line"><span class="comment">/* Check the cache first. */</span> <span class="comment">/* 实现检查缓存 */</span></span><br><span class="line"><span class="comment">/* (Cache hit rate is typically around 35%.) */</span> <span class="comment">/* 缓存命中率大约为 35% */</span></span><br><span class="line">vma = mm-&gt;mmap_cache;</span><br><span class="line"><span class="comment">// 如果不在缓存中</span></span><br><span class="line"><span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;</span><br><span class="line"><span class="comment">// 如果没有建立 AVL 树</span></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;mmap_avl) &#123;</span><br><span class="line"><span class="comment">/* Go through the linear list. */</span> <span class="comment">/* 通过线性链表查找 */</span></span><br><span class="line">vma = mm-&gt;mmap;</span><br><span class="line"><span class="keyword">while</span> (vma &amp;&amp; vma-&gt;vm_end &lt;= addr)</span><br><span class="line">vma = vma-&gt;vm_next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Then go through the AVL tree quickly. */</span> <span class="comment">/* 建立了 AVL 树, 通过 AVL 树快速查找 */</span></span><br><span class="line">struct vm_area_struct * tree = mm-&gt;mmap_avl;</span><br><span class="line">vma = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (tree == vm_avl_empty)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (tree-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">vma = tree;</span><br><span class="line"><span class="keyword">if</span> (tree-&gt;vm_start &lt;= addr)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">tree = tree-&gt;vm_avl_left;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">tree = tree-&gt;vm_avl_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vma)</span><br><span class="line">mm-&gt;mmap_cache = vma; <span class="comment">// 将当前查到的 vma 保存到缓存中.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在创建一个新的 <code>vm_area_struct</code> 将其插入 <code>mm_struct</code> 时, 会调用 <code>insert_vm_struct()</code> 函数, 在这里加了两把锁, 第一把加在新区间 <code>vm_area_struct</code> 上, 第二把加在代表整个虚拟空间的 <code>mm_struct</code> 结构中, 使得操作过程中不让其他进程能够中途也能对这两个数据结构进行修改.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert vm structure into process list sorted by address</span></span><br><span class="line"><span class="comment"> * and into the inode's i_mmap ring.  If vm_file is non-NULL</span></span><br><span class="line"><span class="comment"> * then the i_shared_lock must be held here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> **<span class="title">pprev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有创建 AVL 树</span></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;mmap_avl) &#123;</span><br><span class="line"><span class="comment">// 在单链表中查找</span></span><br><span class="line">pprev = &amp;mm-&gt;mmap;</span><br><span class="line"><span class="keyword">while</span> (*pprev &amp;&amp; (*pprev)-&gt;vm_start &lt;= vmp-&gt;vm_start)</span><br><span class="line">pprev = &amp;(*pprev)-&gt;vm_next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 已经创建 AVL 树, 插入 AVL 树</span></span><br><span class="line">struct vm_area_struct *prev, *next;</span><br><span class="line">avl_insert_neighbours(vmp, &amp;mm-&gt;mmap_avl, &amp;prev, &amp;next);</span><br><span class="line">pprev = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap);</span><br><span class="line"><span class="keyword">if</span> (*pprev != next)</span><br><span class="line">printk(<span class="string">"insert_vm_struct: tree inconsistent with list\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将新的 vm_area_struct 加入单链表</span></span><br><span class="line">vmp-&gt;vm_next = *pprev;</span><br><span class="line">*pprev = vmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mm_struct 中 vm_area_struct 总数++</span></span><br><span class="line">mm-&gt;map_count++;</span><br><span class="line"><span class="comment">// 当 mm_struct 中 vm_area_struct 数量达到 AVL_MIN_MAP_COUNT(32) 且没有创建 AVL 树时, 创建 vm_area_struct 的 AVL 树</span></span><br><span class="line"><span class="keyword">if</span> (mm-&gt;map_count &gt;= AVL_MIN_MAP_COUNT &amp;&amp; !mm-&gt;mmap_avl)</span><br><span class="line">build_mmap_avl(mm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件映射相关操作</span></span><br><span class="line">file = vmp-&gt;vm_file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span> = <span class="title">file</span>-&gt;<span class="title">f_dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">inode</span>-&gt;<span class="title">i_mapping</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> **<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vmp-&gt;vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">atomic_dec(&amp;inode-&gt;i_writecount);</span><br><span class="line"></span><br><span class="line">head = &amp;mapping-&gt;i_mmap;</span><br><span class="line"><span class="keyword">if</span> (vmp-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">head = &amp;mapping-&gt;i_mmap_shared;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/* insert vmp into inode's share list */</span></span><br><span class="line"><span class="keyword">if</span>((vmp-&gt;vm_next_share = *head) != <span class="literal">NULL</span>)</span><br><span class="line">(*head)-&gt;vm_pprev_share = &amp;vmp-&gt;vm_next_share;</span><br><span class="line">*head = vmp;</span><br><span class="line">vmp-&gt;vm_pprev_share = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个新创建的 vm_area_struct 结构插入当前用户空间的 mm_struct 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_vm_struct</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加在 vm_area_struct 上的第一把锁, 防止插入过程中其他进程修改当前的 vm_area_struct</span></span><br><span class="line">lock_vma_mappings(vmp);</span><br><span class="line">    <span class="comment">// 加在 mm_struct 上的第二把锁, 防止插入过程中其他进程修改当前的 mm_struct</span></span><br><span class="line">spin_lock(&amp;current-&gt;mm-&gt;page_table_lock);</span><br><span class="line">__insert_vm_struct(mm, vmp);</span><br><span class="line">spin_unlock(&amp;current-&gt;mm-&gt;page_table_lock);</span><br><span class="line">unlock_vma_mappings(vmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="虚存管理数据结构" title="虚存管理数据结构"></p><p>&emsp;&emsp;<code>mm_struct</code> 及其下属 <code>vm_area_struct</code> 只是说明了对虚拟内存的需求, 一个虚拟内存有相应的区间存在并不保证其所在的页面已经映射到了一个物理(物理内存或磁盘)页面, 更不保证该页面就在内存中.</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<code>mm_struct</code> 和 <code>vm_area_struct</code> 说明了对页面的需求; <code>page</code>, <code>zone_struct</code> 和 <code>pglist_data</code> 说明了对页面的供应; <code>PGD</code>, <code>PMD</code> 和 <code>PT</code> 则是二者之间的桥梁.</p><p><em>本文整理自《Linux内核源代码情景分析》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;页面映射结构&quot;&gt;&lt;a href=&quot;#页面映射结构&quot; class=&quot;headerlink&quot; title=&quot;页面映射结构&quot;&gt;&lt;/a&gt;页面映射结构&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;页目录 &lt;code&gt;PGD&lt;/code&gt;, 中间目录 &lt;code&gt;PMD&lt;/code&gt;, 页表 &lt;code&gt;PT&lt;/code&gt; 分别是由表项 &lt;code&gt;pgd_t&lt;/code&gt;, &lt;code&gt;pmd_t&lt;/code&gt; 以及 &lt;code&gt;pte_t&lt;/code&gt; 构成的数组.&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="内存管理" scheme="http://chunqiublog.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>地址映射</title>
    <link href="http://chunqiublog.github.io/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.html"/>
    <id>http://chunqiublog.github.io/地址映射.html</id>
    <published>2018-01-23T15:28:26.000Z</published>
    <updated>2018-10-07T04:13:42.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;Linux 采用页式内存管理.</p><blockquote><p>优点:</p><ul><li>页面固定大小, 便于管理.</li><li>灵活度高, 在将内存交换到磁盘上时, 按内存页进行交换.</li><li>页式内存管理有内部碎片, 无外部碎片.</li></ul></blockquote><a id="more"></a><p>&emsp;&emsp;即使 <code>i386</code> CPU 在硬件上限制必须先段式再页式的映射方式, Linux 也是避开了段式映射, <strong>在 Linux 内存映射时(除用来模拟80286的 <code>VM86模式</code>), 段式映射的基址总是 <code>0</code>, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射</strong>. 当然 <code>i386</code> 存在段式映射是有历史原因的, 对于其他 CPU 来说就不存在这一层了.</p><h2 id="段式映射"><a href="#段式映射" class="headerlink" title="段式映射"></a>段式映射</h2><p>&emsp;&emsp;在获取到一个虚拟地址后, 首先确定其属于进程的哪一段内存, 然后获取相应内存段的段寄存器中的值. <strong>Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/processor.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建进程时设置对应进程的段寄存器和栈顶,栈底寄存器</span></span><br><span class="line"><span class="comment">// Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start_thread(regs, new_eip, new_esp) do &#123;\</span></span><br><span class="line">__asm__(<span class="string">"movl %0,%%fs ; movl %0,%%gs"</span>: :<span class="string">"r"</span> (<span class="number">0</span>));\</span><br><span class="line">set_fs(USER_DS);\</span><br><span class="line">regs-&gt;xds = __USER_DS;\</span><br><span class="line">regs-&gt;xes = __USER_DS;\</span><br><span class="line">regs-&gt;xss = __USER_DS;\</span><br><span class="line">regs-&gt;xcs = __USER_CS;\</span><br><span class="line">regs-&gt;eip = new_eip;\</span><br><span class="line">regs-&gt;esp = new_esp;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/segment.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_SEGMENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_SEGMENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核代码段寄存器初始值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS0x10</span></span><br><span class="line"><span class="comment">// 内核数据段寄存器初始值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS0x18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户进程代码段寄存器初始值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS0x23</span></span><br><span class="line"><span class="comment">// 用户进程数据段寄存器初始值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS0x2B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要介绍一下段寄存器, <code>RPL</code> 为所要求的特权级别, 共分为 4 级, <code>00</code> 为最高权限, <code>11</code> 为最低权限, Linux 在实现时只使用了这两个级别. <code>TI</code> 为 <code>0</code> 时表示使用 <code>GDT</code>, 为 <code>1</code> 时表示使用 <code>LDT</code>. <code>Index</code> 表示对应段描述符表的下标.</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%A0%BC%E5%BC%8F%E5%AE%9A%E4%B9%89.png" alt="段寄存器格式定义" title="段寄存器格式定义"></p><p>&emsp;&emsp;通过之前介绍, 解析 Linux 段寄存器初始值:</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/Linux%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90_1.png" alt="Linux段寄存器数据解析_1" title="Linux段寄存器数据解析_1"></p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/Linux%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90_2.png" alt="Linux段寄存器数据解析_2" title="Linux段寄存器数据解析_2"></p><p>&emsp;&emsp;<code>TI</code> 值均为 <code>0</code>, 说明都是 <code>GDT</code>, 没有使用 <code>LDT</code>, 在 Linux 中 <code>LDT</code> 只在 <code>VM86模式</code> 下使用. <code>RPL</code> 内核使用 <code>00</code> 级, 普通进程使用 <code>11</code> 级. <code>index</code> 为固定值.</p><p>&emsp;&emsp;在 Linux 实现时会将 <code>GDT</code> 初始化为固定的值, <code>GDT</code> 第一项(下标为 0)会初始化为 <code>0x0000000000000000</code>, 这是<strong>为了防止加电后段寄存器未经初始化就进入保护模式并使用 <code>GDT</code></strong>. 第 2 ~ 5 项对应之前四中段寄存器.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/i386/kernel/head.S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This contains typically 140 quadwords, depending on NR_CPUS.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这通常包含140个四字(64位), 取决于NR_CPUS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! Make sure the gdt descriptor in head.S matches this if you</span></span><br><span class="line"><span class="comment"> * change anything.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意! 如果你改变任何东西, 请确保 head.S 中的 gdt 描述符与此匹配.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 初始化 GDT</span></span><br><span class="line">ENTRY(gdt_table)</span><br><span class="line">.quad <span class="number">0x0000000000000000</span><span class="comment">/* NULL descriptor */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span><span class="comment">/* not used */</span></span><br><span class="line">.quad <span class="number">0x00cf9a000000ffff</span><span class="comment">/* 0x10 kernel 4GB code at 0x00000000, __KERNEL_CS 指向的空间 */</span></span><br><span class="line">.quad <span class="number">0x00cf92000000ffff</span><span class="comment">/* 0x18 kernel 4GB data at 0x00000000, __KERNEL_DS 指向的空间 */</span></span><br><span class="line">.quad <span class="number">0x00cffa000000ffff</span><span class="comment">/* 0x23 user   4GB code at 0x00000000, __USER_CS 指向的空间 */</span></span><br><span class="line">.quad <span class="number">0x00cff2000000ffff</span><span class="comment">/* 0x2b user   4GB data at 0x00000000, __USER_DS 指向的空间 */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span><span class="comment">/* not used */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span><span class="comment">/* not used */</span></span><br></pre></td></tr></table></figure><p>将 2 ~ 5 项按照二进制展开:</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E5%9B%9B%E7%A7%8D%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B1%95%E5%BC%80.png" alt="四种段寄存器二进制展开" title="四种段寄存器二进制展开"></p><p>再按照段描述符表项内容进行分析:</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E9%A1%B9%E5%AE%9A%E4%B9%89.png" alt="段描述表项的定义" title="段描述表项的定义"></p><blockquote><p>相同:</p><ul><li>B0~B15, B16~B31 都是 0.    段基址全为 0.</li><li>L0~L15, L16~L19 都是 1.      段长度全为 0xfffff.</li><li>G 位都是 1.                             段长度单位均为 4KB.</li><li>D 位都是 1.                             对四个段的访问指令都是 32 位指令.</li><li>P 位都是 1.                             四个段都在内存中.</li></ul></blockquote><p>结论: <strong>每个段都是从 0 地址开始的整个 4G 虚拟空间, 虚拟地址到线性地址的映射保持原值不变.</strong></p><blockquote><p>不同:</p><ul><li><code>__KERNEL_CS</code> : <code>DPL</code> = 0, 表示 0 级; <code>S</code> 位为 1, 表示代码段或数据段; <code>type</code> 为 <code>1010</code>, 表示代码段, 可读, 可执行, 尚未受到访问.</li><li><code>__KERNEL_DS</code> : <code>DPL</code> = 0, 表示 0 级; <code>S</code> 位为 1, 表示代码段或数据段; <code>type</code> 为 <code>0010</code>, 表示数据段, 可读, 可执行, 尚未受到访问.</li><li><code>__USER_CS</code> : <code>DPL</code> = 3, 表示 3 级; <code>S</code> 位为 1, 表示代码段或数据段; <code>type</code> 为 <code>1010</code>, 表示代码段, 可读, 可执行, 尚未受到访问.</li><li><code>__USER_DS</code> : <code>DPL</code> = 3, 表示 3 级; <code>S</code> 位为 1, 表示代码段或数据段; <code>type</code> 为 <code>0010</code>, 表示数据段, 可读, 可执行, 尚未受到访问.</li></ul></blockquote><h2 id="页式映射"><a href="#页式映射" class="headerlink" title="页式映射"></a>页式映射</h2><p>&emsp;&emsp;每个进程都有其自身的页目录 <code>PGD</code>, 指向这个目录的指针保存在每个进程的 <code>mm_struct</code> 数据结构(<code>数据结构</code>中介绍)中. 每当一个进程运行时, 内核都要为其设置控制寄存器 <code>CR3</code>, 而 <code>MMU</code> 的硬件总是从 <code>CR3</code> 中取得指向当前页目录的指针. CPU 在执行过程中使用的是虚拟地址, 而 <code>MMU</code> 硬件在进行映射时使用的是物理地址, 这其中的计算则是通过 <code>基本框架</code> 中介绍的 <code>__ps</code> 进行计算的. 这里存在一个问题: 使用不同的页目录, 不会使程序不能连续执行吗? 答案是不会. 因为<a href="http://blog.csdn.net/q1n2hen/article/details/73650347" target="_blank" rel="noopener">所有进程的 <code>PGD</code> 对系统空间的 1G 空间映射完全相同</a>.</p><p>&emsp;&emsp;在获取到 <code>PGD</code> 地址后获取线性地址的最高 10 位作为下标, 在这个 <code>PGD</code> 表项中保存着 <code>PT</code> 的地址. 然后将线性地址接下来的 10 位作为 <code>PT</code> 的下标, 获取到对应的物理页面地址. 线性地址的最低 12 位为物理页面中的偏移量, 就是线性地址在物理内存中的地址.</p><p>&emsp;&emsp;在页面映射的过程中, <code>i386</code> CPU 需要访问三次内存. 第一次访问 <code>PGD</code>, 第二次访问 <code>PT</code>, 第三次才是真正的目标. 所以高效的虚拟内存有赖于两方面:</p><blockquote><ol><li>高速缓存(cache)的实现. 除第一次访问需要这三步, 之后就可以在高速缓存中找到.</li><li>这个过程由硬件实现, 速度很快.</li></ol></blockquote><p><em>本文整理自《Linux内核源代码情景分析》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Linux 采用页式内存管理.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面固定大小, 便于管理.&lt;/li&gt;
&lt;li&gt;灵活度高, 在将内存交换到磁盘上时, 按内存页进行交换.&lt;/li&gt;
&lt;li&gt;页式内存管理有内部碎片, 无外部碎片.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="内存管理" scheme="http://chunqiublog.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>基本框架</title>
    <link href="http://chunqiublog.github.io/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html"/>
    <id>http://chunqiublog.github.io/基本框架.html</id>
    <published>2018-01-23T14:30:24.000Z</published>
    <updated>2018-10-15T10:13:17.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="i386-内存映射"><a href="#i386-内存映射" class="headerlink" title="i386 内存映射"></a><code>i386</code> 内存映射</h2><p>&emsp;&emsp;<code>i386</code> CPU中采用的页式内存管理, 基本思路是：通过页目录和页表两层实现线性地址到物理地址的映射.</p><ul><li>优点: 大多数情况下可以节省页表所占的内存空间。当页表为空时只需要将对应页目录项置为空，就可以节省对相应页表的空间.</li><li>缺点: 适用最大内存为 <code>4G</code> 的内存.</li></ul><a id="more"></a><h2 id="Linux-内存映射"><a href="#Linux-内存映射" class="headerlink" title="Linux 内存映射"></a>Linux 内存映射</h2><p>&emsp;&emsp;由于 Linux 需要考虑不同CPU上的实现, 所有需要设计出一种通用的<code>内存映射模型模型</code>.</p><blockquote><ul><li><strong>Linux 内核的映射机制设计成三层, 在 <code>i386</code> 的页目录和页表的基础上在中间增设了一层”中间目录”.</strong></li></ul></blockquote><p>在源码中, 页目录称为 <code>PGD</code>, 中间目录称为 <code>PMD</code>, 页表称为 <code>PT</code>. 三者均为数组. 相应的逻辑上也将线性地址由高到低分为四个段位, 分别作用于页目录 <code>PGD</code> 的下标, 中间目录 <code>PMD</code> 的下标, 页表 <code>PT</code> 的下标以及物理页面中的位移.</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/%E4%B8%89%E5%B1%82%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="三层地址映射示意图" title="三层地址映射示意图"></p><p>&emsp;&emsp;对于 <code>i386</code> 中的段式内存映射<strong>在 Linux 内存映射时(除用来模拟80286的 <code>VM86模式</code>[^1]), 段式映射的基址总是 <code>0</code>, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射</strong>. <code>i386</code> 在 Pentium Pro 开始引入了物理地址扩充功能 <code>PAE</code>, 可以将地址宽度从32位上升为36位. 所以在 Linux 的内存映射模型对应到 <code>i386</code> CPU时, 如果设置了 <code>PAE</code> 则使用三层映射, 否则跳过中间的 <code>PMD</code> 层次, 使用两层映射.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Linux x86 paging architecture is 'compile-time dual-mode', it</span></span><br><span class="line"><span class="comment"> * implements both the traditional 2-level x86 page tables and the</span></span><br><span class="line"><span class="comment"> * newer 3-level PAE-mode page tables.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Linux x86 分页架构是'编译时双模式', 它实现了传统两层 x86 页表和新的三层 PAE 模式页表两种映射方式.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_X86_PAE <span class="comment">// 编译时设置</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/pgtable-3level.h&gt; // PAE模式三层映射</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/pgtable-2level.h&gt; // 两层映射</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __beep() asm(<span class="meta-string">"movb $0x3,%al; outb %al,$0x61"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_SIZE(1UL &lt;&lt; PMD_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_MASK(~(PMD_SIZE-1))</span></span><br><span class="line"><span class="comment">// 每个页目录项所指向空间的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGDIR_SIZE(1UL &lt;&lt; PGDIR_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGDIR_MASK(~(PGDIR_SIZE-1))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/pgtable-2level.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * traditional i386 two-level paging structure:</span></span><br><span class="line"><span class="comment"> * 传统 i386 两层分页结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PGD 数组的下标在线性地址中的起始位置, 即线性地址的 23 ~ 32 位(从 0 开始)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGDIR_SHIFT22</span></span><br><span class="line"><span class="comment">// 每个 PGD 中的指针数, 即 PGD 中页目录项的数量, i386 中指针所用空间为 4 个字节, 则 PGD 所占空间为 1024 * 4 = 4KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTRS_PER_PGD1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the i386 is two-level, so we don't really have any</span></span><br><span class="line"><span class="comment"> * PMD directory physically.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因为 i386 是两层分页结构, 所以我们不会有真正物理上的 PMD 目录.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PMD 数组的下标在线性地址中的起始位置, 与 PGDIR_SHIFT 相同, 即 PMD 在线性地址中不存在, 长度为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_SHIFT22</span></span><br><span class="line"><span class="comment">// 每个 PMD 中的指针数, 只有 1 个, 直接指向 PT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTRS_PER_PMD1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;32位地址意味着4G字节的虚存空间, Linux 内核将这4G字节的空间分成两个部分. 将最高的1G字节(从虚拟地址 <code>0xC0000000</code> 至 <code>0xFFFFFFFF</code>), 用于内核本身, 称为<strong>系统空间</strong>. 而将较低的3G字节(从虚拟地址    <code>0x00000000</code> 至 <code>0xBFFFFFFF</code>), 用作各个进程的<strong>用户空间</strong>, 理论上每个进程拥有独立的3G字节的用户空间. 系统空间是所有进程逻辑上共用的1G字节空间, 每一个进程通过系统调用从用户空间进入内核, 在系统空间中运行. 即每一个进程都拥有4G的虚拟空间, 较低的3G虚拟空间独立使用, 最高的1G虚拟空间与所用进程及内核共享.</p><p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/%E8%BF%9B%E7%A8%8B%E8%99%9A%E5%AD%98%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="进程虚存空间示意图" title="进程虚存空间示意图"></p><p><em>这里独立的虚拟空间只是在逻辑上独立, 但是在物理上所有的进程共用3G的物理内存.</em></p><p>&emsp;&emsp;<strong>系统空间在虚拟内存中占据最高的1G空间, 但是在物理内存中却是从最低地址(0)开始, 处于最低1G空间</strong>. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/page.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This handles the memory map.. We could make this a config</span></span><br><span class="line"><span class="comment"> * option, but too many people screw it up, and too few need</span></span><br><span class="line"><span class="comment"> * it.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里处理内核的内存映射. 我们可以将其设置为配置选项, 但是有许多人搞砸它, 并且很少需要它.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A __PAGE_OFFSET of 0xC0000000 means that the kernel has</span></span><br><span class="line"><span class="comment"> * a virtual address space of one gigabyte, which limits the</span></span><br><span class="line"><span class="comment"> * amount of physical memory you can use to about 950MB. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 值为 0xC0000000 的 __PAGE_OFFSET 意味着内核有 1GB 的虚拟空间, 这限制了可以内核使用的物理空间大约 950MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you want more physical memory than this then see the CONFIG_HIGHMEM4G</span></span><br><span class="line"><span class="comment"> * and CONFIG_HIGHMEM64G options in the kernel configuration.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果你想要超过这些的物理内存, 请参阅内核配置中的 CONFIG_HIGHMEM4G</span></span><br><span class="line"><span class="comment"> * 和 CONFIG_HIGHMEM64G 选项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PAGE_OFFSET(0xC0000000)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/page.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET((unsigned long)__PAGE_OFFSET)</span></span><br><span class="line"><span class="comment">// 计算系统空间在虚拟内存中对应物理空间中的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pa(x)((unsigned long)(x)-PAGE_OFFSET)</span></span><br><span class="line"><span class="comment">// 计算系统空间在物理内存中对应虚拟空间中的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __va(x)((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-i386/processor.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User space process size: 3GB (default).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用户空间进程大小: 3GB(默认)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 用户空间进程大小.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE(PAGE_OFFSET)</span></span><br></pre></td></tr></table></figure><p><em>本文整理自《Linux内核源代码情景分析》</em></p><p>[^1]: <code>VM86模式</code> 是为采用保护模式的系统提供 <code>实模式(real-mode)</code> 软件的兼容性, 用来在保护模式下模拟运行实模式的软件.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;i386-内存映射&quot;&gt;&lt;a href=&quot;#i386-内存映射&quot; class=&quot;headerlink&quot; title=&quot;i386 内存映射&quot;&gt;&lt;/a&gt;&lt;code&gt;i386&lt;/code&gt; 内存映射&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;i386&lt;/code&gt; CPU中采用的页式内存管理, 基本思路是：通过页目录和页表两层实现线性地址到物理地址的映射.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点: 大多数情况下可以节省页表所占的内存空间。当页表为空时只需要将对应页目录项置为空，就可以节省对相应页表的空间.&lt;/li&gt;
&lt;li&gt;缺点: 适用最大内存为 &lt;code&gt;4G&lt;/code&gt; 的内存.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://chunqiublog.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="内存管理" scheme="http://chunqiublog.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>etcd gateway</title>
    <link href="http://chunqiublog.github.io/etcd_gateway.html"/>
    <id>http://chunqiublog.github.io/etcd_gateway.html</id>
    <published>2018-01-02T11:36:48.000Z</published>
    <updated>2018-09-23T16:05:15.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>翻译自: <a href="https://github.com/coreos/etcd/blob/c578ac4a1a87f90ccd13ae210ee920ff2753387f/Documentation/op-guide/gateway.md" target="_blank" rel="noopener">etcd gateway</a></em></p><h1 id="etcd-gateway-是什么"><a href="#etcd-gateway-是什么" class="headerlink" title="etcd gateway 是什么?"></a>etcd gateway 是什么?</h1><p>etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.<br>这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持.</p><a id="more"></a><h1 id="什么时候使用-etcd-gateway"><a href="#什么时候使用-etcd-gateway" class="headerlink" title="什么时候使用 etcd gateway?"></a>什么时候使用 etcd gateway?</h1><p>每个访问 etcd 的应用必须首先拥有 etcd 集群的地址. 如果是同一台服务器上的多个应用访问同一个 etcd 集群, 每个应用仍然需要知道这个 etcd 集群公布的地址. 如果这个 etcd 集群重新配置为拥有不同端点的集群, 则每个应用程序可能还需要更新其端点列表. 这种大规模的重新配置既枯燥又容易出错.</p><p>etcd gateway 通过作为一个稳定的本地端点提供服务解决了这个问题. 一个典型的 etcd gateway 配置是让每一个机器运行一个监听本地端口的 gateway, 同时每一个 etcd 应用连接到这个本地 gateway. 这样在 etcd 集群重新配置时只有 gateway 需要更新它的端点配置, 而不是更新每一个应用.</p><p>总之, 为了自动传播 etcd 集群端点更改, etcd gateway 应该运行在为访问同一个 etcd 集群的多个应用程序提供服务的每台机器上.</p><h1 id="什么时候不应该使用-etcd-gateway"><a href="#什么时候不应该使用-etcd-gateway" class="headerlink" title="什么时候不应该使用 etcd gateway?"></a>什么时候不应该使用 etcd gateway?</h1><ul><li><p>提高性能<br>gateway 不是为了提高 etcd 集群性能而设置. 它不提供缓存, watch 的合并或批处理. etcd 团队正在开发一个旨在提高集群可扩展性的缓存代理.</p></li><li><p>在集群管理系统上运行<br>高级集群管理系统(如 Kubernetes) 本身支持服务发现, 应用程序可以使用有系统管理的 DNS 名称或虚拟 IP 地址访问 etcd 集群. 例如: kube-proxy等同于etcd网关.</p></li></ul><h1 id="启动-etcd-gateway"><a href="#启动-etcd-gateway" class="headerlink" title="启动 etcd gateway"></a>启动 etcd gateway</h1><p>考虑一个具有以下静态端点的 etcd 集群:</p><table><thead><tr><th>Name</th><th>Address</th><th>Hostname</th></tr></thead><tbody><tr><td>infra0</td><td>10.0.1.10</td><td>infra0.example.com</td></tr><tr><td>infra1</td><td>10.0.1.11</td><td>infra1.example.com</td></tr><tr><td>infra2</td><td>10.0.1.12</td><td>infra2.example.com</td></tr></tbody></table><p>使用包含这些静态端点的命令启动etcd gateway:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcd gateway start --endpoints=infra0.example.com,infra1.example.com,infra2.example.com</span><br><span class="line">2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...]</span><br></pre></td></tr></table></figure></p><p>或者, 如果使用 DNS 进行服务发现, 请考虑 DNS SRV 条目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dig +noall +answer SRV _etcd-client._tcp.example.com</span><br><span class="line">_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra0.example.com.</span><br><span class="line">_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra1.example.com.</span><br><span class="line">_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra2.example.com.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.com</span><br><span class="line">infra0.example.com.  300  IN  A  10.0.1.10</span><br><span class="line">infra1.example.com.  300  IN  A  10.0.1.11</span><br><span class="line">infra2.example.com.  300  IN  A  10.0.1.12</span><br></pre></td></tr></table></figure><p>使用以下命令从 DNS SRV 条目获取端点启动 etcd gateway:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcd gateway --discovery-srv=example.com</span><br><span class="line">2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...]</span><br></pre></td></tr></table></figure></p><h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h1><h2 id="etcd-集群"><a href="#etcd-集群" class="headerlink" title="etcd 集群"></a>etcd 集群</h2><h3 id="–endpoints"><a href="#–endpoints" class="headerlink" title="–endpoints"></a>–endpoints</h3><ul><li>逗号分隔的转发客户端连接的目标 etcd 集群列表</li><li>默认配置: <code>127.0.0.1:2379</code></li><li>无效示例: <code>https://127.0.0.1:2379</code>(gateway 不终止 TLS)</li></ul><h3 id="–discovery-srv"><a href="#–discovery-srv" class="headerlink" title="–discovery-srv"></a>–discovery-srv</h3><ul><li>通过 SRV 记录引导集群端点的 DNS 域名</li><li>默认配置: (不设置)</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="–listen-addr"><a href="#–listen-addr" class="headerlink" title="–listen-addr"></a>–listen-addr</h3><ul><li>接口和端口绑定接收客户端请求</li><li>默认: 127.0.0.1:23790</li></ul><h3 id="–retry-delay"><a href="#–retry-delay" class="headerlink" title="–retry-delay"></a>–retry-delay</h3><ul><li>重试连接到失败的端点之前的延迟时间</li><li>默认配置: 1m0s</li><li>无效示例: “123”(使用指定格式的时间单位)</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="–insecure-discovery"><a href="#–insecure-discovery" class="headerlink" title="–insecure-discovery"></a>–insecure-discovery</h3><ul><li>接收 SRV 记录是不安全或易受到中间人攻击的</li><li>默认配置: <code>false</code></li></ul><h3 id="–trusted-ca-file"><a href="#–trusted-ca-file" class="headerlink" title="–trusted-ca-file"></a>–trusted-ca-file</h3><ul><li>用于 etcd 集群的客户端 TLS CA 文件路径. 用于认证端点.</li><li>默认配置: (不设置)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;翻译自: &lt;a href=&quot;https://github.com/coreos/etcd/blob/c578ac4a1a87f90ccd13ae210ee920ff2753387f/Documentation/op-guide/gateway.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;etcd gateway&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;etcd-gateway-是什么&quot;&gt;&lt;a href=&quot;#etcd-gateway-是什么&quot; class=&quot;headerlink&quot; title=&quot;etcd gateway 是什么?&quot;&gt;&lt;/a&gt;etcd gateway 是什么?&lt;/h1&gt;&lt;p&gt;etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.&lt;br&gt;这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持.&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chunqiublog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="etcd" scheme="http://chunqiublog.github.io/tags/etcd/"/>
    
      <category term="翻译" scheme="http://chunqiublog.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis 4.0源码解析: SDS(3)</title>
    <link href="http://chunqiublog.github.io/Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_3.html"/>
    <id>http://chunqiublog.github.io/Redis_4_0源码解析_SDS_3.html</id>
    <published>2017-12-14T03:22:35.000Z</published>
    <updated>2018-09-23T16:25:32.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SDS-结构"><a href="#SDS-结构" class="headerlink" title="SDS 结构"></a>SDS 结构</h2><p>&emsp;&emsp;<code>SDS</code> 结构如下:<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 类型为 3 lsb, string 长度为 5 msb. */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;               <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;             <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中:</p><ul><li><code>len</code> 表示 <code>sds</code> 字符串的长度</li><li><code>alloc</code> 表示 <code>SDS</code> 结构体剩余空间</li><li><code>flags</code> 表示 <code>SDS</code> 结构体类型</li><li><code>buf</code> 表示 <code>sds</code> 字符串<br>&emsp;&emsp;4.0 版本将 3.0 版本时期统一的结构根据 <code>SDS</code> 结构体可以存储字符串的长度划分为不同的 <strong>5</strong> 种类型, 节省了内存占用的空间, 但是加大字符串操作的复杂度, 在字符串长度变动时需要改变 <code>SDS</code> 结构体类型.</li></ul><h2 id="SDS-优势"><a href="#SDS-优势" class="headerlink" title="SDS 优势"></a>SDS 优势</h2><blockquote><ol><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数</li><li>二进制安全</li><li>兼容部分 <code>C</code> 字符串函数</li></ol></blockquote><h2 id="SDS-内存分配策略"><a href="#SDS-内存分配策略" class="headerlink" title="SDS 内存分配策略"></a>SDS 内存分配策略</h2><ol><li>如果直接创建新结点, 会调用 <code>sdsnewlen</code> 函数根据指定字符串的长度创建一个新结点, 新结点没有空闲空间.</li><li>如果已有结点需要扩展空间时, 会调用 <code>sdsMakeRoomFor</code> 函数进行扩展.<br>a. 已有结点 <code>sds</code> 字符串空间 <code>&lt;</code> <code>SDS_MAX_PREALLOC</code>,  则对 <code>sds</code> 字符串空间扩展<strong>一倍</strong>.<br>b. 已有结点 <code>sds</code> 字符串空间 <code>&gt;=</code> <code>SDS_MAX_PREALLOC</code>(<code>1024 * 1024</code>),  则对 <code>sds</code> 字符串空间扩展 <code>SDS_MAX_PREALLOC</code>.</li><li><code>SDS</code> 会提供出一组接口使 <code>SDS</code> 的调用者需要释放或分配 <code>SDS</code> 相关的一些东西时可以使用. 同时将分配释放的宏封装起来可以在更换 <code>SDS</code> 分配器时不需要更改调用者中的分配器.</li></ol><h2 id="SDS-应用"><a href="#SDS-应用" class="headerlink" title="SDS 应用"></a>SDS 应用</h2><ul><li>保存数据库中的字符串值.</li><li>用作缓冲区(buffer)<ul><li>AOF 模块中的 AOF 缓冲区.</li><li>客户端状态中的输入缓冲区.</li></ul></li></ul><h2 id="SDS-源码的思考"><a href="#SDS-源码的思考" class="headerlink" title="SDS 源码的思考"></a>SDS 源码的思考</h2><ol><li>感觉没有必要使用 <code>SDS_HDR_VAR</code>, 会影响代码的可读性.</li><li>sdsnewlen 中为什么把 <code>len</code> 和 <code>alloc</code> 设置相同的字符串的长度?<br>len 表示字符串长度, <code>alloc</code> 表示字符串分配的空间, 这时分配空间是按照头结点长度 hdrlen + 字符串长度 <code>initlen</code> + <code>null</code> 终结符 1 进行计算, 分配给字符串的空间即为字符串长度, 所以这时的 <code>len</code> 等于 <code>alloc</code>.</li><li><code>sdsnewlen</code> 中为什么 <code>initlen</code> 为 0 时, 类型 5 不擅长?<br><em>(后续关注对 SDS 的调用)</em></li><li><code>sdsupdatelen</code> 是否已经弃用?<br><em>(后续关注对 SDS 的调用)</em></li><li><code>sdsRemoveFreeSpace</code> 的注释中 级联 是什么意思?<br><em>(后续关注对 SDS 的调用)</em></li><li><code>ssdsnew</code>, <code>sdsupdatelen</code>, <code>sdscat</code>, <code>sdscpy</code> 不是二进制安全, <code>sdscatrepr</code> -&gt; <code>sdscatprintf</code> -&gt; <code>sdscatvprintf</code> -&gt; <code>sdscat</code>, <code>sdsjoin</code> -&gt; <code>sdscat</code>, 二级制不安全. 注意 <code>sesdup</code> 调用的 <code>sdslen</code>, 二进制安全的. </li><li><code>zfree</code> 的时间复杂度是 O(N)? <code>sdsfree</code> 时间复杂度是 O(N)?<br><em>(后续关注对 SDS 的调用)</em></li><li><code>sdscatvprintf</code> 对于 <code>buf</code> 的处理为什么是将 -2 的位置置为 ‘\0’?<br>因为在 <code>vsnprintf(buf, buflen, fmt, cpy);</code> 函数中, 无论真正的格式化输出字符串的长度是否超过 <code>buflen</code>, <code>vsnprintf</code> 函数都会将 <code>buf[buflen - 1]</code> 置为 ‘\0’, 所以如果用 -1 位置判断就会出错, 只能用最后一个可以判断的字符即 -2  位置判断.</li><li><code>sdsfromlonglong</code> 真的比 <code>sdscatprintf</code> 快吗?<br><code>sdsfromlonglong</code> 调用 <code>sdsll2str</code> 进行转换, <code>sdscatprintf</code> -&gt; <code>sdscatvprintf</code> -&gt; <code>vsnprintf</code> 函数进行转换, 使用了可变参数. 猜测 <code>vsnprintf</code> 底层转换与 sdsll2str 相似. 在我自己的机器上实测了一下, <code>sdscatprintf</code> 会比 <code>sdsfromlonglong</code> 慢 1us.</li><li><code>sdscatrepr</code> 中 ‘\\‘, ‘“‘, 为什么不和其他字符一样使用 <code>sdscatlen</code>?<br>适用 <code>SDS</code> 中自带的测试集进行实测, 是可以实现的.</li><li><code>sdssplitargs</code> 如果处理类似 “ test\”aaa\” “ 会将参数识别为 test\”aaa\” 不影响吗?<br><em>(后续关注对 SDS 的调用)</em></li></ol><p><em>本文部分内容参考《Redis 设计与实现》一书.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SDS-结构&quot;&gt;&lt;a href=&quot;#SDS-结构&quot; class=&quot;headerlink&quot; title=&quot;SDS 结构&quot;&gt;&lt;/a&gt;SDS 结构&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;SDS&lt;/code&gt; 结构如下:&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chunqiublog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://chunqiublog.github.io/tags/Redis/"/>
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis 4.0源码解析: SDS(2)</title>
    <link href="http://chunqiublog.github.io/Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_2.html"/>
    <id>http://chunqiublog.github.io/Redis_4_0源码解析_SDS_2.html</id>
    <published>2017-12-14T03:22:31.000Z</published>
    <updated>2018-09-23T16:05:10.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本文将介绍 <code>SDS</code> 的实现.<br><a id="more"></a></p><p><code>sds.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SDSLib 2.0, 一个 C 实现的 strings 库 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sdsalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不同类型 sds 结构体大小</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr5);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr8);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr16);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr32);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 string 长度确定存储的 sds 类型</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(string_size &lt; <span class="number">1</span> &lt;&lt; <span class="number">5</span>) <span class="comment">// 最大 31</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(string_size &lt; <span class="number">1</span> &lt;&lt; <span class="number">8</span>) <span class="comment">// 最大 255</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(string_size &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>) <span class="comment">// 最大 65535</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span>(string_size &lt; <span class="number">1l</span>l &lt;&lt; <span class="number">32</span>) <span class="comment">//最大 2 ^ 32 - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64; <span class="comment">//最大 2 ^ 64 - 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制安全: 只会严格的按照二进制的数据存取. 不会妄图已某种特殊格式解析数据.</span></span><br><span class="line"><span class="comment">/* 使用 'init' 指针和 'initlen' 指定的内容创建一个新的 sds string.</span></span><br><span class="line"><span class="comment"> * 如果 'init' 是 NULL, 那么 string 将被初始化为 0 字节.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字符串始终为空终止(\0)(所有的 sds 字符串都是, 都总是)</span></span><br><span class="line"><span class="comment"> * 因此即使你创建一个这样的 sds 字符串:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen("abc", 3);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 你可以使用 printf() 打印字符串, 因为字符串的末尾有一个隐含的 \0.</span></span><br><span class="line"><span class="comment"> * 同时因为字符串长度保存在 sds 头结点中, 字符串是二进制安全的, \0也可以被包含在 sds 字符串中.</span></span><br><span class="line"><span class="comment"> * 也就是说 当 mystring = sdsnewlen("abc", 4); 时, \0 也是 sds 字符串中的一部分, 是二进制安全. */</span></span><br><span class="line"><span class="comment">// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过长度获取存储字符串的 SDS 类型</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为了添加字符串, 空字符串经常被创建.</span></span><br><span class="line"><span class="comment">     * 使用类型 8, 因为类型 5 在这里不适用. */</span></span><br><span class="line">    <span class="keyword">if</span>(type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        type = SDS_TYPE_8;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 SDS 类型获取 SDS 头结点大小</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* 标记指针 */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen + initlen + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!init)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sh == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = (<span class="keyword">char</span> *)sh + hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SDS 头结点</span></span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">        &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定初始化内容, 将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span>(initlen &amp;&amp; init)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串以 \0 结尾</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分, 而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个空(长度为 0) sds 字符串.</span></span><br><span class="line"><span class="comment"> * 在这种情况下字符串总是含有一个 null(\0) 终结符. */</span></span><br><span class="line"><span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据一个空终止(\0)的 C 字符串开始创建一个新的 sds 字符串. */</span></span><br><span class="line"><span class="comment">// 也只适合 C 字符串</span></span><br><span class="line"><span class="comment">// 根据给定字符串 init 创建一个包含同样字符串的 sds</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制一个 sds 字符串 */</span></span><br><span class="line"><span class="comment">// 复制给定 sds 的副本</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 sds. 如果 s 为空, 则不需要干什么 */</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_free((<span class="keyword">char</span> *)s - sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 sds 字符串长度为通过 strlen() 获取的长度, </span></span><br><span class="line"><span class="comment"> * 因此要考虑到内容只能到达第一个 null(\0) 字符.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当 sds 字符串被黑客以某种手动方式入侵时, 这个函数是很有用的,</span></span><br><span class="line"><span class="comment"> * 如下例所示:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * s = sdsnew("foobar");</span></span><br><span class="line"><span class="comment"> * s[2] = '\0';</span></span><br><span class="line"><span class="comment"> * sdsupdatelen(s);</span></span><br><span class="line"><span class="comment"> * printf("%d\n", sdslen(s));</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出将会是 2, 如果我们注释调用 sdsupdatelen() 的部分,</span></span><br><span class="line"><span class="comment"> * 输出将会是 6, 因为字符串被修改, 但是逻辑长度依然是 6. */</span></span><br><span class="line"><span class="comment">// 更新 sds 的长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改一个字符串, 使它立刻变成空(长度为 0).</span></span><br><span class="line"><span class="comment"> * 但是所有现有的缓冲区不会被丢弃, 而是设置为可用空间,</span></span><br><span class="line"><span class="comment"> * 以便下一次增加操作不需要预先分配可用的字节数. */</span></span><br><span class="line"><span class="comment">// 清空 sds 字符串的内容</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 sds 字符串的尾部扩增可用空间, 以便确保该函数的调用者在调用该函数后可以 sds 字符串末尾写入 addlen 个字节.</span></span><br><span class="line"><span class="comment"> * 再在末尾加上一个 null 终结符.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意: 注意这个函数不会改变 sdslen() 返回的 sds 字符串的 *length*, </span></span><br><span class="line"><span class="comment"> * 只能改变我们拥有的可用缓冲区空间. */</span></span><br><span class="line"><span class="comment">// 当 sds 字符串空间充足时, 直接返回, 空间不足时, 重新分配空间, 设置 sds 头结点, 字符串内容</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    <span class="keyword">void</span> *newsh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前空闲空间大小</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">size_t</span> newlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="comment">// 获取当前 sds 的类型</span></span><br><span class="line">    <span class="keyword">char</span> oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果空间足够, 立刻返回 */</span></span><br><span class="line">    <span class="keyword">if</span>(avail &gt;= addlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span> *)s - sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要新分配给 sds 字符串的空间的长度小于 sds 最大预分配给 sds 字符串的空间长度</span></span><br><span class="line">    <span class="keyword">if</span>(newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">    &#123;</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果需要新分配给 sds 字符串的空间的长度大于最大预分配给 sds 字符串的空间长度时, 每次增长最大预分配给 sds 字符串的空间长度</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要新分配给 sds 字符串的空间的长度计算新的 sds 需要的类型</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不要使用类型 5: 当用户扩增字符串时, 由于类型 5 不能记住空闲空间,</span></span><br><span class="line"><span class="comment">     * 因此调用 sdsMakeRoomFor() 时必须进行扩增操作 */</span></span><br><span class="line">    <span class="keyword">if</span>(type == SDS_TYPE_5)</span><br><span class="line">    &#123;</span><br><span class="line">        type = SDS_TYPE_8;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oldtype == type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果新类型与原来的类型相同, 重新分配新长度的 sds 并将原来 sds 字符串(包括头结点和 null 终结符)拷贝到新空间.</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(newsh == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 由于头结点大小改变, 需要将字符串向前移动, 不能直接使用 realloc */</span></span><br><span class="line">        <span class="comment">// 如果新类型与原来的类型不同, 重新分配新类型新长度的 sds </span></span><br><span class="line">        newsh = s_malloc(hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(newsh == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的 sds 字符串拷贝到新 sds 中</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放原来的 sds</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">        <span class="comment">// 设置新 sds 类型, 长度</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新分配空间大小</span></span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了使 sds 字符串结尾没有可用空间, 对其重新分配空间.</span></span><br><span class="line"><span class="comment"> * 剩下的 sds 字符串没有改变, 但是下一个级联操作将需要重新分配空间.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在被调用后, 通过这个函数的 sds 字符串不能变的更长, 所有的指针必须被调用返回的新指针替换 */</span></span><br><span class="line"><span class="comment">// 将 sds 字符串的空间缩短到字符串自身的长度.</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    <span class="keyword">void</span> *newsh;</span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">char</span> oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span> *)s - sdsHdrSize(oldtype);</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oldtype == type)</span><br><span class="line">    &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen + len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(newsh == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen + len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(newsh == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定 sds 字符串分配总空间的大小</span></span><br><span class="line"><span class="comment"> * 包括:</span></span><br><span class="line"><span class="comment"> * 1) 指针前的 sds 头结点.</span></span><br><span class="line"><span class="comment"> * 2) 字符串.</span></span><br><span class="line"><span class="comment"> * 3) 结尾若干可用缓冲区.</span></span><br><span class="line"><span class="comment"> * 4) 隐含的 null 终结符.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 获取分配给 sds 的总空间</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> alloc = sdsalloc(s);</span><br><span class="line">    <span class="keyword">return</span> sdsHdrSize(s[<span class="number">-1</span>]) + alloc + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回 sds 真实的分配总空间(通常, sds 字符串作为字符串缓冲区开始的参考) */</span></span><br><span class="line"><span class="comment">// 获取 sds 总空间的指针</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)(s = sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据 'incr' 增加 sds 字符串长度, 并减小字符串左侧可用空间.</span></span><br><span class="line"><span class="comment"> * 同时在新的字符串结尾设置 null 终结符.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用这个函数是为了在用户调用 sdsMakeRoomFor() 函数后, 在当前字符串的结尾写入一些东西,</span></span><br><span class="line"><span class="comment"> * 最后需要设置字符串新长度是修改字符串的长度.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意: 可以使用负增量来从右侧缩减字符串.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用法示例:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用以下模式调用 sdsIncrLen() 和 sdsMakeRoomFor(), 可以将字符串直接从内核挂载连接到</span></span><br><span class="line"><span class="comment"> * sds 字符串末尾, 不需要复制到中间缓冲区.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * oldlen = sdslen(s);</span></span><br><span class="line"><span class="comment"> * s = sdsMakeRoomFor(s, BUFFER_SIZE);</span></span><br><span class="line"><span class="comment"> * nread = read(fd, s + oldlen, BUFFER_SIZE);</span></span><br><span class="line"><span class="comment"> * ... 检查 nread &lt;= 0 并处理它 ...</span></span><br><span class="line"><span class="comment"> * sdsIncrLen(s, nread);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 修改 sds 字符串长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 sds 字符串长度</span></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> oldlen = SDS_TYPE_5_LEN(flags);</span><br><span class="line">            assert((incr &gt; <span class="number">0</span> &amp;&amp; oldlen + incr &lt; <span class="number">32</span>) || (incr &lt; <span class="number">0</span> &amp;&amp; oldlen &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            *fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            len = oldlen + incr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len +=incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len +=incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len +=incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len +=incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            len = <span class="number">0</span>; <span class="comment">/* 只是为了避免编译警告 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 sds 字符串的长度增长到指定长度. 增长的长度初始化为 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果指定的长度比当前 sds 字符串的短, 则不执行任何操作. */</span></span><br><span class="line"><span class="comment">// 增长字符串, 并将增加的部分置为 0</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &lt;= curlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩增 sds 字符串分配的空间</span></span><br><span class="line">    s = sdsMakeRoomFor(s, len - curlen);</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保添加的区域不包含垃圾 */</span></span><br><span class="line">    <span class="comment">// 将添加区域初始化为 0</span></span><br><span class="line">    <span class="built_in">memset</span>(s + curlen, <span class="number">0</span>, (len - curlen + <span class="number">1</span>));</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 sds 字符串 's' 后添加二进制安全的 len 个字节的 't' 字符串</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */</span></span><br><span class="line"><span class="comment">// 在 sds 字符串后添加长度为 len 的字符串</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空间足够直接返回, 空间不足获取空间</span></span><br><span class="line">    s = sdsMakeRoomFor(s, len);</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s + curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen + len);</span><br><span class="line">    s[curlen + len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 sds 字符串后添加指定以 null 终止的 C 字符串.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */</span></span><br><span class="line"><span class="comment">// 在 sds 字符串后添加指定以 null 终止的 C 字符串.</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在现有 sds 字符串后添加指定 sds 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */</span></span><br><span class="line"><span class="comment">// 在 sds 字符串后添加指定 sds 字符串.</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 破坏性的修改 sds 字符串来保存指定的长度为 'len' 字节的二进制安全的字符串 't'. */</span></span><br><span class="line"><span class="comment">// 拷贝二进制安全字符串 't' 到 sds 字符串中.</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查看字符串空间是否足够</span></span><br><span class="line">    <span class="keyword">if</span>(sdsalloc(s) &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        s = sdsMakeRoomFor(s, len - sdslen(s));</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似 sdscpylen() 但是 't' 必须是一个以 null 终结的字符串, 以便通过 strlen() 获取字符串长度. */</span></span><br><span class="line"><span class="comment">// 对 C 字符串进行拷贝</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 帮助 sdscatlonglong() 进行实际的数字 -&gt; 字符串的转换.</span></span><br><span class="line"><span class="comment"> * 's' 必须指向一个最少 SDS_LLSTR_SIZE 字节的字符串空间.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数返回存储在 's' 中的以 null 终结的字符串表示的长度 */</span></span><br><span class="line"><span class="comment">// long long 类型转换为 string 类型</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">char</span> aux;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">size_t</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成字符串表示, 这种方式产生一个反转的字符串 */</span></span><br><span class="line">    <span class="comment">// 将 long long 反转存储在字符串中</span></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    p = s;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只能适用于 C 语言字符集</span></span><br><span class="line">        *p++ = <span class="string">'0'</span> + (v % <span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算长度并添加 null 终止符 */</span></span><br><span class="line">    l = p - s;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反转字符串 */</span></span><br><span class="line">    <span class="comment">// 将反转的字符串反转就是 long long 的顺序字符串表示</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    p --;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; p)</span><br><span class="line">    &#123;</span><br><span class="line">        aux = *s;</span><br><span class="line">        *s = *p;</span><br><span class="line">        *p = aux;</span><br><span class="line">        s++;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 与 sdsll2str() 相同, 但是这个函数是针对 unsigned long long 类型. */</span></span><br><span class="line"><span class="comment">// unsigned long long 类型转换为 string 类型</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsull2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">char</span> aux;</span><br><span class="line">    <span class="keyword">size_t</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成字符串表示, 这种方式产生一个反转的字符串 */</span></span><br><span class="line">    p = s;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">'0'</span> + (v % <span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算长度并添加 null 终止符 */</span></span><br><span class="line">    l = p - s;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反转字符串 */</span></span><br><span class="line">    p--;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; p)</span><br><span class="line">    &#123;</span><br><span class="line">        aux = *s;</span><br><span class="line">        *s = *p;</span><br><span class="line">        *p = aux;</span><br><span class="line"></span><br><span class="line">        s++;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据一个 long long 值创建一个 sds 字符串. 这要比以下方式快很多:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sdscatprintf(sdsempty(), "%lld\n", value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// long long 类型转换为 sds 类型</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似 sdscatprintf() 但是获取的是 va_list 而不是可变参数 */</span></span><br><span class="line"><span class="comment">// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *buf = staticbuf;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们尝试开始使用静态缓冲区来提升速度.</span></span><br><span class="line"><span class="comment">     * 如果不可能, 我们回到使用堆分配. */</span></span><br><span class="line">    <span class="keyword">if</span>(buflen &gt; <span class="keyword">sizeof</span>(staticbuf))</span><br><span class="line">    &#123;</span><br><span class="line">        buf = s_malloc(buflen);</span><br><span class="line">        <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每次当我们使用当前缓冲区大小无法适应字符串时, 尝试使用缓冲区的两倍大小. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[buflen - <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        va_copy(cpy, ap);</span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        va_end(cpy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buf[buflen - <span class="number">2</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓冲区大小无法适应字符串.</span></span><br><span class="line">            <span class="keyword">if</span>(buf != staticbuf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在堆上分配的空间, 释放</span></span><br><span class="line">                s_free(buf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新分配两倍大小的空间</span></span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            buf = s_malloc(buflen);</span><br><span class="line">            <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直到适应字符串</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最后将获得的字符串添加到 sds 字符串并返回它. */</span></span><br><span class="line">    <span class="comment">// 将字符串添加到 sds 字符串后</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    <span class="keyword">if</span>(buf != staticbuf)</span><br><span class="line">    &#123;</span><br><span class="line">        s_free(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将使用类似 printf 指定格式获得的字符串添加到 sds 字符串.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在被调用后, 被修改的 sds 字符串将不再有效, </span></span><br><span class="line"><span class="comment"> * 所有指针必须被调用返回的新指针替代.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Sum is: ");</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s, "%d+%d = %d", a, b, a + b);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常, 你需要使用类似 printf 格式从头创建一个字符串.</span></span><br><span class="line"><span class="comment"> * 当你需要时, 只需要使用 sdsempty() 作为字符串:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(sdsempty(), "... your format ...", args);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数类似 sdscatprintf, 但是要快很多, 它没有依靠 libc 中通常很慢的 sprintf() 系列函数.</span></span><br><span class="line"><span class="comment"> * 此外, 将 sds 字符串作为被连接新数据直接处理提供了性能改进.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然而, 这个函数只处理类似 printf 的格式说明符的不兼容子集.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %s - C 字符串</span></span><br><span class="line"><span class="comment"> * %S - SDS 字符串</span></span><br><span class="line"><span class="comment"> * %i - 有符号整形</span></span><br><span class="line"><span class="comment"> * %I - 64 位有符号整形(long long, int64_t)</span></span><br><span class="line"><span class="comment"> * %u - 无符号整形</span></span><br><span class="line"><span class="comment"> * %U - 64 位无符号整形(unsigned long long, uint64_t)</span></span><br><span class="line"><span class="comment"> * %% - % 字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = sdslen(s);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *f = fmt;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    va_list ap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历参数</span></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    f = fmt;      <span class="comment">/* 遍历格式化输出字符串中格式说明符下一个要处理的字节. */</span></span><br><span class="line">    i = initlen;  <span class="comment">/* 写入目标字符串下一个字节的位置. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历格式化输出字符串</span></span><br><span class="line">    <span class="keyword">while</span>(*f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> next, *str;</span><br><span class="line">        <span class="keyword">size_t</span> l;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> unum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 确保至少有一个字节的空间 */</span></span><br><span class="line">        <span class="comment">// 确保当该字符不是说明符时有可以存储的 1 字节空间</span></span><br><span class="line">        <span class="keyword">if</span>(sdsavail(s) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = sdsMakeRoomFor(s, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理有可能为说明符的情况, 即 *f 为 %.</span></span><br><span class="line">        <span class="keyword">switch</span>(*f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">                next = *(f + <span class="number">1</span>);</span><br><span class="line">                f++;</span><br><span class="line">                <span class="keyword">switch</span>(next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                        str = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">                        l = (next == <span class="string">'s'</span>) ? <span class="built_in">strlen</span>(str) : sdslen(str);</span><br><span class="line">                        <span class="comment">// 空间不足时扩容</span></span><br><span class="line">                        <span class="keyword">if</span>(sdsavail(s) &lt; l)</span><br><span class="line">                        &#123;</span><br><span class="line">                            s = sdsMakeRoomFor(s, l);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将字符串添加到 sds 字符串后</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(s + i, str, l);</span><br><span class="line">                        sdsinclen(s, l);</span><br><span class="line">                        i += l;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                        <span class="keyword">if</span>(next == <span class="string">'i'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            num = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            num = va_arg(ap, <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 long long 转换为字符串</span></span><br><span class="line">                        <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">                        l = sdsll2str(buf, num);</span><br><span class="line">                        <span class="keyword">if</span>(sdsavail(s) &lt; l)</span><br><span class="line">                        &#123;</span><br><span class="line">                            s = sdsMakeRoomFor(s, l);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">memcpy</span>(s + i, buf, l);</span><br><span class="line">                        sdsinclen(s, l);</span><br><span class="line">                        i += l;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                        <span class="keyword">if</span>(next == <span class="string">'u'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            unum = va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            unum = va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">                        l = sdsull2str(buf, unum);</span><br><span class="line">                        <span class="keyword">if</span>(sdsavail(s) &lt; l)</span><br><span class="line">                        &#123;</span><br><span class="line">                            s = sdsMakeRoomFor(s, l);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">memcpy</span>(s + i, buf, l);</span><br><span class="line">                        sdsinclen(s, l);</span><br><span class="line">                        i += l;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="comment">/* 处理 %%, 通常为 %&lt;unknown&gt;. */</span></span><br><span class="line">                        s[i++] = next;</span><br><span class="line">                        sdsinclen(s, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 处理不是 % 开头的可能为说明符的情况</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                s[i++] = *f;</span><br><span class="line">                sdsinclen(s, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f++;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加 null 终结符 */</span></span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从字符串左边和右边分别删除 sds 字符串的一部分, 删除的字符串为在 'cset' 中找到的字符组成的连续字符,</span></span><br><span class="line"><span class="comment"> * 'cset' 字符串是一个 null 终结的 C 字符串.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用这个函数后, 被修改 sds 字符串不再有效,</span></span><br><span class="line"><span class="comment"> * 所有指针必须被调用返回的新指针替代.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHellWorld    :::");</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s, "Aa. :");</span></span><br><span class="line"><span class="comment"> * printf("%s\n", s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只输出 "Hello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 删除 sds 字符串首尾在 'cset' 中存在的字符串</span></span><br><span class="line"><span class="comment">// T = O(M*N)，M 为 SDS 长度, N 为 cset 长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start;</span><br><span class="line">    <span class="keyword">char</span> *end;</span><br><span class="line">    <span class="keyword">char</span> *sp;</span><br><span class="line">    <span class="keyword">char</span> *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s + sdslen(s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头向尾遍历</span></span><br><span class="line">    <span class="comment">// T = O(M * N)</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp))</span><br><span class="line">    &#123;</span><br><span class="line">        sp++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从尾向头遍历</span></span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep))</span><br><span class="line">    &#123;</span><br><span class="line">        ep--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep - sp) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动剩余部分</span></span><br><span class="line">    <span class="keyword">if</span>(s != sp)</span><br><span class="line">    &#123;</span><br><span class="line">        memmove(s, sp, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * start 和 end 可以是负数, 其中 -1 表示字符串的最后一个字符, -2 表示倒数第二个字符, 等等.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 间隔是包含的, 因此开始和结束字符是生成字符串的一部分. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字符串就地被修改.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span><br><span class="line"><span class="comment"> * sdsrange(s, 1, -1); // =&gt; "ello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将 sds 字符串缩短为 'start' 到 'end' 之间, 闭区间</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newlen;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定 'start' 是负数</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start = len + start;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 赋值负数超出字符串范围的 start 为 0</span></span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(end &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        end = len + end;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 start 和 end 指定子串的长度, 包含 start 和 end</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end - start) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(newlen != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= (<span class="keyword">signed</span>)len)</span><br><span class="line">        &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &gt;= (<span class="keyword">signed</span>)len)</span><br><span class="line">        &#123;</span><br><span class="line">            end = len - <span class="number">1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end - start) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里 newlen = 0, 一定进入下一个 if</span></span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清楚 start 前的字符</span></span><br><span class="line">    <span class="keyword">if</span>(start &amp;&amp; newlen)</span><br><span class="line">    &#123;</span><br><span class="line">        memmove(s, s + start, newlen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newlen 为 0 时, 清空字符串.</span></span><br><span class="line">    <span class="comment">// 即为 s[newlen] = '\0';</span></span><br><span class="line">    s[newlen] = <span class="number">0</span>;</span><br><span class="line">    sdssetlen(s, newlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对 sds 字符串 's' 的每一个字符调用 tolower() */</span></span><br><span class="line"><span class="comment">// 将 sds 字符串 's' 中的字母转换为小写字母</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换每一个字符</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对 sds 字符串 's' 的每一个字符调用 sdstoupper() */</span></span><br><span class="line"><span class="comment">// 将 sds 字符串 's' 中的字母转换为大写字母</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 memcmp() 比较两个 sds 字符串 s1 和 s2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     如果 s1 &gt; s2, 返回正数.</span></span><br><span class="line"><span class="comment"> *     如果 s1 &lt; s2, 返回负数.</span></span><br><span class="line"><span class="comment"> *     如果s1和s2是完全相同的二进制字符, 则为0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果两个字符串共享完全相同的前缀, 但是其中的一个长度更长, 则较长的字符串被认为大于较小的字符串. */</span></span><br><span class="line"><span class="comment">// 比较两个字符串</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1;</span><br><span class="line">    <span class="keyword">size_t</span> l2;</span><br><span class="line">    <span class="keyword">size_t</span> minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    <span class="comment">// 获取最小长度</span></span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    <span class="comment">// 比较最小长度空间中的字符</span></span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1, s2, minlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmp == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 最小长度空间中字符相同, 返回长度的差值, 为 0 则两个字符串相同</span></span><br><span class="line">        <span class="keyword">return</span> l1 - l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小长度空间中不同字符的差</span></span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用分隔符 'sep' 分割 's'. 返回 sds 字符串数组.</span></span><br><span class="line"><span class="comment"> * *count 将会被指针设置为 sds 的数量.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 内存溢出, 空字符串, 空分隔符将会返回 NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意: 'sep' 可以是一个由多个字符组成的分隔符. 例如:</span></span><br><span class="line"><span class="comment"> * sdssplit("foo_-_bar", "_-_");</span></span><br><span class="line"><span class="comment"> * 将返回 "foo" 和 "bar" 两个元素.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数的版本是二级制安全的, 但是需要参数长度.</span></span><br><span class="line"><span class="comment"> * sdssplit() 是只针对 NULL 终结的字符串的相同函数.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾</span></span><br><span class="line"><span class="comment">// T = O(N ^ 2)</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slots = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    sds *tokens;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens = s_malloc(<span class="keyword">sizeof</span>(sds) * slots);</span><br><span class="line">    <span class="keyword">if</span>(tokens == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="comment">// T = O(N ^ 2)</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; (len - (seplen - <span class="number">1</span>)), j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 确保下一个元素和最后一个元素有空间 */</span></span><br><span class="line">        <span class="keyword">if</span>(slots &lt; elements + <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            newtokens = s_realloc(tokens, <span class="keyword">sizeof</span>(sds) * slots);</span><br><span class="line">            <span class="keyword">if</span>(newtokens == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 搜索分隔符 */</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">if</span>((seplen == <span class="number">1</span> &amp;&amp; *(s + j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s + j, sep, seplen) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到分隔符</span></span><br><span class="line">            tokens[elements] = sdsnewlen(s + start, j - start);</span><br><span class="line">            <span class="keyword">if</span>(tokens[elements] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elements++;</span><br><span class="line">            start = j + seplen;</span><br><span class="line">            <span class="comment">// 麻蛋, -1 是因为 for 循环自己加了 1</span></span><br><span class="line">            j = j + seplen - <span class="number">1</span>; <span class="comment">/* 跳过分隔符 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加最后一个元素. 我们确定在标记数组中存在空间. */</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s + start, len - start);</span><br><span class="line">    <span class="keyword">if</span>(tokens[elements] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">// 清理空间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; elements; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sdsfree(tokens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        s_free(tokens);</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 sdssplitlen() 返回的结果, 或者当 'tokens' 为 NULL 时什么都不做. */</span></span><br><span class="line"><span class="comment">// 释放分割的结果</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tokens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_free(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为 sds 字符串 's' 添加将所有无法打印的字符(使用 isprint() 测试)</span></span><br><span class="line"><span class="comment"> * 变成 "\n\r\a..." 或 "\x&lt;hex-number&gt;" 转移的形式组成的转义字符串的表示.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在被调用后, 被修改的 sds 字符串将不再有效, </span></span><br><span class="line"><span class="comment"> * 所有指针必须被调用返回的新指针替代. */</span></span><br><span class="line"><span class="comment">// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = sdscatlen(s, <span class="string">"\""</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                s = sdscatprintf(s, <span class="string">"\\%c"</span>, *p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// case '\\': s = sdscatlen(s, "\\\\", 2); break;</span></span><br><span class="line">            <span class="comment">// case '"': s = sdscatlen(s, "\\\"", 2); break;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s, <span class="string">"\\n"</span>, <span class="number">2</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s, <span class="string">"\\r"</span>, <span class="number">2</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s, <span class="string">"\\t"</span>, <span class="number">2</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s, <span class="string">"\\a"</span>, <span class="number">2</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s, <span class="string">"\\b"</span>, <span class="number">2</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isprint</span>(*p))</span><br><span class="line">                &#123;</span><br><span class="line">                    s = sdscatprintf(s, <span class="string">"%c"</span>, *p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s = sdscatprintf(s, <span class="string">"\\x%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, <span class="string">"\""</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sdssplitargs() 的辅助函数, 如果 'c' 是有效的十六进制, 则返回非零. */</span></span><br><span class="line"><span class="comment">// 测试字符是否为十六进制字符</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;=<span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sdssplitargs() 的辅助函数, 将十六进制数转换为从 0 到 15 的整数. */</span></span><br><span class="line"><span class="comment">// 将十六进制转换为从 0 到 15 的整数.</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把一行文本切割成多个参数, 每个参数可以有以下的类编程语言 REPL 格式:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * foo bar "newline are suported\n" and "\xff\x00otherstuff"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数的数量存储在 *argc 中, 这个函数会返回一个 sds 数组.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者应该调用 sdsfreesplitres() 函数释放生成的 sds 数组.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意: sdscatrepr() 可以将一个字符串转换为一个带引号的字符串,</span></span><br><span class="line"><span class="comment"> * 相同格式的字符串可以被 sdssplitargs() 函数解析.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即使当输入出现空字符串, 函数仍然会将成功处理的字符串返回.</span></span><br><span class="line"><span class="comment"> * 或当输入不对应的引号或后引号后面没有跟空格例如: "foo"bar 或 "foo' 时返回 NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// * 这个函数主要用于 config.c 中对配置文件进行分析, 将字符串按照 REPL 格式切分成一个 sds 参数数组.</span></span><br><span class="line"><span class="comment">// * </span></span><br><span class="line"><span class="comment">// * 例如:</span></span><br><span class="line"><span class="comment">// *     sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");</span></span><br><span class="line"><span class="comment">// * 会得出:</span></span><br><span class="line"><span class="comment">// *     arr[0] = "timeout"</span></span><br><span class="line"><span class="comment">// *     arr[1] = "10086"</span></span><br><span class="line"><span class="comment">// *     arr[2] = "port"</span></span><br><span class="line"><span class="comment">// *     arr[3] = "123321"</span></span><br><span class="line"><span class="comment">// * T = O(N)</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = line;</span><br><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遇到空格跳过</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p))</span><br><span class="line">        &#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 获取一个标记 */</span></span><br><span class="line">            <span class="keyword">int</span> inq = <span class="number">0</span>;  <span class="comment">/* 如果遇到引号设置为 1 */</span></span><br><span class="line">            <span class="keyword">int</span> insq = <span class="number">0</span>; <span class="comment">/* 如果遇到单引号设置为 1 */</span></span><br><span class="line">            <span class="comment">// 当前参数结束了设置为 1</span></span><br><span class="line">            <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个 sds 存储参数</span></span><br><span class="line">            <span class="keyword">if</span>(current == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current = sdsempty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T = O(N)</span></span><br><span class="line">            <span class="keyword">while</span>(!done)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(inq)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 前面遍历过前引号</span></span><br><span class="line">                    <span class="keyword">if</span>(*p == <span class="string">'\\'</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">'x'</span> </span><br><span class="line">                        &amp;&amp; is_hex_digit(*(p + <span class="number">2</span>)) &amp;&amp; is_hex_digit(*(p + <span class="number">3</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 遇到十六进制表示, 转换为字符</span></span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">                        byte = (hex_digit_to_int(*(p + <span class="number">2</span>)) * <span class="number">16</span>) + hex_digit_to_int(*(p + <span class="number">3</span>));</span><br><span class="line">                        current = sdscatlen(current, (<span class="keyword">char</span> *)&amp;byte, <span class="number">1</span>);</span><br><span class="line">                        p += <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="string">'\\'</span> &amp;&amp; *(p + <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 遇到转义字符, 转换为对应的字符</span></span><br><span class="line">                        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">                        p++;</span><br><span class="line">                        <span class="keyword">switch</span>(*p)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>; </span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        current = sdscatlen(current, &amp;c, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="string">'"'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 后引号后面必须紧跟空格或者在字符串结尾 */</span></span><br><span class="line">                        <span class="comment">// 遇到后引号, 检测后一个字符是否为空格或结束</span></span><br><span class="line">                        <span class="keyword">if</span>(*(p + <span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p + <span class="number">1</span>)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 不是执行错误处理代码</span></span><br><span class="line">                            <span class="keyword">goto</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!*p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 引号没有终止 */</span></span><br><span class="line">                        <span class="comment">// 没有后引号就结束</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 否则为普通字符</span></span><br><span class="line">                        current = sdscatlen(current, p, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(insq)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 前面遍历过前单引号</span></span><br><span class="line">                    <span class="keyword">if</span>(*p == <span class="string">'\\'</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">'\''</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 遇到转义的单引号</span></span><br><span class="line">                        p++;</span><br><span class="line">                        current = sdscatlen(current, <span class="string">"'"</span>, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="string">'\''</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 后引号后面必须紧跟空格或者在字符串结尾 */</span></span><br><span class="line">                        <span class="comment">// 遇到后单引号, 检测后一个字符是否为空格或结束</span></span><br><span class="line">                        <span class="keyword">if</span>(*(p + <span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p + <span class="number">1</span>)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">goto</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!*p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 引号没有终止 */</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 否则为普通字符</span></span><br><span class="line">                        current = sdscatlen(current, p, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 不在引号内的字符</span></span><br><span class="line">                    <span class="keyword">switch</span>(*p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 分隔参数的符号</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'\0'</span>:</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 前引号</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                            inq = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 后引号</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'\''</span>:</span><br><span class="line">                            insq = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 普通字符</span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            current = sdscatlen(current, p, <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 指针向后移动</span></span><br><span class="line">                <span class="keyword">if</span>(*p)</span><br><span class="line">                &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 在 vector 中添加标记 */</span></span><br><span class="line">            <span class="comment">// 将参数添加到参数数组 vector 中</span></span><br><span class="line">            <span class="comment">// T = O(N)</span></span><br><span class="line">            <span class="built_in">vector</span> = s_realloc(<span class="built_in">vector</span>, ((*argc) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span><br><span class="line">            (*argc)++;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 即使是空字符串仍然返回一些内容, 不会返回 NULL */</span></span><br><span class="line">            <span class="comment">// 字符串遍历结束</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">vector</span> == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span> = s_malloc(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出错时, 清理内存空间, 返回 NULL</span></span><br><span class="line">        <span class="keyword">while</span>((*argc)--)</span><br><span class="line">        &#123;</span><br><span class="line">            sdsfree(<span class="built_in">vector</span>[*argc]);</span><br><span class="line">        &#125;</span><br><span class="line">        s_free(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current)</span><br><span class="line">        &#123;</span><br><span class="line">            sdsfree(current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *argc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 sds 字符串中所有 'from' 字符串中指定的字符集出现的字符替换为 'to' 数组中相应位置的字符.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如:</span></span><br><span class="line"><span class="comment"> * sdsmapchars(mystring, "ho", "01", 2);</span></span><br><span class="line"><span class="comment"> * 将具有将字符串 "hello" 转换为 "0ell1" 的效果.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数返回 sds 字符串指针, 它总是与输入指针大小相同, 因此不需要调整大小. */</span></span><br><span class="line"><span class="comment">// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符</span></span><br><span class="line"><span class="comment">// T = O(M * N) M 为 setlen 的长度, N 为 s 的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> j;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">size_t</span> l = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; l; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; setlen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == from[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s[j] = to[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用指定分隔符(C 字符串)将一个 C 字符串数组组合成一个 sds 字符串.</span></span><br><span class="line"><span class="comment"> * 以 sds 字符串形式返回结果 */</span></span><br><span class="line"><span class="comment">// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j != argc - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            join = sdscat(join, sep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似 sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串. */</span></span><br><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        join = sdscatsds(join, argv[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j != argc - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            join = sdscatlen(join, sep, seplen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 低等级函数作为 API 暴露给用户使用 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 封装被 SDS 使用的分配器. </span></span><br><span class="line"><span class="comment"> * 注意: 为了避免函数调用过程的付出开销, SDS 实际上只使用 sdsalloc.h 中定义的宏.</span></span><br><span class="line"><span class="comment"> * 这里, 我们定义这些封装只有在当链接 SDS 的程序想要接触 SDS 构件的时候使用, 即使它们使用的是不同的分配器. */</span></span><br><span class="line"><span class="comment">// 在 SDS 的调用者需要释放或申请 SDS 相关的一些东西时可以使用这三个程序.</span></span><br><span class="line"><span class="comment">// 将分配释放的宏封装起来应该是为了在更换 SDS 分配器时不需要更改调用者中的分配器.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s_malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s_realloc(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SDS_TEST_MAIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"testhelp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"limits.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNUSED(x) (void)(x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsTest</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        sds x = sdsnew(<span class="string">"foo"</span>), y;</span><br><span class="line"></span><br><span class="line">        test_cond(<span class="string">"Create a string and obtain the length"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"foo\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnewlen(<span class="string">"foo"</span>,<span class="number">2</span>);</span><br><span class="line">        test_cond(<span class="string">"Create a string with specified length"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">2</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"fo\0"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        x = sdscat(x,<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"Strings concatenation"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">5</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"fobar\0"</span>,<span class="number">6</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        x = sdscpy(x,<span class="string">"a"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscpy() against an originally longer string"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">1</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"a\0"</span>,<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        x = sdscpy(x,<span class="string">"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscpy() against an originally shorter string"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">33</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">memcmp</span>(x,<span class="string">"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0"</span>,<span class="number">33</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdscatprintf(sdsempty(),<span class="string">"%d"</span>,<span class="number">123</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscatprintf() seems working in the base case"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"123\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"--"</span>);</span><br><span class="line">        x = sdscatfmt(x, <span class="string">"Hello %s World %I,%I--"</span>, <span class="string">"Hi!"</span>, LLONG_MIN,LLONG_MAX);</span><br><span class="line">        test_cond(<span class="string">"sdscatfmt() seems working in the base case"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">60</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">memcmp</span>(x,<span class="string">"--Hello Hi! World -9223372036854775808,"</span></span><br><span class="line">                     <span class="string">"9223372036854775807--"</span>,<span class="number">60</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%s]\n"</span>,x);</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"--"</span>);</span><br><span class="line">        x = sdscatfmt(x, <span class="string">"%u,%U--"</span>, UINT_MAX, ULLONG_MAX);</span><br><span class="line">        test_cond(<span class="string">"sdscatfmt() seems working with unsigned numbers"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">35</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">memcmp</span>(x,<span class="string">"--4294967295,18446744073709551615--"</span>,<span class="number">35</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">" x "</span>);</span><br><span class="line">        sdstrim(x,<span class="string">" x"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdstrim() works when all chars match"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">" x "</span>);</span><br><span class="line">        sdstrim(x,<span class="string">" "</span>);</span><br><span class="line">        test_cond(<span class="string">"sdstrim() works when a single char remains"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">1</span> &amp;&amp; x[<span class="number">0</span>] == <span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"xxciaoyyy"</span>);</span><br><span class="line">        sdstrim(x,<span class="string">"xy"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdstrim() correctly trims characters"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">4</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"ciao\0"</span>,<span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">1</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"i\0"</span>,<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,-1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"iao\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">-2</span>,<span class="number">-1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,-2,-1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">2</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"ao\0"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,2,1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">0</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"\0"</span>,<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,100)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"iao\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsdup(x);</span><br><span class="line">        sdsrange(y,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,100,100)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">0</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"\0"</span>,<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"foo"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"foa"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(foo,foa)"</span>, sdscmp(x,y) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(bar,bar)"</span>, sdscmp(x,y) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"aar"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(bar,bar)"</span>, sdscmp(x,y) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnewlen(<span class="string">"\a\n\0foo\r"</span>,<span class="number">7</span>);</span><br><span class="line">        y = sdscatrepr(sdsempty(),x,sdslen(x));</span><br><span class="line">        test_cond(<span class="string">"sdscatrepr(...data...)"</span>,</span><br><span class="line">            <span class="built_in">memcmp</span>(y,<span class="string">"\"\\a\\n\\x00foo\\r\""</span>,<span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> oldfree;</span><br><span class="line">            <span class="keyword">char</span> *p;</span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">10</span>, j, i;</span><br><span class="line"></span><br><span class="line">            sdsfree(x);</span><br><span class="line">            sdsfree(y);</span><br><span class="line">            x = sdsnew(<span class="string">"0"</span>);</span><br><span class="line">            test_cond(<span class="string">"sdsnew() free/len buffers"</span>, sdslen(x) == <span class="number">1</span> &amp;&amp; sdsavail(x) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Run the test a few times in order to hit the first two</span></span><br><span class="line"><span class="comment">             * SDS header types. */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> oldlen = sdslen(x);</span><br><span class="line">                x = sdsMakeRoomFor(x,step);</span><br><span class="line">                <span class="keyword">int</span> type = x[<span class="number">-1</span>]&amp;SDS_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">                test_cond(<span class="string">"sdsMakeRoomFor() len"</span>, sdslen(x) == oldlen);</span><br><span class="line">                <span class="keyword">if</span> (type != SDS_TYPE_5) &#123;</span><br><span class="line">                    test_cond(<span class="string">"sdsMakeRoomFor() free"</span>, sdsavail(x) &gt;= step);</span><br><span class="line">                    oldfree = sdsavail(x);</span><br><span class="line">                &#125;</span><br><span class="line">                p = x+oldlen;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; step; j++) &#123;</span><br><span class="line">                    p[j] = <span class="string">'A'</span>+j;</span><br><span class="line">                &#125;</span><br><span class="line">                sdsIncrLen(x,step);</span><br><span class="line">            &#125;</span><br><span class="line">            test_cond(<span class="string">"sdsMakeRoomFor() content"</span>,</span><br><span class="line">                <span class="built_in">memcmp</span>(<span class="string">"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ"</span>,x,<span class="number">101</span>) == <span class="number">0</span>);</span><br><span class="line">            test_cond(<span class="string">"sdsMakeRoomFor() final length"</span>,sdslen(x)==<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">            sdsfree(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test_report()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_TEST_MAIN</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsTest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文将介绍 &lt;code&gt;SDS&lt;/code&gt; 的实现.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chunqiublog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://chunqiublog.github.io/tags/Redis/"/>
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis 4.0源码解析: SDS(1)</title>
    <link href="http://chunqiublog.github.io/Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_1.html"/>
    <id>http://chunqiublog.github.io/Redis_4_0源码解析_SDS_1.html</id>
    <published>2017-12-14T03:22:26.000Z</published>
    <updated>2018-09-23T16:05:12.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本文将介绍 <code>SDS</code> 的头文件. <code>SDS</code> 的头文件包括两个文件: <code>sds.h</code> 和 <code>sdsalloc.h</code>.<br><a id="more"></a></p><p><code>sds.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SDSLib 2.0, 一个 C 实现的 strings 库 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大预分配给 sds 字符串的空间长度(分配给 sds 字符串的空间最大增长长度)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_MAX_PREALLOC (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类别名, 用于指向 sdshdr 的 buf 属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lsb 最低有效位</span></span><br><span class="line"><span class="comment">/* 注意: sdshdr5 是永远不会被使用的, 它只是被我们用来直接获取 flags 标记字节.</span></span><br><span class="line"><span class="comment"> * 这里是记录 SDS strings类型 5 的布局. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 类型为 3 lsb, string 长度为 5 msb. */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;               <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;             <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;              <span class="comment">/* 被使用 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc;            <span class="comment">/* 不包括头结点和空字节符 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;       <span class="comment">/* 类型为 3 lsb, 5 个没有使用的位 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻蛋, C 实现的多态... 吓尿了... </span></span><br><span class="line"><span class="comment">// 但是感觉在代码中突然冒出一个 sh 会影响程序的可读性.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T, s)  struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T, s)      ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f)  ((f) &gt;&gt; SDS_TYPE_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>, s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 sds 分配给 sds 字符串的空间的长度与保存的字符串长度之差, 即空闲空间</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">        &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 sds 实际保存的字符串长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s) - <span class="number">1</span>;</span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>, s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>, s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>, s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>, s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 sds 实际保存字符串增加的长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, <span class="keyword">size_t</span> inc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> newlen = SDS_TYPE_5_LEN(flags) + inc;</span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); <span class="comment">//=============================感觉没有必要呀</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>, s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>, s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>, s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>, s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sdsalloc() = sdsavail() + sdslen() */</span></span><br><span class="line"><span class="comment">// 获取 sds 分配给 sds 字符串的空间的长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>, s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>, s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>, s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>, s)-&gt;alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分配给 sds 字符串的空间长度</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(<span class="keyword">const</span> sds s, <span class="keyword">size_t</span> newlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; SDS_TYPE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="comment">/* 不需要做什么事, 这个类型没有分配给 sds 字符串的空间信息 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>, s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>, s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>, s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>, s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>; <span class="comment">// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;                    <span class="comment">// 根据给定字符串 init 创建一个包含同样字符串的 sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;                              <span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;                         <span class="comment">// 复制给定 sds 的副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;                             <span class="comment">// 释放 sds. 如果 s 为空, 则不需要干什么</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;              <span class="comment">// 增长字符串, 并将增加的部分置为 0</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 在 sds 字符串后添加长度为 len 的字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;                <span class="comment">// 在 sds 字符串后添加指定以 null 终止的 C 字符串.</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;               <span class="comment">// 在 sds 字符串后添加指定 sds 字符串.</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 拷贝二进制安全字符串 't' 到 sds 字符串中.</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;                <span class="comment">// 对 C 字符串进行拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>; <span class="comment">// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串</span></span><br><span class="line"><span class="comment">// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line">    __attribute__((format(printf, 2, 3)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;                                        <span class="comment">// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>;                                              <span class="comment">// 删除 sds 字符串首尾在 'cset' 中存在的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;                                          <span class="comment">//将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;                                                          <span class="comment">// 更新 sds 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>;                                                              <span class="comment">// 清空 sds 字符串的内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>;                                            <span class="comment">// 比较两个字符串</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>; <span class="comment">// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;                                      <span class="comment">// 释放分割的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>;                                                            <span class="comment">// 将 sds 字符串 's' 中的字母转换为小写字母</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>;                                                            <span class="comment">// 将 sds 字符串 's' 中的字母转换为大写字母</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;                                              <span class="comment">// long long 类型转换为 sds 类型</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;                                  <span class="comment">// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;                                    <span class="comment">// 将字符串按照 REPL 格式切分成一个 sds 参数数组</span></span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span></span>;           <span class="comment">// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>;                                     <span class="comment">// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span></span>;               <span class="comment">// 类似sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 低等级函数作为 API 暴露给用户使用 */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s);</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 SDS 使用的分配器输出给调用 SDS 的程序使用.</span></span><br><span class="line"><span class="comment"> * 有时链接 SDS 的程序可能会设置不同的迭代器, 但是可能想要分配或释放 SDS 分别释放或分配的一些东西. */</span></span><br><span class="line"><span class="comment">// 封装 SDS 分配器给调用者使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsTest</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><code>sdsalloc.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SDSLib 2.0, 一个 C 实现的 strings 库 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SDS 选择分配器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用这个文件是为了在编译时可以改变 SDS 的分配器.</span></span><br><span class="line"><span class="comment"> * 只需要根据你需要使用的分配器定义宏.</span></span><br><span class="line"><span class="comment"> * 也需要根据需要 include(导入) 你用来替换的分配器的库</span></span><br><span class="line"><span class="comment"> * (使用默认分配器不需要). */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_malloc  zmalloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_realloc zrealloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_free    zfree</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文将介绍 &lt;code&gt;SDS&lt;/code&gt; 的头文件. &lt;code&gt;SDS&lt;/code&gt; 的头文件包括两个文件: &lt;code&gt;sds.h&lt;/code&gt; 和 &lt;code&gt;sdsalloc.h&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chunqiublog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://chunqiublog.github.io/tags/Redis/"/>
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis 4.0源码解析</title>
    <link href="http://chunqiublog.github.io/Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://chunqiublog.github.io/Redis_4_0源码解析.html</id>
    <published>2017-12-14T03:21:58.000Z</published>
    <updated>2018-09-23T16:05:14.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.<br><a id="more"></a><br>&emsp;&emsp;以前一直没有阅读过真正大项目的源码, 真正开始阅读才发现Redis的源码对我来说真的是好庞大, 一个文件上千行代码, 利用工作之余阅读, 尽量做到认真阅读每行代码, 大于要花大半个月的时间, 算算时间可能阅读完Redis源码需要花费的时间要超过一年. 回顾以往经历, 对自己能否坚持下来很是担心. 正好这两天我也在看一个大神的博客, 想自己搞个博客, 写点东西. 所以搞个博客记录一下自己的学习. 一方面可以归纳总结自己所学到的东西, 有不对的地方也可以被其他人指正; 另一方面有人阅读我的文章也是对我的一种激励, 避免一个人独自学习因为无聊而放弃.<br>最开始在网上找到了一份关于Redis 2.8 的中文注释源码, 就开始阅读这份源码. 在阅读过程中查资料时发现了 Redis设计与实现 , 感觉这个本书写的挺不错, 而且也附带有一份关于Redis 3.0 的中文注释源码, 同时由于发现了一处Redis源码中的小问题在向Redis提交代码是发现最新的Redis已经到了4.0版本. 于是决定参考2.8和3.0的源码阅读Redis 4.0版本的源码. 由于对redis还没有一个整体的认识, 所以在阅读过程中可能存在一些错误的认识, 欢迎大家指正.</p><blockquote><p><strong>Redis 学习资源</strong></p></blockquote><blockquote><ol><li><a href="https://redis.io" target="_blank" rel="noopener">Redis 官网</a></li><li><a href="http://www.redis.cn" target="_blank" rel="noopener">Redis 中文官方网站</a></li><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Github 上 Redis 源码</a></li><li><a href="https://try.redis.io" target="_blank" rel="noopener">线上 Redis 示范环境</a></li><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis 使用教程</a></li><li><a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="noopener">如何阅读 Redis 源码?</a></li><li><a href="http://redisbook.com" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">Redis 3.0中文注释源码</a></li><li><a href="http://blog.csdn.net/androidlushangderen/article/details/39803337" target="_blank" rel="noopener">Redis 2.8源码解析</a></li><li><a href="https://github.com/linyiqun/Redis-Code" target="_blank" rel="noopener">Reids 2.8中文注释源码</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chunqiublog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://chunqiublog.github.io/tags/Redis/"/>
    
      <category term="源码" scheme="http://chunqiublog.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
