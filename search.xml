<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[etcd gateway]]></title>
    <url>%2F2018-01-02-etcd-gateway.html</url>
    <content type="text"><![CDATA[etcd gateway 是什么?etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持. 什么时候使用 etcd gateway?每个访问 etcd 的应用必须首先拥有 etcd 集群的地址. 如果是同一台服务器上的多个应用访问同一个 etcd 集群, 每个应用仍然需要知道这个 etcd 集群公布的地址. 如果这个 etcd 集群重新配置为拥有不同端点的集群, 则每个应用程序可能还需要更新其端点列表. 这种大规模的重新配置既枯燥又容易出错. etcd gateway 通过作为一个稳定的本地端点提供服务解决了这个问题. 一个典型的 etcd gateway 配置是让每一个机器运行一个监听本地端口的 gateway, 同时每一个 etcd 应用连接到这个本地 gateway. 这样在 etcd 集群重新配置时只有 gateway 需要更新它的端点配置, 而不是更新每一个应用. 总之, 为了自动传播 etcd 集群端点更改, etcd gateway 应该运行在为访问同一个 etcd 集群的多个应用程序提供服务的每台机器上. 什么时候不应该使用 etcd gateway? 提高性能gateway 不是为了提高 etcd 集群性能而设置. 它不提供缓存, watch 的合并或批处理. etcd 团队正在开发一个旨在提高集群可扩展性的缓存代理. 在集群管理系统上运行高级集群管理系统(如 Kubernetes) 本身支持服务发现, 应用程序可以使用有系统管理的 DNS 名称或虚拟 IP 地址访问 etcd 集群. 例如: kube-proxy等同于etcd网关. 启动 etcd gateway考虑一个具有以下静态端点的 etcd 集群:|Name |Address |Hostname ||infra0 |10.0.1.10 |infra0.example.com||infra1 |10.0.1.11 |infra1.example.com||infra2 |10.0.1.12 |infra2.example.com| 使用包含这些静态端点的命令启动etcd gateway:12$ etcd gateway start --endpoints=infra0.example.com,infra1.example.com,infra2.example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 或者, 如果使用 DNS 进行服务发现, 请考虑 DNS SRV 条目:1234$ dig +noall +answer SRV _etcd-client._tcp.example.com_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra0.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra1.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra2.example.com. 1234$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.cominfra0.example.com. 300 IN A 10.0.1.10infra1.example.com. 300 IN A 10.0.1.11infra2.example.com. 300 IN A 10.0.1.12 使用以下命令从 DNS SRV 条目获取端点启动 etcd gateway:12$ etcd gateway --discovery-srv=example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 配置选项etcd 集群–endpoints 逗号分隔的转发客户端连接的目标 etcd 集群列表 默认配置: 127.0.0.1:2379 无效示例: https://127.0.0.1:2379(gateway 不终止 TLS) –discovery-srv 通过 SRV 记录引导集群端点的 DNS 域名 默认配置: (不设置) 网络–listen-addr 接口和端口绑定接收客户端请求 默认: 127.0.0.1:23790 –retry-delay 重试连接到失败的端点之前的延迟时间 默认配置: 1m0s 无效示例: “123”(使用指定格式的时间单位) 安全–insecure-discovery 接收 SRV 记录是不安全或易受到中间人攻击的 默认配置: false –trusted-ca-file 用于 etcd 集群的客户端 TLS CA 文件路径. 用于认证端点. 默认配置: (不设置)]]></content>
      <categories>
        <category>数据库</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(3)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-3.html</url>
    <content type="text"><![CDATA[SDS 结构&emsp;&emsp;SDS 结构如下:12345678910111213141516171819202122232425262728293031323334353637struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;; &emsp;&emsp;其中: len 表示 sds 字符串的长度 alloc 表示 SDS 结构体剩余空间 flags 表示 SDS 结构体类型 buf 表示 sds 字符串&emsp;&emsp;4.0 版本将 3.0 版本时期统一的结构根据 SDS 结构体可以存储字符串的长度划分为不同的 5 种类型, 节省了内存占用的空间, 但是加大字符串操作的复杂度, 在字符串长度变动时需要改变 SDS 结构体类型. SDS 优势 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串时带来的内存重分配次数 二进制安全 兼容部分 C 字符串函数 SDS 内存分配策略 如果直接创建新结点, 会调用 sdsnewlen 函数根据指定字符串的长度创建一个新结点, 新结点没有空闲空间. 如果已有结点需要扩展空间时, 会调用 sdsMakeRoomFor 函数进行扩展.a. 已有结点 sds 字符串空间 &lt; SDS_MAX_PREALLOC, 则对 sds 字符串空间扩展一倍.b. 已有结点 sds 字符串空间 &gt;= SDS_MAX_PREALLOC(1024 * 1024), 则对 sds 字符串空间扩展 SDS_MAX_PREALLOC. SDS 会提供出一组接口使 SDS 的调用者需要释放或分配 SDS 相关的一些东西时可以使用. 同时将分配释放的宏封装起来可以在更换 SDS 分配器时不需要更改调用者中的分配器. SDS 应用 保存数据库中的字符串值. 用作缓冲区(buffer) AOF 模块中的 AOF 缓冲区. 客户端状态中的输入缓冲区. SDS 源码的思考 感觉没有必要使用 SDS_HDR_VAR, 会影响代码的可读性. sdsnewlen 中为什么把 len 和 alloc 设置相同的字符串的长度?len 表示字符串长度, alloc 表示字符串分配的空间, 这时分配空间是按照头结点长度 hdrlen + 字符串长度 initlen + null 终结符 1 进行计算, 分配给字符串的空间即为字符串长度, 所以这时的 len 等于 alloc. sdsnewlen 中为什么 initlen 为 0 时, 类型 5 不擅长?(后续关注对 SDS 的调用) sdsupdatelen 是否已经弃用?(后续关注对 SDS 的调用) sdsRemoveFreeSpace 的注释中 级联 是什么意思?(后续关注对 SDS 的调用) ssdsnew, sdsupdatelen, sdscat, sdscpy 不是二进制安全, sdscatrepr -&gt; sdscatprintf -&gt; sdscatvprintf -&gt; sdscat, sdsjoin -&gt; sdscat, 二级制不安全. 注意 sesdup 调用的 sdslen, 二进制安全的. zfree 的时间复杂度是 O(N)? sdsfree 时间复杂度是 O(N)?(后续关注对 SDS 的调用) sdscatvprintf 对于 buf 的处理为什么是将 -2 的位置置为 ‘\0’?因为在 vsnprintf(buf, buflen, fmt, cpy); 函数中, 无论真正的格式化输出字符串的长度是否超过 buflen, vsnprintf 函数都会将 buf[buflen - 1] 置为 ‘\0’, 所以如果用 -1 位置判断就会出错, 只能用最后一个可以判断的字符即 -2 位置判断. sdsfromlonglong 真的比 sdscatprintf 快吗?sdsfromlonglong 调用 sdsll2str 进行转换, sdscatprintf -&gt; sdscatvprintf -&gt; vsnprintf 函数进行转换, 使用了可变参数. 猜测 vsnprintf 底层转换与 sdsll2str 相似. 在我自己的机器上实测了一下, sdscatprintf 会比 sdsfromlonglong 慢 1us. sdscatrepr 中 ‘\\‘, ‘“‘, 为什么不和其他字符一样使用 sdscatlen?适用 SDS 中自带的测试集进行实测, 是可以实现的. sdssplitargs 如果处理类似 “ test\”aaa\” “ 会将参数识别为 test\”aaa\” 不影响吗?(后续关注对 SDS 的调用) 本文部分内容参考《Redis 设计与实现》一书.]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(2)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-2.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的实现. sds.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785/* SDSLib 2.0, 一个 C 实现的 strings 库 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;#include "sds.h"#include "sdsalloc.h"// 获取不同类型 sds 结构体大小// T = O(1)static inline int sdsHdrSize(char type)&#123; switch(type &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return sizeof(struct sdshdr5); case SDS_TYPE_8: return sizeof(struct sdshdr8); case SDS_TYPE_16: return sizeof(struct sdshdr16); case SDS_TYPE_32: return sizeof(struct sdshdr32); case SDS_TYPE_64: return sizeof(struct sdshdr64); &#125; return 0;&#125;// 根据 string 长度确定存储的 sds 类型// T = O(1)static inline char sdsReqType(size_t string_size)&#123; if(string_size &lt; 1 &lt;&lt; 5) // 最大 31 &#123; return SDS_TYPE_5; &#125; if(string_size &lt; 1 &lt;&lt; 8) // 最大 255 &#123; return SDS_TYPE_8; &#125; if(string_size &lt; 1 &lt;&lt; 16) // 最大 65535 &#123; return SDS_TYPE_16; &#125;#if(LONG_MAX == LLONG_MAX) if(string_size &lt; 1ll &lt;&lt; 32) //最大 2 ^ 32 - 1 &#123; return SDS_TYPE_32; &#125;#endif return SDS_TYPE_64; //最大 2 ^ 64 - 1&#125;// 二进制安全: 只会严格的按照二进制的数据存取. 不会妄图已某种特殊格式解析数据./* 使用 'init' 指针和 'initlen' 指定的内容创建一个新的 sds string. * 如果 'init' 是 NULL, 那么 string 将被初始化为 0 字节. * * 字符串始终为空终止(\0)(所有的 sds 字符串都是, 都总是) * 因此即使你创建一个这样的 sds 字符串: * * mystring = sdsnewlen("abc", 3); * * 你可以使用 printf() 打印字符串, 因为字符串的末尾有一个隐含的 \0. * 同时因为字符串长度保存在 sds 头结点中, 字符串是二进制安全的, \0也可以被包含在 sds 字符串中. * 也就是说 当 mystring = sdsnewlen("abc", 4); 时, \0 也是 sds 字符串中的一部分, 是二进制安全. */// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化// T = O(N)sds sdsnewlen(const void *init, size_t initlen)&#123; void *sh; sds s; // 通过长度获取存储字符串的 SDS 类型 char type = sdsReqType(initlen); /* 为了添加字符串, 空字符串经常被创建. * 使用类型 8, 因为类型 5 在这里不适用. */ if(type == SDS_TYPE_5 &amp;&amp; initlen == 0) &#123; type = SDS_TYPE_8; &#125; // 通过 SDS 类型获取 SDS 头结点大小 int hdrlen = sdsHdrSize(type); unsigned char *fp; /* 标记指针 */ sh = s_malloc(hdrlen + initlen + 1); if(!init) &#123; memset(sh, 0, hdrlen + initlen + 1); &#125; if(sh == NULL) &#123; return NULL; &#125; s = (char *)sh + hdrlen; fp = ((unsigned char *)s) - 1; // 初始化 SDS 头结点 switch(type) &#123; case SDS_TYPE_5: &#123; *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS); break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; &#125; // 如果指定初始化内容, 将它们复制到 sdshdr 的 buf 中 // T = O(N) if(initlen &amp;&amp; init) &#123; memcpy(s, init, initlen); &#125; // 字符串以 \0 结尾 s[initlen] = '\0'; // 返回 buf 部分, 而不是整个 sdshdr return s;&#125;/* 创建一个空(长度为 0) sds 字符串. * 在这种情况下字符串总是含有一个 null(\0) 终结符. */// 创建并返回一个只保存了空字符串 "" 的 sds// T = O(1)sds sdsempty(void)&#123; return sdsnewlen("", 0);&#125;/* 根据一个空终止(\0)的 C 字符串开始创建一个新的 sds 字符串. */// 也只适合 C 字符串// 根据给定字符串 init 创建一个包含同样字符串的 sds// T = O(N)sds sdsnew(const char *init)&#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;/* 复制一个 sds 字符串 */// 复制给定 sds 的副本// T = O(N)sds sdsdup(const sds s)&#123; return sdsnewlen(s, sdslen(s));&#125;/* 释放 sds. 如果 s 为空, 则不需要干什么 */// T = O(N)void sdsfree(sds s)&#123; if(s == NULL) &#123; return ; &#125; s_free((char *)s - sdsHdrSize(s[-1]));&#125;/* 设置 sds 字符串长度为通过 strlen() 获取的长度, * 因此要考虑到内容只能到达第一个 null(\0) 字符. * * 当 sds 字符串被黑客以某种手动方式入侵时, 这个函数是很有用的, * 如下例所示: * * s = sdsnew("foobar"); * s[2] = '\0'; * sdsupdatelen(s); * printf("%d\n", sdslen(s)); * * 输出将会是 2, 如果我们注释调用 sdsupdatelen() 的部分, * 输出将会是 6, 因为字符串被修改, 但是逻辑长度依然是 6. */// 更新 sds 的长度// T = O(1)void sdsupdatelen(sds s)&#123; int reallen = strlen(s); sdssetlen(s, reallen);&#125;/* 修改一个字符串, 使它立刻变成空(长度为 0). * 但是所有现有的缓冲区不会被丢弃, 而是设置为可用空间, * 以便下一次增加操作不需要预先分配可用的字节数. */// 清空 sds 字符串的内容// T = O(1)void sdsclear(sds s)&#123; sdssetlen(s, 0); s[0] = '\0';&#125;/* 在 sds 字符串的尾部扩增可用空间, 以便确保该函数的调用者在调用该函数后可以 sds 字符串末尾写入 addlen 个字节. * 再在末尾加上一个 null 终结符. * * 注意: 注意这个函数不会改变 sdslen() 返回的 sds 字符串的 *length*, * 只能改变我们拥有的可用缓冲区空间. */// 当 sds 字符串空间充足时, 直接返回, 空间不足时, 重新分配空间, 设置 sds 头结点, 字符串内容// T = O(N)sds sdsMakeRoomFor(sds s, size_t addlen)&#123; void *sh; void *newsh; // 获取当前空闲空间大小 size_t avail = sdsavail(s); size_t len; size_t newlen; char type; // 获取当前 sds 的类型 char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; /* 如果空间足够, 立刻返回 */ if(avail &gt;= addlen) &#123; return s; &#125; len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); newlen = (len + addlen); // 如果需要新分配给 sds 字符串的空间的长度小于 sds 最大预分配给 sds 字符串的空间长度 if(newlen &lt; SDS_MAX_PREALLOC) &#123; newlen *= 2; &#125; else &#123; // 如果需要新分配给 sds 字符串的空间的长度大于最大预分配给 sds 字符串的空间长度时, 每次增长最大预分配给 sds 字符串的空间长度 newlen += SDS_MAX_PREALLOC; &#125; // 根据需要新分配给 sds 字符串的空间的长度计算新的 sds 需要的类型 type = sdsReqType(newlen); /* 不要使用类型 5: 当用户扩增字符串时, 由于类型 5 不能记住空闲空间, * 因此调用 sdsMakeRoomFor() 时必须进行扩增操作 */ if(type == SDS_TYPE_5) &#123; type = SDS_TYPE_8; &#125; hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; // 如果新类型与原来的类型相同, 重新分配新长度的 sds 并将原来 sds 字符串(包括头结点和 null 终结符)拷贝到新空间. newsh = s_realloc(sh, hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; /* 由于头结点大小改变, 需要将字符串向前移动, 不能直接使用 realloc */ // 如果新类型与原来的类型不同, 重新分配新类型新长度的 sds newsh = s_malloc(hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; // 将原来的 sds 字符串拷贝到新 sds 中 memcpy((char *)newsh + hdrlen, s, len + 1); // 释放原来的 sds s_free(sh); s = (char *)newsh + hdrlen; // 设置新 sds 类型, 长度 s[-1] = type; sdssetlen(s, len); &#125; // 更新分配空间大小 sdssetalloc(s, newlen); return s;&#125;/* 为了使 sds 字符串结尾没有可用空间, 对其重新分配空间. * 剩下的 sds 字符串没有改变, 但是下一个级联操作将需要重新分配空间. * * 在被调用后, 通过这个函数的 sds 字符串不能变的更长, 所有的指针必须被调用返回的新指针替换 */// 将 sds 字符串的空间缩短到字符串自身的长度.// T = O(N)sds sdsRemoveFreeSpace(sds s)&#123; void *sh; void *newsh; char type; char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; size_t len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); type = sdsReqType(len); hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; newsh = s_realloc(sh, hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; newsh = s_malloc(hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; memcpy((char *)newsh + hdrlen, s, len + 1); s_free(sh); s = (char *)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); &#125; sdssetalloc(s, len); return s;&#125;/* 返回指定 sds 字符串分配总空间的大小 * 包括: * 1) 指针前的 sds 头结点. * 2) 字符串. * 3) 结尾若干可用缓冲区. * 4) 隐含的 null 终结符. */// 获取分配给 sds 的总空间// T = O(1)size_t sdsAllocSize(sds s)&#123; size_t alloc = sdsalloc(s); return sdsHdrSize(s[-1]) + alloc + 1;&#125;/* 返回 sds 真实的分配总空间(通常, sds 字符串作为字符串缓冲区开始的参考) */// 获取 sds 总空间的指针// T = O(1)void *sdsAllocPtr(sds s)&#123; return (void *)(s = sdsHdrSize(s[-1]));&#125;/* 根据 'incr' 增加 sds 字符串长度, 并减小字符串左侧可用空间. * 同时在新的字符串结尾设置 null 终结符. * * 使用这个函数是为了在用户调用 sdsMakeRoomFor() 函数后, 在当前字符串的结尾写入一些东西, * 最后需要设置字符串新长度是修改字符串的长度. * * 注意: 可以使用负增量来从右侧缩减字符串. * * 用法示例: * * 使用以下模式调用 sdsIncrLen() 和 sdsMakeRoomFor(), 可以将字符串直接从内核挂载连接到 * sds 字符串末尾, 不需要复制到中间缓冲区. * * oldlen = sdslen(s); * s = sdsMakeRoomFor(s, BUFFER_SIZE); * nread = read(fd, s + oldlen, BUFFER_SIZE); * ... 检查 nread &lt;= 0 并处理它 ... * sdsIncrLen(s, nread); */// 修改 sds 字符串长度// T = O(1)void sdsIncrLen(sds s, int incr)&#123; unsigned char flags = s[-1]; size_t len; // 修改 sds 字符串长度 switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char oldlen = SDS_TYPE_5_LEN(flags); assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr))); *fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS); len = oldlen + incr; break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; default: len = 0; /* 只是为了避免编译警告 */ &#125; s[len] = '\0';&#125;/* 将 sds 字符串的长度增长到指定长度. 增长的长度初始化为 0. * * 如果指定的长度比当前 sds 字符串的短, 则不执行任何操作. */// 增长字符串, 并将增加的部分置为 0// T = O(N)sds sdsgrowzero(sds s, size_t len)&#123; size_t curlen = sdslen(s); if(len &lt;= curlen) &#123; return s; &#125; // 扩增 sds 字符串分配的空间 s = sdsMakeRoomFor(s, len - curlen); if(s == NULL) &#123; return NULL; &#125; /* 确保添加的区域不包含垃圾 */ // 将添加区域初始化为 0 memset(s + curlen, 0, (len - curlen + 1)); sdssetlen(s, len); return s;&#125;/* 在 sds 字符串 's' 后添加二进制安全的 len 个字节的 't' 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加长度为 len 的字符串// T = O(N)sds sdscatlen(sds s, const void *t, size_t len)&#123; size_t curlen = sdslen(s); // 空间足够直接返回, 空间不足获取空间 s = sdsMakeRoomFor(s, len); if(s == NULL) &#123; return NULL; &#125; memcpy(s + curlen, t, len); sdssetlen(s, curlen + len); s[curlen + len] = '\0'; return s;&#125;/* 在 sds 字符串后添加指定以 null 终止的 C 字符串. * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定以 null 终止的 C 字符串.// T = O(N)sds sdscat(sds s, const char *t)&#123; return sdscatlen(s, t, strlen(t));&#125;/* 在现有 sds 字符串后添加指定 sds 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定 sds 字符串.// T = O(N)sds sdscatsds(sds s, const sds t)&#123; return sdscatlen(s, t, sdslen(t));&#125;/* 破坏性的修改 sds 字符串来保存指定的长度为 'len' 字节的二进制安全的字符串 't'. */// 拷贝二进制安全字符串 't' 到 sds 字符串中.// T = O(N)sds sdscpylen(sds s, const char *t, size_t len)&#123; // 查看字符串空间是否足够 if(sdsalloc(s) &lt; len) &#123; s = sdsMakeRoomFor(s, len - sdslen(s)); if(s == NULL) &#123; return NULL; &#125; &#125; memcpy(s, t, len); s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 类似 sdscpylen() 但是 't' 必须是一个以 null 终结的字符串, 以便通过 strlen() 获取字符串长度. */// 对 C 字符串进行拷贝// T = O(N)sds sdscpy(sds s, const char *t)&#123; return sdscpylen(s, t, strlen(t));&#125;/* 帮助 sdscatlonglong() 进行实际的数字 -&gt; 字符串的转换. * 's' 必须指向一个最少 SDS_LLSTR_SIZE 字节的字符串空间. * * 这个函数返回存储在 's' 中的以 null 终结的字符串表示的长度 */// long long 类型转换为 string 类型// T = O(N)#define SDS_LLSTR_SIZE 21int sdsll2str(char *s, long long value)&#123; char *p; char aux; unsigned long long v; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ // 将 long long 反转存储在字符串中 v = (value &lt; 0) ? -value : value; p = s; // T = O(N) do &#123; // 只能适用于 C 语言字符集 *p++ = '0' + (v % 10); v /= 10; &#125;while(v); if(value &lt; 0) &#123; *p++ = '-'; &#125; /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ // 将反转的字符串反转就是 long long 的顺序字符串表示 // T = O(N) p --; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 与 sdsll2str() 相同, 但是这个函数是针对 unsigned long long 类型. */// unsigned long long 类型转换为 string 类型// T = O(N)int sdsull2str(char *s, unsigned long long v)&#123; char *p; char aux; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ p = s; do &#123; *p++ = '0' + (v % 10); v /= 10; &#125;while(v); /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 根据一个 long long 值创建一个 sds 字符串. 这要比以下方式快很多: * * sdscatprintf(sdsempty(), "%lld\n", value); */// long long 类型转换为 sds 类型// T = O(N)sds sdsfromlonglong(long long value)&#123; char buf[SDS_LLSTR_SIZE]; int len = sdsll2str(buf, value); return sdsnewlen(buf, len);&#125;/* 类似 sdscatprintf() 但是获取的是 va_list 而不是可变参数 */// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// T = O(N)sds sdscatvprintf(sds s, const char *fmt, va_list ap)&#123; va_list cpy; char staticbuf[1024]; char *buf = staticbuf; char *t; size_t buflen = strlen(fmt) * 2; /* 我们尝试开始使用静态缓冲区来提升速度. * 如果不可能, 我们回到使用堆分配. */ if(buflen &gt; sizeof(staticbuf)) &#123; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; &#125; else &#123; buflen = sizeof(staticbuf); &#125; /* 每次当我们使用当前缓冲区大小无法适应字符串时, 尝试使用缓冲区的两倍大小. */ while(1) &#123; buf[buflen - 2] = '\0'; va_copy(cpy, ap); vsnprintf(buf, buflen, fmt, cpy); va_end(cpy); if(buf[buflen - 2] != '\0') &#123; // 缓冲区大小无法适应字符串. if(buf != staticbuf) &#123; // 在堆上分配的空间, 释放 s_free(buf); &#125; // 重新分配两倍大小的空间 buflen *= 2; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; continue; &#125; // 直到适应字符串 break; &#125; /* 最后将获得的字符串添加到 sds 字符串并返回它. */ // 将字符串添加到 sds 字符串后 t = sdscat(s, buf); if(buf != staticbuf) &#123; s_free(buf); &#125; return t;&#125;/* 将使用类似 printf 指定格式获得的字符串添加到 sds 字符串. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("Sum is: "); * s = sdscatprintf(s, "%d+%d = %d", a, b, a + b); * * 通常, 你需要使用类似 printf 格式从头创建一个字符串. * 当你需要时, 只需要使用 sdsempty() 作为字符串: * * s = sdscatprintf(sdsempty(), "... your format ...", args); */// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串// T = O(N)sds sdscatprintf(sds s, const char *fmt, ...)&#123; va_list ap; char *t; va_start(ap, fmt); t = sdscatvprintf(s, fmt, ap); va_end(ap); return t;&#125;/* 这个函数类似 sdscatprintf, 但是要快很多, 它没有依靠 libc 中通常很慢的 sprintf() 系列函数. * 此外, 将 sds 字符串作为被连接新数据直接处理提供了性能改进. * * 然而, 这个函数只处理类似 printf 的格式说明符的不兼容子集. * * %s - C 字符串 * %S - SDS 字符串 * %i - 有符号整形 * %I - 64 位有符号整形(long long, int64_t) * %u - 无符号整形 * %U - 64 位无符号整形(unsigned long long, uint64_t) * %% - % 字符 */// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串// T = O(N)sds sdscatfmt(sds s, char const *fmt, ...)&#123; size_t initlen = sdslen(s); const char *f = fmt; int i; va_list ap; // 开始遍历参数 va_start(ap, fmt); f = fmt; /* 遍历格式化输出字符串中格式说明符下一个要处理的字节. */ i = initlen; /* 写入目标字符串下一个字节的位置. */ // 遍历格式化输出字符串 while(*f) &#123; char next, *str; size_t l; long long num; unsigned long long unum; /* 确保至少有一个字节的空间 */ // 确保当该字符不是说明符时有可以存储的 1 字节空间 if(sdsavail(s) == 0) &#123; s = sdsMakeRoomFor(s, 1); &#125; // 处理有可能为说明符的情况, 即 *f 为 %. switch(*f) &#123; case '%': next = *(f + 1); f++; switch(next) &#123; case 's': case 'S': str = va_arg(ap, char *); l = (next == 's') ? strlen(str) : sdslen(str); // 空间不足时扩容 if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; // 将字符串添加到 sds 字符串后 memcpy(s + i, str, l); sdsinclen(s, l); i += l; break; case 'i': case 'I': if(next == 'i') &#123; num = va_arg(ap, int); &#125; else &#123; num = va_arg(ap, long long); &#125; // 将 long long 转换为字符串 char buf[SDS_LLSTR_SIZE]; l = sdsll2str(buf, num); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; case 'u': case 'U': if(next == 'u') &#123; unum = va_arg(ap, unsigned int); &#125; else &#123; unum = va_arg(ap, unsigned long long); &#125; char buf[SDS_LLSTR_SIZE]; l = sdsull2str(buf, unum); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; default: /* 处理 %%, 通常为 %&lt;unknown&gt;. */ s[i++] = next; sdsinclen(s, 1); break; &#125; break; // 处理不是 % 开头的可能为说明符的情况 default: s[i++] = *f; sdsinclen(s, 1); break; &#125; f++; &#125; va_end(ap); /* 添加 null 终结符 */ s[i] = '\0'; return s;&#125;/* 从字符串左边和右边分别删除 sds 字符串的一部分, 删除的字符串为在 'cset' 中找到的字符组成的连续字符, * 'cset' 字符串是一个 null 终结的 C 字符串. * * 在调用这个函数后, 被修改 sds 字符串不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("AA...AA.a.aa.aHellWorld :::"); * s = sdstrim(s, "Aa. :"); * printf("%s\n", s); * * 只输出 "Hello World" */// 删除 sds 字符串首尾在 'cset' 中存在的字符串// T = O(M*N)，M 为 SDS 长度, N 为 cset 长度sds sdstrim(sds s, const char *cset)&#123; char *start; char *end; char *sp; char *ep; size_t len; sp = start = s; ep = end = s + sdslen(s) - 1; // 从头向尾遍历 // T = O(M * N) while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) &#123; sp++; &#125; // 从尾向头遍历 while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) &#123; ep--; &#125; len = (sp &gt; ep) ? 0 : ((ep - sp) + 1); // 移动剩余部分 if(s != sp) &#123; memmove(s, sp, len); &#125; s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串. * * start 和 end 可以是负数, 其中 -1 表示字符串的最后一个字符, -2 表示倒数第二个字符, 等等. * * 间隔是包含的, 因此开始和结束字符是生成字符串的一部分. * * 字符串就地被修改. * * 例如: * * s = sdsnew("Hello World"); * sdsrange(s, 1, -1); // =&gt; "ello World" */// 将 sds 字符串缩短为 'start' 到 'end' 之间, 闭区间// T = O(N)void sdsrange(sds s, int start, int end)&#123; size_t newlen; size_t len = sdslen(s); if(len == 0) &#123; return ; &#125; // 如果指定 'start' 是负数 if(start &lt; 0) &#123; start = len + start; if(start &lt; 0) &#123; // 赋值负数超出字符串范围的 start 为 0 start = 0; &#125; &#125; if(end &lt; 0) &#123; end = len + end; if(end &lt; 0) &#123; end = 0; &#125; &#125; // 计算 start 和 end 指定子串的长度, 包含 start 和 end newlen = (start &gt; end) ? 0 : (end - start) + 1; if(newlen != 0) &#123; if(start &gt;= (signed)len) &#123; newlen = 0; &#125; else if(end &gt;= (signed)len) &#123; end = len - 1; newlen = (start &gt; end) ? 0 : (end - start) + 1; &#125; &#125; else &#123; // 这里 newlen = 0, 一定进入下一个 if start = 0; &#125; // 清楚 start 前的字符 if(start &amp;&amp; newlen) &#123; memmove(s, s + start, newlen); &#125; // newlen 为 0 时, 清空字符串. // 即为 s[newlen] = '\0'; s[newlen] = 0; sdssetlen(s, newlen);&#125;/* 对 sds 字符串 's' 的每一个字符调用 tolower() */// 将 sds 字符串 's' 中的字母转换为小写字母// T = O(N)void sdstolower(sds s)&#123; int len = sdslen(s); int j; // 转换每一个字符 for(j = 0; j &lt; len; j++) &#123; s[j] = tolower(s[j]); &#125;&#125;/* 对 sds 字符串 's' 的每一个字符调用 sdstoupper() */// 将 sds 字符串 's' 中的字母转换为大写字母// T = O(N)void sdstoupper(sds s)&#123; int len = sdslen(s); int j; for(j = 0; j &lt; len; j++) &#123; s[j] = toupper(s[j]); &#125;&#125;/* 使用 memcmp() 比较两个 sds 字符串 s1 和 s2. * * 返回值: * * 如果 s1 &gt; s2, 返回正数. * 如果 s1 &lt; s2, 返回负数. * 如果s1和s2是完全相同的二进制字符, 则为0. * * 如果两个字符串共享完全相同的前缀, 但是其中的一个长度更长, 则较长的字符串被认为大于较小的字符串. */// 比较两个字符串// T = O(N)int sdscmp(const sds s1, const sds s2)&#123; size_t l1; size_t l2; size_t minlen; int cmp; l1 = sdslen(s1); l2 = sdslen(s2); // 获取最小长度 minlen = (l1 &lt; l2) ? l1 : l2; // 比较最小长度空间中的字符 cmp = memcmp(s1, s2, minlen); if(cmp == 0) &#123; // 最小长度空间中字符相同, 返回长度的差值, 为 0 则两个字符串相同 return l1 - l2; &#125; // 返回最小长度空间中不同字符的差 return cmp;&#125;/* 使用分隔符 'sep' 分割 's'. 返回 sds 字符串数组. * *count 将会被指针设置为 sds 的数量. * * 内存溢出, 空字符串, 空分隔符将会返回 NULL. * * 注意: 'sep' 可以是一个由多个字符组成的分隔符. 例如: * sdssplit("foo_-_bar", "_-_"); * 将返回 "foo" 和 "bar" 两个元素. * * 这个函数的版本是二级制安全的, 但是需要参数长度. * sdssplit() 是只针对 NULL 终结的字符串的相同函数. */// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾// T = O(N ^ 2)sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count)&#123; int elements = 0; int slots = 5; int start = 0; int j; sds *tokens; if(seplen &lt; 1 || len &lt; 0) &#123; return NULL; &#125; tokens = s_malloc(sizeof(sds) * slots); if(tokens == NULL) &#123; return NULL; &#125; if(len == 0) &#123; *count = 0; return tokens; &#125; // 遍历字符串 // T = O(N ^ 2) for(j = 0; j &lt; (len - (seplen - 1)), j++) &#123; /* 确保下一个元素和最后一个元素有空间 */ if(slots &lt; elements + 2) &#123; sds *newtokens; slots *= 2; newtokens = s_realloc(tokens, sizeof(sds) * slots); if(newtokens == NULL) &#123; goto cleanup; &#125; tokens = newtokens; &#125; /* 搜索分隔符 */ // T = O(N) if((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) &#123; // 找到分隔符 tokens[elements] = sdsnewlen(s + start, j - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; start = j + seplen; // 麻蛋, -1 是因为 for 循环自己加了 1 j = j + seplen - 1; /* 跳过分隔符 */ &#125; &#125; /* 添加最后一个元素. 我们确定在标记数组中存在空间. */ tokens[elements] = sdsnewlen(s + start, len - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; *count = elements; return tokens; // 错误处理 cleanup: &#123; int i; // 清理空间 for(i = 0; i &lt; elements; i++) &#123; sdsfree(tokens[i]); &#125; s_free(tokens); *count = 0; return NULL; &#125;&#125;/* 释放 sdssplitlen() 返回的结果, 或者当 'tokens' 为 NULL 时什么都不做. */// 释放分割的结果// T = O(N)void sdsfreesplitres(sds *tokens, int count)&#123; if(!tokens) &#123; return ; &#125; while(count--) &#123; sdsfree(tokens[count]); &#125; s_free(tokens);&#125;/* 为 sds 字符串 's' 添加将所有无法打印的字符(使用 isprint() 测试) * 变成 "\n\r\a..." 或 "\x&lt;hex-number&gt;" 转移的形式组成的转义字符串的表示. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. */// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.// T = O(N)sds sdscatrepr(sds s, const char *p, size_t len)&#123; s = sdscatlen(s, "\"", 1); while(len--) &#123; switch(*p) &#123; case '\\': case '"': s = sdscatprintf(s, "\\%c", *p); break; // case '\\': s = sdscatlen(s, "\\\\", 2); break; // case '"': s = sdscatlen(s, "\\\"", 2); break; case '\n': s = sdscatlen(s, "\\n", 2); break; case '\r': s = sdscatlen(s, "\\r", 2); break; case '\t': s = sdscatlen(s, "\\t", 2); break; case '\a': s = sdscatlen(s, "\\a", 2); break; case '\b': s = sdscatlen(s, "\\b", 2); break; default: if(isprint(*p)) &#123; s = sdscatprintf(s, "%c", *p); &#125; else &#123; s = sdscatprintf(s, "\\x%02x", (unsigned char) *p); &#125; break; &#125; p++; &#125; return sdscatlen(s, "\"", 1);&#125;/* sdssplitargs() 的辅助函数, 如果 'c' 是有效的十六进制, 则返回非零. */// 测试字符是否为十六进制字符// T = O(1)int is_hex_digit(char c)&#123; return (c &gt;= '0' &amp;&amp; c &lt;='9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F');&#125;/* sdssplitargs() 的辅助函数, 将十六进制数转换为从 0 到 15 的整数. */// 将十六进制转换为从 0 到 15 的整数.// T = O(1)int hex_digit_to_int(char c)&#123; switch(c) &#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; default: return 0; &#125;&#125;/* 把一行文本切割成多个参数, 每个参数可以有以下的类编程语言 REPL 格式: * * foo bar "newline are suported\n" and "\xff\x00otherstuff" * * 参数的数量存储在 *argc 中, 这个函数会返回一个 sds 数组. * * 调用者应该调用 sdsfreesplitres() 函数释放生成的 sds 数组. * * 注意: sdscatrepr() 可以将一个字符串转换为一个带引号的字符串, * 相同格式的字符串可以被 sdssplitargs() 函数解析. * * 即使当输入出现空字符串, 函数仍然会将成功处理的字符串返回. * 或当输入不对应的引号或后引号后面没有跟空格例如: "foo"bar 或 "foo' 时返回 NULL. */// * 这个函数主要用于 config.c 中对配置文件进行分析, 将字符串按照 REPL 格式切分成一个 sds 参数数组.// * // * 例如:// * sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");// * 会得出:// * arr[0] = "timeout"// * arr[1] = "10086"// * arr[2] = "port"// * arr[3] = "123321"// * T = O(N)sds *sdssplitargs(const char *line, int *argc)&#123; const char *p = line; char *current = NULL; char **vector = NULL; *argc = 0; while(1) &#123; // 遇到空格跳过 // T = O(N) while(*p &amp;&amp; isspace(*p)) &#123; p++; &#125; if(*p) &#123; /* 获取一个标记 */ int inq = 0; /* 如果遇到引号设置为 1 */ int insq = 0; /* 如果遇到单引号设置为 1 */ // 当前参数结束了设置为 1 int done = 0; // 获取一个 sds 存储参数 if(current == NULL) &#123; current = sdsempty(); &#125; // T = O(N) while(!done) &#123; if(inq) &#123; // 前面遍历过前引号 if(*p == '\\' &amp;&amp; *(p + 1) == 'x' &amp;&amp; is_hex_digit(*(p + 2)) &amp;&amp; is_hex_digit(*(p + 3))) &#123; // 遇到十六进制表示, 转换为字符 unsigned char byte; byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3)); current = sdscatlen(current, (char *)&amp;byte, 1); p += 3; &#125; else if(*p == '\\' &amp;&amp; *(p + 1)) &#123; // 遇到转义字符, 转换为对应的字符 char c; p++; switch(*p) &#123; case 'n': c = '\n'; break; case 'r': c = '\r'; break; case 't': c = '\t'; break; case 'b': c = '\b'; break; case 'a': c = '\a'; break; default: c = *p; break; &#125; current = sdscatlen(current, &amp;c, 1); &#125; else if(*p == '"') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; // 不是执行错误处理代码 goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ // 没有后引号就结束 goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else if(insq) &#123; // 前面遍历过前单引号 if(*p == '\\' &amp;&amp; *(p + 1) == '\'') &#123; // 遇到转义的单引号 p++; current = sdscatlen(current, "'", 1); &#125; else if(*p == '\'') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后单引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else &#123; // 不在引号内的字符 switch(*p) &#123; // 分隔参数的符号 case ' ': case '\n': case '\r': case '\t': case '\0': done = 1; break; // 前引号 case '"': inq = 1; break; // 后引号 case '\'': insq = 1; break; // 普通字符 default: current = sdscatlen(current, p, 1); break; &#125; &#125; // 指针向后移动 if(*p) &#123; p++; &#125; &#125; /* 在 vector 中添加标记 */ // 将参数添加到参数数组 vector 中 // T = O(N) vector = s_realloc(vector, ((*argc) + 1) * sizeof(char *)); vector[*argc] = current; (*argc)++; current = NULL; &#125; else &#123; /* 即使是空字符串仍然返回一些内容, 不会返回 NULL */ // 字符串遍历结束 if(vector == NULL) &#123; vector = s_malloc(sizeof(void *)); &#125; return vector; &#125; &#125; err: &#123; // 出错时, 清理内存空间, 返回 NULL while((*argc)--) &#123; sdsfree(vector[*argc]); &#125; s_free(vector); if(current) &#123; sdsfree(current); &#125; *argc = 0; return NULL; &#125;&#125;/* 将 sds 字符串中所有 'from' 字符串中指定的字符集出现的字符替换为 'to' 数组中相应位置的字符. * * 例如: * sdsmapchars(mystring, "ho", "01", 2); * 将具有将字符串 "hello" 转换为 "0ell1" 的效果. * * 这个函数返回 sds 字符串指针, 它总是与输入指针大小相同, 因此不需要调整大小. */// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符// T = O(M * N) M 为 setlen 的长度, N 为 s 的长度sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen)&#123; size_t j; size_t i; size_t l = sdslen(s); for(j = 0; j &lt; l; j++) &#123; for(i = 0; i &lt; setlen; i++) &#123; if(s[j] == from[i]) &#123; s[j] = to[i]; break; &#125; &#125; &#125; return s;&#125;/* 使用指定分隔符(C 字符串)将一个 C 字符串数组组合成一个 sds 字符串. * 以 sds 字符串形式返回结果 */// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全// T = O(N)sds sdsjoin(char **argv, int argc, char *sep)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscat(join, argv[j]); if(j != argc - 1) &#123; join = sdscat(join, sep); &#125; &#125; return join;&#125;/* 类似 sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串. */// T = O(N)sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscatsds(join, argv[j]); if(j != argc - 1) &#123; join = sdscatlen(join, sep, seplen); &#125; &#125; return join;&#125;/* 低等级函数作为 API 暴露给用户使用 *//* 封装被 SDS 使用的分配器. * 注意: 为了避免函数调用过程的付出开销, SDS 实际上只使用 sdsalloc.h 中定义的宏. * 这里, 我们定义这些封装只有在当链接 SDS 的程序想要接触 SDS 构件的时候使用, 即使它们使用的是不同的分配器. */// 在 SDS 的调用者需要释放或申请 SDS 相关的一些东西时可以使用这三个程序.// 将分配释放的宏封装起来应该是为了在更换 SDS 分配器时不需要更改调用者中的分配器.void *sds_malloc(size_t size)&#123; return s_malloc(size);&#125;void *sds_realloc(void *ptr, size_t size)&#123; return s_realloc(ptr, size);&#125;void sds_free(void *ptr)&#123; s_free(ptr);&#125;// 测试代码#if defined(SDS_TEST_MAIN)#include &lt;stdio.h&gt;#include "testhelp.h"#include "limits.h"#define UNUSED(x) (void)(x)int sdsTest(void) &#123; &#123; sds x = sdsnew("foo"), y; test_cond("Create a string and obtain the length", sdslen(x) == 3 &amp;&amp; memcmp(x,"foo\0",4) == 0) sdsfree(x); x = sdsnewlen("foo",2); test_cond("Create a string with specified length", sdslen(x) == 2 &amp;&amp; memcmp(x,"fo\0",3) == 0) x = sdscat(x,"bar"); test_cond("Strings concatenation", sdslen(x) == 5 &amp;&amp; memcmp(x,"fobar\0",6) == 0); x = sdscpy(x,"a"); test_cond("sdscpy() against an originally longer string", sdslen(x) == 1 &amp;&amp; memcmp(x,"a\0",2) == 0) x = sdscpy(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"); test_cond("sdscpy() against an originally shorter string", sdslen(x) == 33 &amp;&amp; memcmp(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0",33) == 0) sdsfree(x); x = sdscatprintf(sdsempty(),"%d",123); test_cond("sdscatprintf() seems working in the base case", sdslen(x) == 3 &amp;&amp; memcmp(x,"123\0",4) == 0) sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX); test_cond("sdscatfmt() seems working in the base case", sdslen(x) == 60 &amp;&amp; memcmp(x,"--Hello Hi! World -9223372036854775808," "9223372036854775807--",60) == 0) printf("[%s]\n",x); sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX); test_cond("sdscatfmt() seems working with unsigned numbers", sdslen(x) == 35 &amp;&amp; memcmp(x,"--4294967295,18446744073709551615--",35) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," x"); test_cond("sdstrim() works when all chars match", sdslen(x) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," "); test_cond("sdstrim() works when a single char remains", sdslen(x) == 1 &amp;&amp; x[0] == 'x') sdsfree(x); x = sdsnew("xxciaoyyy"); sdstrim(x,"xy"); test_cond("sdstrim() correctly trims characters", sdslen(x) == 4 &amp;&amp; memcmp(x,"ciao\0",5) == 0) y = sdsdup(x); sdsrange(y,1,1); test_cond("sdsrange(...,1,1)", sdslen(y) == 1 &amp;&amp; memcmp(y,"i\0",2) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,-1); test_cond("sdsrange(...,1,-1)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,-2,-1); test_cond("sdsrange(...,-2,-1)", sdslen(y) == 2 &amp;&amp; memcmp(y,"ao\0",3) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,2,1); test_cond("sdsrange(...,2,1)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,100); test_cond("sdsrange(...,1,100)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,100,100); test_cond("sdsrange(...,100,100)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); sdsfree(x); x = sdsnew("foo"); y = sdsnew("foa"); test_cond("sdscmp(foo,foa)", sdscmp(x,y) &gt; 0) sdsfree(y); sdsfree(x); x = sdsnew("bar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) == 0) sdsfree(y); sdsfree(x); x = sdsnew("aar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) &lt; 0) sdsfree(y); sdsfree(x); x = sdsnewlen("\a\n\0foo\r",7); y = sdscatrepr(sdsempty(),x,sdslen(x)); test_cond("sdscatrepr(...data...)", memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0) &#123; unsigned int oldfree; char *p; int step = 10, j, i; sdsfree(x); sdsfree(y); x = sdsnew("0"); test_cond("sdsnew() free/len buffers", sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0); /* Run the test a few times in order to hit the first two * SDS header types. */ for (i = 0; i &lt; 10; i++) &#123; int oldlen = sdslen(x); x = sdsMakeRoomFor(x,step); int type = x[-1]&amp;SDS_TYPE_MASK; test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen); if (type != SDS_TYPE_5) &#123; test_cond("sdsMakeRoomFor() free", sdsavail(x) &gt;= step); oldfree = sdsavail(x); &#125; p = x+oldlen; for (j = 0; j &lt; step; j++) &#123; p[j] = 'A'+j; &#125; sdsIncrLen(x,step); &#125; test_cond("sdsMakeRoomFor() content", memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0); test_cond("sdsMakeRoomFor() final length",sdslen(x)==101); sdsfree(x); &#125; &#125; test_report() return 0;&#125;#endif#ifdef SDS_TEST_MAINint main(void) &#123; return sdsTest();&#125;#endif]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(1)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-1.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的头文件. SDS 的头文件包括两个文件: sds.h 和 sdsalloc.h. sds.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/* SDSLib 2.0, 一个 C 实现的 strings 库 */#ifndef __SDS_H#define __SDS_H// 最大预分配给 sds 字符串的空间长度(分配给 sds 字符串的空间最大增长长度)#define SDS_MAX_PREALLOC (1024 * 1024)#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdint.h&gt;// 类别名, 用于指向 sdshdr 的 buf 属性typedef char *sds;// lsb 最低有效位/* 注意: sdshdr5 是永远不会被使用的, 它只是被我们用来直接获取 flags 标记字节. * 这里是记录 SDS strings类型 5 的布局. */struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3// 麻蛋, C 实现的多态... 吓尿了... // 但是感觉在代码中突然冒出一个 sh 会影响程序的可读性.#define SDS_HDR_VAR(T, s) struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)))#define SDS_HDR(T, s) ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))#define SDS_TYPE_5_LEN(f) ((f) &gt;&gt; SDS_TYPE_BITS)// 获取 sds 实际保存的字符串的长度// T = O(1)static inline size_t sdslen(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;len; &#125; return 0;&#125;// 获取 sds 分配给 sds 字符串的空间的长度与保存的字符串长度之差, 即空闲空间// T = O(1)static inline size_t sdsavail(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125;// 设置 sds 实际保存的字符串长度// T = O(1)static inline void sdssetlen(sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len = newlen; break; &#125;&#125;// 设置 sds 实际保存字符串增加的长度// T = O(1)static inline void sdsinclen(sds s, size_t inc)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char newlen = SDS_TYPE_5_LEN(flags) + inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); //=============================感觉没有必要呀 &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len += inc; break; &#125;&#125;/* sdsalloc() = sdsavail() + sdslen() */// 获取 sds 分配给 sds 字符串的空间的长度// T = O(1)static inline size_t sdsalloc(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;alloc; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;alloc; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;alloc; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;alloc; &#125; return 0;&#125;// 设置分配给 sds 字符串的空间长度// T = O(1)static inline void sdssetalloc(const sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: /* 不需要做什么事, 这个类型没有分配给 sds 字符串的空间信息 */ break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;alloc = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;alloc = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;alloc = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;alloc = newlen; break; &#125;&#125;sds sdsnewlen(const void *init, size_t initlen); // 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化sds sdsnew(const char *init); // 根据给定字符串 init 创建一个包含同样字符串的 sdssds sdsempty(void); // 创建并返回一个只保存了空字符串 "" 的 sdssds sdsdup(const sds s); // 复制给定 sds 的副本void sdsfree(sds s); // 释放 sds. 如果 s 为空, 则不需要干什么sds sdsgrowzero(sds s, size_t len); // 增长字符串, 并将增加的部分置为 0sds sdscatlen(sds s, const void *t, size_t len); // 在 sds 字符串后添加长度为 len 的字符串sds sdscat(sds s, const char *t); // 在 sds 字符串后添加指定以 null 终止的 C 字符串.sds sdscatsds(sds s, const sds t); // 在 sds 字符串后添加指定 sds 字符串.sds sdscpylen(sds s, const char *t, size_t len); // 拷贝二进制安全字符串 't' 到 sds 字符串中.sds sdscpy(sds s, const char *t); // 对 C 字符串进行拷贝sds sdscatvprintf(sds s, const char *fmt, va_list ap); // 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串#ifdef __GNUC__sds sdscatprintf(sds s, const char *fmt, ...) __attribute__((format(printf, 2, 3)));#elsesds sdscatprintf(sds s, const char *fmt, ...);#endifsds sdscatfmt(sds s, char const *fmt, ...); // 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串sds sdstrim(sds s, const char *cset); // 删除 sds 字符串首尾在 'cset' 中存在的字符串void sdsrange(sds s, int start, int end); //将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.void sdsupdatelen(sds s); // 更新 sds 的长度void sdsclear(sds s); // 清空 sds 字符串的内容int sdscmp(const sds s1, const sds s2); // 比较两个字符串sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count); // 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾void sdsfreesplitres(sds *tokens, int count); // 释放分割的结果void sdstolower(sds s); // 将 sds 字符串 's' 中的字母转换为小写字母void sdstoupper(sds s); // 将 sds 字符串 's' 中的字母转换为大写字母sds sdsfromlonglong(long long value); // long long 类型转换为 sds 类型sds sdscatrepr(sds s, const char *p, size_t len); // 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.sds *sdssplitargs(const char *line, int *argc); // 将字符串按照 REPL 格式切分成一个 sds 参数数组sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen); // 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符sds sdsjoin(char **argv, int argc, char *sep); // 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen); // 类似sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串/* 低等级函数作为 API 暴露给用户使用 */sds sdsMakeRoomFor(sds s, size_t addlen);void sdsIncrLen(sds s, int incr);sds sdsRemoveFreeSpace(sds s);size_t sdsAllocSize(sds s);void *sdsAllocPtr(sds s);/* 将 SDS 使用的分配器输出给调用 SDS 的程序使用. * 有时链接 SDS 的程序可能会设置不同的迭代器, 但是可能想要分配或释放 SDS 分别释放或分配的一些东西. */// 封装 SDS 分配器给调用者使用void *sds_malloc(size_t size);void *sds_realloc(void *ptr, size_t size);void sds_free(void *ptr);#ifdef REDIS_TESTint sdsTest(int argc, char *argv[]);#endif#endif sdsalloc.h12345678910111213/* SDSLib 2.0, 一个 C 实现的 strings 库 *//* SDS 选择分配器. * * 使用这个文件是为了在编译时可以改变 SDS 的分配器. * 只需要根据你需要使用的分配器定义宏. * 也需要根据需要 include(导入) 你用来替换的分配器的库 * (使用默认分配器不需要). */#include "zmalloc.h"#define s_malloc zmalloc#define s_realloc zrealloc#define s_free zfree]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.&emsp;&emsp;以前一直没有阅读过真正大项目的源码, 真正开始阅读才发现Redis的源码对我来说真的是好庞大, 一个文件上千行代码, 利用工作之余阅读, 尽量做到认真阅读每行代码, 大于要花大半个月的时间, 算算时间可能阅读完Redis源码需要花费的时间要超过一年. 回顾以往经历, 对自己能否坚持下来很是担心. 正好这两天我也在看一个大神的博客, 想自己搞个博客, 写点东西. 所以搞个博客记录一下自己的学习. 一方面可以归纳总结自己所学到的东西, 有不对的地方也可以被其他人指正; 另一方面有人阅读我的文章也是对我的一种激励, 避免一个人独自学习因为无聊而放弃.最开始在网上找到了一份关于Redis 2.8 的中文注释源码, 就开始阅读这份源码. 在阅读过程中查资料时发现了 Redis设计与实现 , 感觉这个本书写的挺不错, 而且也附带有一份关于Redis 3.0 的中文注释源码, 同时由于发现了一处Redis源码中的小问题在向Redis提交代码是发现最新的Redis已经到了4.0版本. 于是决定参考2.8和3.0的源码阅读Redis 4.0版本的源码. 由于对redis还没有一个整体的认识, 所以在阅读过程中可能存在一些错误的认识, 欢迎大家指正. Redis 学习资源 Redis 官网 Redis 中文官方网站 Github 上 Redis 源码 线上 Redis 示范环境 Redis 使用教程 如何阅读 Redis 源码? Redis 设计与实现 Redis 3.0中文注释源码 Redis 2.8源码解析 Reids 2.8中文注释源码]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
