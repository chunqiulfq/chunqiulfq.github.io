<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用户堆栈扩展]]></title>
    <url>%2F2018-02-13-%E7%94%A8%E6%88%B7%E5%A0%86%E6%A0%88%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 越界访问 中, 对于 do_page_fault() 的分析只进行了部分, 只分析了 find_vma 返回 vma 紧邻其上的区间不是栈区的处理情况. 这里分析一下如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. &emsp;&emsp;当系统为一个进程分配的栈空间已经被使用完, 栈顶指针 %esp 已经指向已映射的栈区区间的开始地址(栈自顶而下分配空间)时, 如果出现新的函数调用, 就需要先将函数的参数入栈到 %esp - 4 的位置, 但是由于栈区区间已经到达开始地址, 再向下就是还没有映射的空洞. 在访问 %esp - 4 时, 就会发生一次页面出错异常. 12345678910111213141516171819202122232425262728293031323334353637383940// arch/i386/mm/fault.c [do_page_fault()] // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; // 内存映射的空洞紧邻其上的是一个栈区区间 // 处于用户模式 if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. * * 访问 %esp 所指向的栈顶之下的空间总是一个 bug. * 由于一些指令(如 pusha)会使 %esp 做递减, 并在更下面的位置, * 所以会 "+ 32" */ // 在参数入栈时一次入栈最多通过 pusha 入栈 32 个字节 // 所以如果访问的位置超出 32 个字节说明访问的页面出错异常不是堆栈扩展造成的 if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; // 本次页面出错异常是堆栈扩展造成的 // 扩展堆栈: expand_stack 建立页面映射并扩展栈区 if (expand_stack(vma, address)) goto bad_area; &emsp;&emsp;出现页面出错异常在 vma 排除其他三种情况(if (!vma), if (vma-&gt;vm_start &lt;= address), if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)))后, 剩下的就是如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. 这时也分为两种可能: 由于栈区空间被使用完, 栈空间自顶向下扩展时产生的页面出错异常. 由于内存非法越界访问, 访问的地址落入栈空间与堆空间的空洞中. &emsp;&emsp;区分这两种可能是使用访问地址的位置进行判断. 栈空间扩展都是先参数入栈, 然后再开辟栈帧. 当参数入栈时, 通常是一次压入 4 个字节, 这时访问的虚拟地址为 %esp - 4, 但在 i386 CPU 中有一个 pusha 指令, 一次可以将 32 个字节(8 个 32 位寄存器的内容)压入栈空间. 所以如果是栈区扩展产生的页面出错异常那么访问的虚拟地址就会在 %esp - 32 及其以上的区域, 否则访问的地址就会低于 %esp - 32, 出现这种情况的处理方式与 越界访问 中的处理方式相同. &emsp;&emsp;当确认页面出错异常为扩展栈空间的要求时, 就要开始从当前空洞的顶部为栈空间扩展: 建立页面映射, 并将之并入栈区区间(if (expand_stack(vma, address))). 扩展栈区123456789101112131415161718192021222324252627282930// include/linux/mm.h [do_page_fault() &gt; expand_stack()]/* vma is the first one with address &lt; vma-&gt;vm_end, * and even address &lt; vma-&gt;vm_start. Have to extend vma. * * 参数 vma 是第一个 address &lt; vma-&gt;vm_end 甚至 address &lt; vma-&gt;vm_start 的区间. * 必须扩展 vma * */// 将栈区自顶向下扩展static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)&#123; unsigned long grow; // 将地址按照页面边界对齐 address &amp;= PAGE_MASK; // 获取扩展页面数 grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT; // 进程栈空间的大小超过了限制的最大值或进程可用存储区超过了限制的最大长度 if (vma-&gt;vm_end - address &gt; current-&gt;rlim[RLIMIT_STACK].rlim_cur || ((vma-&gt;vm_mm-&gt;total_vm + grow) &lt;&lt; PAGE_SHIFT) &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur) return -ENOMEM; // 扩展栈区 vma-&gt;vm_start = address; vma-&gt;vm_pgoff -= grow; vma-&gt;vm_mm-&gt;total_vm += grow; if (vma-&gt;vm_flags &amp; VM_LOCKED) vma-&gt;vm_mm-&gt;locked_vm += grow; return 0;&#125; &emsp;&emsp;由于系统资源有限, 所以进程对各种资源的使用有限制. 每个进程的 task_struct 结构中都有一个 rlim 结构数组规定了每种资源分配的使用限制. 代码中的 RLIMIT_STACK 限制了栈的最大大小, RLIMIT_AS 限制了进程可用存储区的最大长度(字节). 如果扩展以后栈区大小超过了限制的最大值或者动态分配的页面总量超过了可用于该进程的资源限制, 就不能再扩展了, 返回一个 -ENOMEM 的出错代码. &emsp;&emsp;expand_stack() 函数扩展栈区以页面为单位进行扩展, 只是改变栈区的 vm_area_struct 结构, 并未建立起新扩展的页面对物理内存的映射. &emsp;&emsp;从 expand_stack() 函数中正确返回, 会进入 do_page_fault() 函数的 good_vma 中, 表示访问的地址在一个 vma 中, 这里会根据 error_code 判断页面出错异常出错原因. 1234567891011121314151617181920212223// arch/i386/mm/fault.c [do_page_fault()]/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code) &emsp;&emsp;出现页面出错异常是由于需要压栈, 即数据写入(error_code 中 bit 1 == 1). 已经扩展了 vm_area_struct 但是没有建立物理页面的映射, 即物理页面不存在(error_code 中 bit 0 == 0). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// arch/i386/mm/fault.c [do_page_fault()]/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. * * 对于这次内存访问, 我们有一个好的 vm_area_struct, 因此我们可以处理它.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */ /* 出错指令为读操作, 物理页面在内存中 */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ /* 出错指令为写操作, 物理页面不在内存中 */ // 检查当前 vma 是否可写 if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ /* 出错指令为读操作, 物理页面在内存中 */ goto bad_area; case 0: /* read, not present */ /* 出错指令为读操作, 物理页面不在内存中 */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. * * 如果因为任何原因我们无法处理错误, 请确保我们优雅的退出, 而不是无休止的重复处理错误. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ // 处理与 VM86 模式及 VGA 的图像存储区相关的特殊情况 if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return; &emsp;&emsp;所以 switch (error_code &amp; 3) 时会进入 case 2: 分支检查当前 vm_area_struct 是否可写, 不可写与 越界访问 处理方式相同. 可写进入 handle_mm_fault() 函数. 建立映射123456789101112131415161718192021222324252627282930// mm/memory.c [do_page_fault() &gt; handle_mm_fault()]/* * By the time we get here, we already hold the mm semaphore * * 当我们到达这里, 我们已经有了 mm */// 处理页面映射过程中的错误int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access)&#123; int ret = -1; pgd_t *pgd; pmd_t *pmd; // 获取当前虚拟地址所在的 pgd_t 指针 pgd = pgd_offset(mm, address); // 获取当前虚拟地址所在的 pmd_t 指针 pmd = pmd_alloc(pgd, address); // 如果虚拟地址所在 pmd_t 指针不为空 if (pmd) &#123; // 获取当前虚拟地址所在的 pte_t 指针 pte_t * pte = pte_alloc(pmd, address); // 如果虚拟地址所在 pte_t 指针不为空 if (pte) ret = handle_pte_fault(mm, vma, address, write_access, pte); &#125; return ret;&#125; &emsp;&emsp;先获取虚拟地址所在的页目录项指针. 页目录总是存在的. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; pgd_offset()]/* to find an entry in a page-table-directory. *//* 在页目录中查找虚拟地址所在的页目录项 */// 获取页目录中虚拟地址所在下标#define pgd_index(address) ((address &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))#define __pgd_offset(address) pgd_index(address)// 获取页目录中虚拟地址所在的页目录项的指针#define pgd_offset(mm, address) ((mm)-&gt;pgd+pgd_index(address)) &emsp;&emsp;然后获取虚拟地址所在的中间目录项指针. 由于 i386 CPU 中没有使用 PMD, 所以把页目录项当做只有一个表项的 PMD, 所以 pmd_alloc() 绝对不会执行失败. 所以 handle_mm_fault() 中的 pmd 绝对不会为 0. 12345678910// include/asm-i386/pgalloc-2level.h [do_page_fault() &gt; handle_mm_fault() &gt; pmd_alloc()]// 在中间目录中查找虚拟地址所在的中间目录项// i386 中没有启用 PMD, 把页目录项当做只有一个表项的 PMDextern inline pmd_t * pmd_alloc(pgd_t *pgd, unsigned long address)&#123; if (!pgd) BUG(); return (pmd_t *) pgd;&#125; &emsp;&emsp;其次获取虚拟地址所在的页表项指针. 中间目录项指针有可能指向一个存在的页表, 可以直接获取页表项指针; 也有可能中间目录项为空, 页表不存在, 需要在 getnew 中申请一个新的页表. 一个页表与一个物理页面大小相同, 内核中对页面表的分配作了一些优化. 当释放一个页表时, 内核将释放的页表保存在页表缓存池中, 而不直接释放物理内存页面. 只有在缓存池已满的情况下才真正将页表所占用的物理内存页面释放. 如果页表缓存池中有页表, 就直接获取, 如果没有则使用 get_pte_slow() 获取页表, 这时如果物理内存页面用完, 则需要将长时间没有使用的物理内存页面交换到磁盘上去, 获取页表的速度会很慢. 123456789101112131415161718192021222324252627282930313233// include/asm-i386/pgalloc.h [do_page_fault() &gt; handle_mm_fault() &gt; pte_alloc()]// 在页表中查找虚拟地址所在的页表项// 如果页表不存在则创建页表extern inline pte_t * pte_alloc(pmd_t * pmd, unsigned long address)&#123; // 获取虚拟地址所在物理页面指针在页表中的下标 address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1); // 判断 pmd_t 是否为空 if (pmd_none(*pmd)) goto getnew; // 判断中间目录项权限是否正确 if (pmd_bad(*pmd)) goto fix; return (pte_t *)pmd_page(*pmd) + address;// 获取一个新的页表getnew:&#123; // 从页表缓存池中获取一页页表 unsigned long page = (unsigned long) get_pte_fast(); // 判读是否缓存池已空 if (!page) return get_pte_slow(pmd, address); // 获取页表, 返回给定偏移量位置的页表项指针 // 将获取的页表绑定到中间目录项中 set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(page))); return (pte_t *)page + address;&#125;fix: __handle_bad_pmd(pmd); return NULL;&#125; &emsp;&emsp;最后就是映射到物理页面本身了, 对应到栈区扩展的情况, 物理内存页面还没有分配, 所以物理页面不在内存中, 一定会进入 if (!pte_present(entry)), 对应的页表项也一定会为空, 一定会进入 if (pte_none(entry)). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault()]/* * These routines also need to handle stuff like marking pages dirty * and/or accessed for architectures that don't do it in hardware (most * RISC architectures). The early dirtying is also good on the i386. * * 这些程序也需要处理如硬件体系结构(大部分为 RISC 体系结构)无法做到的设置页面脏和/或已访问. * * There is also a hook called "update_mmu_cache()" that architectures * with external mmu caches can use to update those (ie the Sparc or * PowerPC hashed page tables that act as extended TLBs). * * Note the "page_table_lock". It is to protect against kswapd removing * pages from under us. Note that kswapd only ever _removes_ pages, never * adds them. As such, once we have noticed that the page is not present, * we can drop the lock early. * * The adding of pages is protected by the MM semaphore (which we hold), * so we don't need to worry about a page being suddenly been added into * our VM. */static inline int handle_pte_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t * pte)&#123; pte_t entry; /* * We need the page table lock to synchronize with kswapd * and the SMP-safe atomic PTE updates. */ // 加锁 spin_lock(&amp;mm-&gt;page_table_lock); entry = *pte; // 判断 PTE 的 P 标志位和第 8 位是否设置(查看物理页面是否在内存中) if (!pte_present(entry)) &#123; /* * If it truly wasn't present, we know that kswapd * and the PTE updates will not touch it later. So * drop the lock. * * 如果它确实不存在, 我们知道 kswapd 和 PTE 更新不会稍后不会触及它. * 因此解锁. */ spin_unlock(&amp;mm-&gt;page_table_lock); // 判断 PTE 是否为 0, 是则表示映射还未建立, 否表示映射已经建立 if (pte_none(entry)) return do_no_page(mm, vma, address, write_access, pte); // 如果页表项不为空, 说明物理页面在磁盘上 return do_swap_page(mm, vma, address, pte, pte_to_swp_entry(entry), write_access); &#125; if (write_access) &#123; if (!pte_write(entry)) return do_wp_page(mm, vma, address, pte, entry); entry = pte_mkdirty(entry); &#125; entry = pte_mkyoung(entry); establish_pte(vma, address, pte, entry); spin_unlock(&amp;mm-&gt;page_table_lock); return 1;&#125; &emsp;&emsp;vm_area_struct 中存在一个 vm_operations_struct 结构体(数据结构 中介绍), 这个结构实际上是一个函数跳转表, 结构中通常是一些与文件操作有关的函数指针, 这样, 当通过 mmap() 将一块虚存区间与一个已打开的文件(包括设备)建立映射后, 就可以通对这些函数的操作转化成对文件操作, 或者进行一些必要的对文件的附加操作. 另一方面, 物理页面的盘区交换显然也和文件操作有关. 所以为特定的虚存空间预先指定一些操作是很有必要的. &emsp;&emsp;其中 nopage 用于物理内存页面的分配. 为什么物理内存页面的分配与文件操作有关? 因为这对文件共享很有意义. 当多个进程将同一个文件映射到各自的虚存空间中时, 内存中通常只会保存一份物理页面就可以. 只有当一个进程需要写入该文件时, 才有必要另外复制一份独立的副本, 称为 copy on write 或者 COW(后面进程中关于 fork() 的内容详细介绍). &emsp;&emsp;由于这里是栈区扩展, 与文件系统或页面共享没有关系, 所以不会指定 nopage 操作, 会进入 do_anonymous_page() 函数处理. 123456789101112131415161718192021222324252627// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page()]/* * do_no_page() tries to create a new page mapping. It aggressively * tries to share with existing pages, but makes a separate copy if * the "write_access" parameter is true in order to avoid the next * page fault. * * do_no_page() 尝试创建一个新的页面映射. 它积极尝试与已存在的页面共享, 但是如果 write_access 参数为 true, * 为了避免再次出现页面错误, 它会创建单独的副本. * * As this is called only for pages that do not currently exist, we * do not need to flush old virtual caches or the TLB. * * 仅针对当前不存在的页面调用这个函数, 因此我们不需要刷新就得虚拟缓存或 TLB. * * This is called with the MM semaphore held. */static int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t *page_table)&#123; struct page * new_page; pte_t entry; // 如果当前区间没有定义 vm_operation_struct 的函数操作或者没有定义 vm_operation_struct 中缺页时的操作 nopage if (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage) return do_anonymous_page(mm, vma, page_table, write_access, address); &emsp;&emsp;进入 do_anonymous_page() 函数后, 如果引发异常的是读操作就会将页表项指向一个始终为 0 的只读的全局共享物理内存页面; 如果是写操作就会获取一个新的物理页面, 将页表项指向可写的物理内存页面. 1234567891011121314151617181920212223242526272829// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page()]/* * This only needs the MM semaphore */static int do_anonymous_page(struct mm_struct * mm, struct vm_area_struct * vma, pte_t *page_table, int write_access, unsigned long addr)&#123; struct page *page = NULL; // 将页表项指向一个始终为 0 的只读的全局共享物理内存页面 mk_pte: 设置页表项中的权限位 pte_t entry = pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot)); // 如果出现异常的指令是写操作 if (write_access) &#123; // 获取一个物理页面 page = alloc_page(GFP_HIGHUSER); if (!page) return -1; clear_user_highpage(page, addr); // 将页表项指向可写的物理内存页面 page entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot))); mm-&gt;rss++; flush_page_to_ram(page); &#125; // 将页表项的值填入一个页表项中. set_pte(page_table, entry); /* No need to invalidate - it was non-present before */ // i386 的 MMU 在 CPU 中, 不需要这个功能, 这里为空函数 update_mmu_cache(vma, addr, entry); return 1; /* Minor fault */&#125; &emsp;&emsp;只要是只读页面, 开始时都会不管其虚拟地址是什么, 直接映射向同一个始终为 0 物理页面 empty_zero_page. 只有是可写页面时才会分配新的独立物理内存. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page() &gt; ZERO_PAGE()]/* * ZERO_PAGE is a global shared page that is always zero: used * for zero-mapped memory areas etc.. * * ZERO_PAGE 是一个始终为 0 的全局共享页面: 用于零映射内存区域等.. */extern unsigned long empty_zero_page[1024];// 获取一个全局共享的初始化为 0 的物理页面#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page)) &emsp;&emsp;栈区扩展是由于写操作异常引起的, 所以会调用 alloc_page() 为其分配新的物理内存页面, 并将分配的物理页面及权限写入页表项中. 至此映射建立完成, 逐层退出函数. 注意&emsp;&emsp;当 CPU 从一次页面出错异常处理返回到用户空间时, 将会先重新执行因映射失败而中断的那条指令, 然后才会继续向下执行, 这是异常处理的特殊性. 中断以及自陷(trap 指令) 发生时, CPU 都会将下一条指令, 也就是接下去本来要执行的指令的地址入栈作为恢复中断服务的返回地址. 而当异常发生时, CPU 将因无法完成(例如除以 0, 映射失败等) 而夭折的指令本身的地址(而不是下一条指令的地址)压入栈, 当从异常处理返回时继续刚刚没有完成的指令. 这个过程是在 CPU 内部电路中实现的, 不需要软件干预. 从这个意义上来讲, 缺页中断 正确的说法应该是 缺页异常. 本文参考自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[越界访问]]></title>
    <url>%2F2018-02-07-%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;页式存储管理机制通过页目录和页表将每个线性地址映射到物理地址. 但是在这个过程中可能存在一些问题导致映射失败, 这时 CPU 就会产生 页面出错异常(Page Fault Exception), 也成 缺页中断, 进而执行预定的页面异常处理程序, 使应用程序从产生异常的指令处恢复执行或进行善后处理. 产生 页面出错异常(Page Fault Exception) 的原因有: 访问的 pgd_t 或 pte_t 为空. 这可能是还未映射或映射已经撤销导致的. 物理页面被交换出内存. 指令的访问方式与页面要求的权限不符. 如修改只读页面. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291// arch/i386/mm/fault.c/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)&#123; // 当前出现异常进程的 task_struct struct task_struct *tsk; // 当前出现异常进程用户空间 mm_struct struct mm_struct *mm; // 当前出现异常进程的出错区间 struct vm_area_struct * vma; // 当前出现异常进程访问的出错地址 unsigned long address; unsigned long page; unsigned long fixup; int write; siginfo_t info; /* get the address */ /* 获取出错地址 */ __asm__("movl %%cr2,%0":"=r" (address)); // 获取 task_struct tsk = current; /* * We fault-in kernel-space virtual memory on-demand. The * 'reference' page table is init_mm.pgd. * * NOTE! We MUST NOT take any locks for this case. We may * be in an interrupt or a critical region, and should * only copy the information from the master page table, * nothing more. */ if (address &gt;= TASK_SIZE) goto vmalloc_fault; // 获取 mm_struct mm = tsk-&gt;mm; info.si_code = SEGV_MAPERR; /* * If we're in an interrupt or have no user * context, we must not take the fault.. * * 如果我们处于中断或没有用户上下文环境的情况下, 我们绝不能处理这种错误. */ // in_interrupt() 返回非零, 说明映射失败发生在某个中断/异常处理程序中, 与当前出现异常进程无关. // mm 为空, 说明当前出现异常进程的映射还没有建立, 与该进程无关. 说明映射发生在某个 in_interrupt() 程序无法检测的某个中断/异常处理程序中. if (in_interrupt() || !mm) goto no_context; // 信号量, 锁住 mm_struct 及其下属的 vm_area_struct, 防止其他进程打扰. down(&amp;mm-&gt;mmap_sem); // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前异常虚拟地址所在的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. */ if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; if (expand_stack(vma, address)) goto bad_area;/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ goto bad_area; case 0: /* read, not present */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return;/* * Something tried to access memory that isn't in our memory map.. * Fix it, but check if it's kernel or user first.. * * 尝试访问的内存不在内存映射(vm_area_struct)之中.. * 首先检查当前出现异常进程属于用户还是内核, 然后修复.. */bad_area: // 对于 mm_struct 及其下属 vm_area_struct 的使用完成, 信号量解锁 up(&amp;mm-&gt;mmap_sem);bad_area_nosemaphore: /* User mode accesses just cause a SIGSEGV */ /* 用户模块访问只会导致 SIGSEGV */ // 用户模式 if (error_code &amp; 4) &#123; // 设置当前出现异常进程的 task_struct tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; // 向当前出现异常进程发送一个强制 SIGSEGV 信号, 产生 Segment Fault info.si_signo = SIGSEGV; info.si_errno = 0; /* info.si_code has been set above */ info.si_addr = (void *)address; force_sig_info(SIGSEGV, &amp;info, tsk); return; &#125; /* * Pentium F0 0F C7 C8 bug workaround. */ if (boot_cpu_data.f00f_bug) &#123; unsigned long nr; nr = (address - idt) &gt;&gt; 3; if (nr == 6) &#123; do_invalid_op(regs, 0); return; &#125; &#125;no_context: /* Are we prepared to handle this kernel fault? */ if ((fixup = search_exception_table(regs-&gt;eip)) != 0) &#123; regs-&gt;eip = fixup; return; &#125;/* * Oops. The kernel tried to access some bad page. We'll have to * terminate things with extreme prejudice. */ bust_spinlocks(); if (address &lt; PAGE_SIZE) printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference"); else printk(KERN_ALERT "Unable to handle kernel paging request"); printk(" at virtual address %08lx\n",address); printk(" printing eip:\n"); printk("%08lx\n", regs-&gt;eip); asm("movl %%cr3,%0":"=r" (page)); page = ((unsigned long *) __va(page))[address &gt;&gt; 22]; printk(KERN_ALERT "*pde = %08lx\n", page); if (page &amp; 1) &#123; page &amp;= PAGE_MASK; address &amp;= 0x003ff000; page = ((unsigned long *) __va(page))[address &gt;&gt; PAGE_SHIFT]; printk(KERN_ALERT "*pte = %08lx\n", page); &#125; die("Oops", regs, error_code); do_exit(SIGKILL);/* * We ran out of memory, or some other thing happened to us that made * us unable to handle the page fault gracefully. */out_of_memory: up(&amp;mm-&gt;mmap_sem); printk("VM: killing process %s\n", tsk-&gt;comm); if (error_code &amp; 4) do_exit(SIGKILL); goto no_context;do_sigbus: up(&amp;mm-&gt;mmap_sem); /* * Send a sigbus, regardless of whether we were in kernel * or user mode. */ tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; info.si_code = SIGBUS; info.si_errno = 0; info.si_code = BUS_ADRERR; info.si_addr = (void *)address; force_sig_info(SIGBUS, &amp;info, tsk); /* Kernel mode? Handle exceptions or die */ if (!(error_code &amp; 4)) goto no_context; return;vmalloc_fault: &#123; /* * Synchronize this task's top level page-table * with the 'reference' page table. */ int offset = __pgd_offset(address); pgd_t *pgd, *pgd_k; pmd_t *pmd, *pmd_k; pgd = tsk-&gt;active_mm-&gt;pgd + offset; pgd_k = init_mm.pgd + offset; if (!pgd_present(*pgd)) &#123; if (!pgd_present(*pgd_k)) goto bad_area_nosemaphore; set_pgd(pgd, *pgd_k); return; &#125; pmd = pmd_offset(pgd, address); pmd_k = pmd_offset(pgd_k, address); if (pmd_present(*pmd) || !pmd_present(*pmd_k)) goto bad_area_nosemaphore; set_pmd(pmd, *pmd_k); return; &#125;&#125; &emsp;&emsp;代码开始时使用汇编获取 address 是因为 i386 CPU 产生 页面出错异常(Page Fault Exception) 时, 会将访问产生这个错误的虚拟地址放入控制寄存器 CR2 中. 由于 C 语言没有直接读取 CR2 的语句, 所以需要使用汇编进行获取. &emsp;&emsp;对于获取到的 vma 的分析: 进程的内存布局代码段, 数据段, bss段, 堆等自底向上分布, 栈区自顶向下发展, 所以结束地址最高的区间为栈区, 如果访问异常的虚拟地址比最高区间的结束地址还高(find_vma 返回 NULL, if (!vma)), 说明其处于高 1G 的系统空间中. 如果访问异常的虚拟地址大于等于当前区间的其实地址(if (vma-&gt;vm_start &lt;= address)), 说明异常发生在当前区间. 如果访问异常的虚拟地址不在系统空间, 也不再任何一个区间, 说明其处于一个内存映射的空洞中: VM_GROWSDOWN 表示一个区间处于栈区, 如果内存映射的空洞紧邻其上的是一个栈区区间说明空洞是栈区一下的空洞, 这个空洞是供动态分配使用(通过系统调用 brk())但是还没有分配出去的空间. 如果紧邻其上的区间没有设置 VM_GROWSDOWN, 说明空洞是因为一个没有建立映射区间或映射区间已经被销毁的空间. &emsp;&emsp;每次从中断/异常处理程序中返回之前, 都要检查当前进程是否有信号(或称软中断)需要处理, 在 vma 处于最后一种情况时需要处理 SIGSEGV 信号. 内核会根据这些待处理信号的性质以及进程本身的选择进行处理. 有些信号是强制执行, 有些是按照进程设置处理. SIGSEGV 信号需要强制执行, 会是该进程产生 Segment Fault, 然后使进程退出. 本文参考自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018-01-28-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[页面映射结构&emsp;&emsp;页目录 PGD, 中间目录 PMD, 页表 PT 分别是由表项 pgd_t, pmd_t 以及 pte_t 构成的数组. 123456789101112131415161718192021222324252627282930// include/asm-i386/page.h/* * These are used to make use of C type-checking.. * * 这些用于 C 类型检查.. */#if CONFIG_X86_PAE // 三层映射 PAE 模式// PT 表项typedef struct &#123; unsigned long pte_low, pte_high; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low | ((unsigned long long)(x).pte_high &lt;&lt; 32))#else // 两层映射// PT 表项typedef struct &#123; unsigned long pte_low; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low)#endif#define PTE_MASK PAGE_MASK// 页面状态信息和访问权限结构体typedef struct &#123; unsigned long pgprot; &#125; pgprot_t; &emsp;&emsp;32 位地址时, pgd_t, pmd_t 和 pte_t 实际上就是长整型. 36 位地址时, 则是 long long 整型. 不直接定义成整型是因为这样可以让 gcc 在编译时加以更严格的类型检查. &emsp;&emsp;所有的物理页面都是 4K 边界对齐, 因此这些表项作为页面的指针一定是 4K 的倍数, 所以指针实际只需要高 20 位, 这高 20 位也可以看做物理页面的下标序号. 所以这些表项的低 12 位就被用于记录页面的状态信息和访问权限. 内核中并没有在表项中定义相关的位段, 而是单独定义用来说明页面保护的结构 pgprot_t. 对 pgprot_t 中位段说明如下: 1234567891011121314// include/asm-i386/pgtable.h#define _PAGE_PRESENT 0x001#define _PAGE_RW 0x002#define _PAGE_USER 0x004#define _PAGE_PWT 0x008#define _PAGE_PCD 0x010#define _PAGE_ACCESSED 0x020#define _PAGE_DIRTY 0x040#define _PAGE_PSE 0x080 /* 4 MB (or 2MB) page, Pentium+, if present.. */#define _PAGE_GLOBAL 0x100 /* Global TLB entry PPro+ */// 对应 pte_t 中第 8 位, Intel 手册指定这一位保留不用, 所以对 MMU 不起作用#define _PAGE_PROTNONE 0x080 /* If not present */ &emsp;&emsp;pgprot_t 设置 pte 低 12 位, 所以总是小于 0x1000, pte 中的指针部分总是大于等于 0x1000, 将二者合在一起就得到实际用于 PT 中的表项. 1234// include/asm-i386/pgtable-2level.h// 为 pte_t 设置 pgprot_t 权限#define __mk_pte(page_nr,pgprot) __pte(((page_nr) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot)) &emsp;&emsp;当 PTE 为 0 时, 表示这个表项所代表的虚拟内存页面没有建立映射. 在映射过程中 MMU 会首先检查 P 标志位, 即 _PAGE_PRESENT, 表示映射的页面是否在内存中. 只有当 P 标志位为 1 时, MMU 才会完成映射的全过程; 如果 PTE 不为 0, P 标志位为 0 时, 表示映射已经建立, 但是所映射的物理页面不在内存中, 会产生一次缺页异常. 物理内存管理结构page 结构&emsp;&emsp;在内核中有个全局的 mem_map 指针, 指向一个 page 结构体的数组, 每个 page 代表一个物理页面, 整个数组代表系统中的所有物理页面. PTE 不仅仅低 12 位为 0 时对于硬件是物理页面的地址, 同时它的高 20 位对于软件也代表这个数组的下标. 1234// include/asm-i386/pgtable-2level.h// 根据 PTE 获取 PTE 指向的物理页面的 page 指针#define pte_page(x) (mem_map+((unsigned long)(((x).pte_low &gt;&gt; PAGE_SHIFT)))) 1234567891011121314151617181920212223242526272829303132// include/linux/mm.h/* * Try to keep the most commonly accessed fields in single cache lines * here (16 bytes or greater). This ordering should be particularly * beneficial on 32-bit processors. * * 尝试在单个缓存线中保留最常访问的字段(16 字节或更大). 这一点对 32 位处理器应该特别有利. * * The first line is data used in page cache lookup, the second line * is used for linear searches (eg. clock algorithm scans). * * 第一行是用于页面缓存的查找的数据, 第二行是用于线性搜索(如时钟算法扫描). */// 物理页面结构体, 代表一个物理页面typedef struct page &#123; struct list_head list; struct address_space *mapping; // 当页面内容来自一个文件时, index 表示该页面在文件中的序号 // 当页面的内容被交换到磁盘上, index 表示页面的去向 unsigned long index; struct page *next_hash; atomic_t count; unsigned long flags; /* atomic flags, some possibly updated asynchronously */ /* 原子标志, 有可能异步更新 */ struct list_head lru; unsigned long age; wait_queue_head_t wait; struct page **pprev_hash; struct buffer_head * buffers; void *virtual; /* non-NULL if kmapped */ struct zone_struct *zone;&#125; mem_map_t; &emsp;&emsp;page 结构中各个成分的次序是有讲究的, 目的是尽量使得联系紧密的若干成分在执行是被装填入高速缓存的同一缓冲线(16个字节)中. 系统在初始化时会创建一个由 page(或 mem_map_t) 组成的 mem_map 数组, 每个 page 代表系统中的一个物理页面, 物理页面初始地址的高 20 位就是对应 page 的下标. none_struct 结构&emsp;&emsp;mem_map 中的所有物理页面被划分成 ZONE_DMA 和 ZONE_NORMAL 两个管理区(也有可能存在第三个 ZONE_HIGHMEM). ZONE_DMA 中管理的是专供 DMA 使用的内存页. 为什么供 DMA 使用的页面要单独加以管理? DMA 使用的页面需要进行磁盘 I/O, 单独管理防止内存页面全部被分配出去无法进行页面与盘区的交换. 在 i386 中 MMU 存在于 CPU 中, DMA 不经过 MMU 的地址映射, 外设直接访问物理内存, 但是部分外设访问物理内存地址较小. DMA 所需的内存当超过 4K 时, 需要连续的物理内存页面, 无法使用 MMU 提供的连续的虚拟内存页面. &emsp;&emsp;每个管理区由 none_struct 结构创建, 一旦创建成功, 每个物理页面就永久属于一个管理区. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// include/linux/mmzone.h/* * Free memory management - zoned buddy allocator. * * 空闲内存管理 - zoned buddy allocator. */// free_area_struct 链接的最大内存块为 2 ^ MAX_ORDER#define MAX_ORDER 10typedef struct free_area_struct &#123; // 双向链表 struct list_head free_list; unsigned int *map;&#125; free_area_t;struct pglist_data;// 管理区结构体typedef struct zone_struct &#123; /* * Commonly accessed fields: * * 常用字段 */ spinlock_t lock; // 当前管理区在 mem_map 中的起始位置(页面序号) unsigned long offset; unsigned long free_pages; unsigned long inactive_clean_pages; unsigned long inactive_dirty_pages; unsigned long pages_min, pages_low, pages_high; /* * free areas of different sizes * * 不同大小的空闲空间 */ struct list_head inactive_clean_list; // 数组中每个成员都是由双向链表连接起来的内存块的链表指针, 每个成员中内存块都是由 2 ^ n 个物理页面组成(1 &lt;= n &lt;= MAX_ORDER, MAX_ORDER = 10). free_area_t free_area[MAX_ORDER]; /* * rarely used fields: * * 很少使用的字段 */ char *name; unsigned long size; /* * Discontig memory support fields. */ // 指向当前 node 节点的管理结构 pglist_data(下一小节介绍) struct pglist_data *zone_pgdat; unsigned long zone_start_paddr; unsigned long zone_start_mapnr; struct page *zone_mem_map;&#125; zone_t;// 管理区类型#define ZONE_DMA 0#define ZONE_NORMAL 1#define ZONE_HIGHMEM 2// 管理区最大数量#define MAX_NR_ZONES 3 pglist_data 结构&emsp;&emsp;计算机内存系统存在两种结构. 均质存储结构(Uniform Memory Architecture) 指计算机中所有物理内存地位均等, 访问任意物理内存消耗时间相同, 简称 UMA. 非均质存储结构(Non-Uniform Memory Architecture) 指计算机中物理内存地址虽然是连续的, 但是却分为不同的模块, 访问速度不同, 消耗的时间也不同, 简称 NUMA. &emsp;&emsp;在真实的计算机系统中, 绝对的 UMA 是不存在的. 真正的系统会存在不同的内存模块, 如多级高速缓存, RAM, ROM, 显存等. Linux 内核从 2.4.0 版本开始支持 NUMA. 在 NUMA 结构的系统中, 分配连续多个物理内存页面要求分配在质地相同的区间(称为 node, 即 节点). 这里的 node 对应到 Linux 系统中就是 pglist_data 结构. 这时 mem_map 数组将不再管理整个物理内存, 而是管理当前 node 中的物理页面. 而 zone_struct 则表示当前 node 中的管理区. 在 zone_struct 和 mem_map 之上则是 pglist_data 结构, 管理整个存储节点. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mmzone.h/* * One allocation request operates on a zonelist. A zonelist * is a list of zones, the first one is the 'goal' of the * allocation, the other zones are fallback zones, in decreasing * priority. * * 一个分配请求在一个 zonelist(管理区列表) 上运行. 一个 zonelist 是 zone 的列表, * 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. * * Right now a zonelist takes up less than a cacheline. We never * modify it apart from boot-up, and only a few indices are used, * so despite the zonelist table being relatively big, the cache * footprint of this construct is very small. * * 现在一个 zonelist 占用的空间比一个缓存线小. * 除非在启动时, 否则我们从不修改它, 并且只有少数索引被使用, 因此尽管 zonelist 表相对较大(0x100(256) 项), * 但是构造它的缓存空间是非常小的. */typedef struct zonelist_struct &#123; // zone_struct 管理区, 类型相同(猜测), 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. zone_t * zones [MAX_NR_ZONES+1]; // NULL delimited int gfp_mask;&#125; zonelist_t;// zonelist 数组最大长度#define NR_GFPINDEX 0x100struct bootmem_data;typedef struct pglist_data &#123; // 当前 node 的 zone_struct 管理区, 最大为 3 个 zone_t node_zones[MAX_NR_ZONES]; // zonelist 表, 规定最多 0x100(256) 中内存分配策略 zonelist_t node_zonelists[NR_GFPINDEX]; // 指向当前 node 的 mem_map 数组 struct page *node_mem_map; unsigned long *valid_addr_bitmap; struct bootmem_data *bdata; unsigned long node_start_paddr; unsigned long node_start_mapnr; unsigned long node_size; int node_id; // 单向链表, 指向下一个 pglist_data 节点 struct pglist_data *node_next;&#125; pg_data_t; 虚拟内存管理结构vm_area_struct 结构&emsp;&emsp;在虚拟内存中, 以进程为基础分为两个部分: 系统空间 和 用户空间. 系统空间 为所有进程共享; 用户空间 为每个进程私有. 其中 用户空间 中的各个部分未必是连续的, 通常形成许多分散的虚拟内存区间. Linux 内核中 vm_area_struct 就表示这些虚拟内存区间, 使用单链表将所有区间连接, 同时为了提高搜索效率, 在区间数量增大到 32 时(&gt;=), 会创建 AVL 树. 在Linux内核中 vm_area_struct 的变量名常常是 vma. vm_area_struct 的划分不仅仅取决于地址的连续性, 还要求同一 vm_area_struct 中的虚拟内存具有相同访问权限(vm_page_prot)和其他一些属性(vm_flags). &emsp;&emsp;同时 vm_area_struct 还会与磁盘文件发生交互: 盘去交换(swap): 指在物理内存页面不够分配时, 一些长时间不用的内存交换到磁盘上, 腾出物理页面以供应急. 这就是一般意义上的 &quot;按需调度&quot;页式虚存管理(demand paging). 系统调用 mmap(): 可以将一个打开的文件映射到用户空间中, 使进程像访问内存中的字符数组一样访问文件中的数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mm.h/* * This struct defines a memory VMM memory area. There is one of these * per VM-area/task. A VM area is any part of the process virtual memory * space that has a special rule for the page-fault handlers (ie a shared * library, the executable area etc). */struct vm_area_struct &#123; // 当前 vm_area_struct 所在进程用户空间的管理结构 mm_struct(下一小节介绍) struct mm_struct * vm_mm; /* VM area parameters */ // vm_area_struct 起始地址, 包含在 vm_area_struct 中 unsigned long vm_start; // vm_area_struct 结束地址, 不包含在 vm_area_struct 中 unsigned long vm_end; /* linked list of VM areas per task, sorted by address */ // 单链表, 每个进程的 vm_area_struct 按照地址高低依次链接 struct vm_area_struct *vm_next; // vm_area_struct 访问权限 pgprot_t vm_page_prot; // vm_area_struct 属性 unsigned long vm_flags; /* AVL tree of VM areas per task, sorted by address */ // AVL 树, 每个进程的 vm_area_struct 按照地址高低组成 AVL 树, 便于查找 short vm_avl_height; struct vm_area_struct * vm_avl_left; struct vm_area_struct * vm_avl_right; /* For areas with an address space and backing store, * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists, * for shm areas, the list of attaches, otherwise unused. */ // 记录, 管理 vm_area_struct 与磁盘文件交互 struct vm_area_struct *vm_next_share; struct vm_area_struct **vm_pprev_share; // 定义了 vm_area_struct 操作执行函数指针, 包括打开, 关闭, 缺页时建立映射 struct vm_operations_struct * vm_ops; unsigned long vm_pgoff; /* offset in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */ struct file * vm_file; unsigned long vm_raend; void * vm_private_data; /* was vm_pte (shared mem) */&#125;; 123456789101112131415// include/linux/mm.h/* * These are the virtual MM functions - opening of an area, closing and * unmapping it (needed to keep files on disk up-to-date etc), pointer * to the functions called when a no-page or a wp-page exception occurs. */struct vm_operations_struct &#123; // vma 打开操作 void (*open)(struct vm_area_struct * area); // vma 关闭操作 void (*close)(struct vm_area_struct * area); // vma 中产生缺页异常时建立映射操作 struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int write_access);&#125;; mm_struct 结构&emsp;&emsp;在 vm_area_struct 结构中存在指向 mm_struct 结构的指针, mm_struct 是整个进程用户空间的管理结构, 在内核中的变量名常常为mm, 比 vm_area_struct 更高一个层次, 对 vm_area_struct 进行管理. 每一个进程控制块即 task_struct 结构中都有一个指向当前进程 mm_struct 结构的指针. 虽然每个进程都只有一个 mm_struct 结构, 但是一个 mm_struct 结构可以被多个进程共用, 如 vfork() 的父子进程共享一个 mm_struct 结构. 123456789101112131415161718192021222324252627282930313233// include/linux/sched.hstruct mm_struct &#123; struct vm_area_struct * mmap; /* list of VMAs */ /* vma 链表 */ struct vm_area_struct * mmap_avl; /* tree of VMAs */ /* vma AVL 树 */ struct vm_area_struct * mmap_cache; /* last find_vma result */ /* find_vma 返回的结果 ,即上一次访问的 vma */ // pgd 指针 pgd_t * pgd; // atomic_t 原子操作整数 atomic_t mm_users; /* How many users with user space? */ atomic_t mm_count; /* How many references to "struct mm_struct" (users count as 1) */ int map_count; /* number of VMAs */ /* 当前 mm_struct 中 vma 的数量 */ // P, V 操作信号量. 使对 mm_struct 及下属 vm_area_struct 的访问互斥 struct semaphore mmap_sem; // 类似 mmap_sem spinlock_t page_table_lock; // 双向链表 struct list_head mmlist; /* List of all active mm's */ /* 所有存活 mm_struct 组成的链表 */ // 代码段, 数据段起始地址和终止地址 unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; unsigned long rss, total_vm, locked_vm; unsigned long def_flags; unsigned long cpu_vm_mask; unsigned long swap_cnt; /* number of pages to swap on next pass */ unsigned long swap_address; /* Architecture-specific MM context */ mm_context_t context;&#125;; &emsp;&emsp;CPU 实际进行的映射并不涉及 mm_struct 结构, 而是像 地址映射 中讲的那样通过 PGD 和 PT 进行, 但是 mm_struct 结构描述了这种映射. &emsp;&emsp;通过 mm_struct 结构查找给定虚拟地址所在的 vma: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// mm/mmap.c/* Look up the first VMA which satisfies addr &lt; vm_end, NULL if none. *//* 查找满足 addr &lt; vm_end 的 vma, 没有则返回 NULL */// 给出一个虚拟地址, 查找对应用户空间 mm 中第一个虚拟地址大于其结束地址的 vma// 返回 NULL 表示该虚拟地址所在区间还未创建struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr)&#123; struct vm_area_struct *vma = NULL; if (mm) &#123; /* Check the cache first. */ /* 实现检查缓存 */ /* (Cache hit rate is typically around 35%.) */ /* 缓存命中率大约为 35% */ vma = mm-&gt;mmap_cache; // 如果不在缓存中 if (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123; // 如果没有建立 AVL 树 if (!mm-&gt;mmap_avl) &#123; /* Go through the linear list. */ /* 通过线性链表查找 */ vma = mm-&gt;mmap; while (vma &amp;&amp; vma-&gt;vm_end &lt;= addr) vma = vma-&gt;vm_next; &#125; else &#123; /* Then go through the AVL tree quickly. */ /* 建立了 AVL 树, 通过 AVL 树快速查找 */ struct vm_area_struct * tree = mm-&gt;mmap_avl; vma = NULL; for (;;) &#123; if (tree == vm_avl_empty) break; if (tree-&gt;vm_end &gt; addr) &#123; vma = tree; if (tree-&gt;vm_start &lt;= addr) break; tree = tree-&gt;vm_avl_left; &#125; else tree = tree-&gt;vm_avl_right; &#125; &#125; if (vma) mm-&gt;mmap_cache = vma; // 将当前查到的 vma 保存到缓存中. &#125; &#125; return vma;&#125; &emsp;&emsp;在创建一个新的 vm_area_struct 将其插入 mm_struct 时, 会调用 insert_vm_struct() 函数, 在这里加了两把锁, 第一把加在新区间 vm_area_struct 上, 第二把加在代表整个虚拟空间的 mm_struct 结构中, 使得操作过程中不让其他进程能够中途也能对这两个数据结构进行修改. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// mm/mmap.c/* Insert vm structure into process list sorted by address * and into the inode's i_mmap ring. If vm_file is non-NULL * then the i_shared_lock must be held here. */void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; struct vm_area_struct **pprev; struct file * file; // 如果没有创建 AVL 树 if (!mm-&gt;mmap_avl) &#123; // 在单链表中查找 pprev = &amp;mm-&gt;mmap; while (*pprev &amp;&amp; (*pprev)-&gt;vm_start &lt;= vmp-&gt;vm_start) pprev = &amp;(*pprev)-&gt;vm_next; &#125; else &#123; // 已经创建 AVL 树, 插入 AVL 树 struct vm_area_struct *prev, *next; avl_insert_neighbours(vmp, &amp;mm-&gt;mmap_avl, &amp;prev, &amp;next); pprev = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap); if (*pprev != next) printk("insert_vm_struct: tree inconsistent with list\n"); &#125; // 将新的 vm_area_struct 加入单链表 vmp-&gt;vm_next = *pprev; *pprev = vmp; // mm_struct 中 vm_area_struct 总数++ mm-&gt;map_count++; // 当 mm_struct 中 vm_area_struct 数量达到 AVL_MIN_MAP_COUNT(32) 且没有创建 AVL 树时, 创建 vm_area_struct 的 AVL 树 if (mm-&gt;map_count &gt;= AVL_MIN_MAP_COUNT &amp;&amp; !mm-&gt;mmap_avl) build_mmap_avl(mm); // 文件映射相关操作 file = vmp-&gt;vm_file; if (file) &#123; struct inode * inode = file-&gt;f_dentry-&gt;d_inode; struct address_space *mapping = inode-&gt;i_mapping; struct vm_area_struct **head; if (vmp-&gt;vm_flags &amp; VM_DENYWRITE) atomic_dec(&amp;inode-&gt;i_writecount); head = &amp;mapping-&gt;i_mmap; if (vmp-&gt;vm_flags &amp; VM_SHARED) head = &amp;mapping-&gt;i_mmap_shared; /* insert vmp into inode's share list */ if((vmp-&gt;vm_next_share = *head) != NULL) (*head)-&gt;vm_pprev_share = &amp;vmp-&gt;vm_next_share; *head = vmp; vmp-&gt;vm_pprev_share = head; &#125;&#125;// 将一个新创建的 vm_area_struct 结构插入当前用户空间的 mm_struct 中void insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; // 加在 vm_area_struct 上的第一把锁, 防止插入过程中其他进程修改当前的 vm_area_struct lock_vma_mappings(vmp); // 加在 mm_struct 上的第二把锁, 防止插入过程中其他进程修改当前的 mm_struct spin_lock(&amp;current-&gt;mm-&gt;page_table_lock); __insert_vm_struct(mm, vmp); spin_unlock(&amp;current-&gt;mm-&gt;page_table_lock); unlock_vma_mappings(vmp);&#125; 总结 &emsp;&emsp;mm_struct 及其下属 vm_area_struct 只是说明了对虚拟内存的需求, 一个虚拟内存有相应的区间存在并不保证其所在的页面已经映射到了一个物理(物理内存或磁盘)页面, 更不保证该页面就在内存中. 总结&emsp;&emsp;mm_struct 和 vm_area_struct 说明了对页面的需求; page, zone_struct 和 pglist_data 说明了对页面的供应; PGD, PMD 和 PT 则是二者之间的桥梁. 本文参考自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地址映射]]></title>
    <url>%2F2018-01-23-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux 采用页式内存管理. 优点: 页面固定大小, 便于管理. 灵活度高, 在将内存交换到磁盘上时, 按内存页进行交换. 页式内存管理有内部碎片, 无外部碎片. &emsp;&emsp;即使 i386 CPU 在硬件上限制必须先段式再页式的映射方式, Linux 也是避开了段式映射, 在 Linux 内存映射时(除用来模拟80286的 VM86模式), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. 当然 i386 存在段式映射是有历史原因的, 对于其他 CPU 来说就不存在这一层了. 段式映射&emsp;&emsp;在获取到一个虚拟地址后, 首先确定其属于进程的哪一段内存, 然后获取相应内存段的段寄存器中的值. Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段. 1234567891011121314// include/asm-i386/processor.h// 创建进程时设置对应进程的段寄存器和栈定,栈底寄存器// Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段.#define start_thread(regs, new_eip, new_esp) do &#123; \ __asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0)); \ set_fs(USER_DS); \ regs-&gt;xds = __USER_DS; \ regs-&gt;xes = __USER_DS; \ regs-&gt;xss = __USER_DS; \ regs-&gt;xcs = __USER_CS; \ regs-&gt;eip = new_eip; \ regs-&gt;esp = new_esp; \&#125; while (0) 12345678910111213141516// include/asm-i386/segment.h#ifndef _ASM_SEGMENT_H#define _ASM_SEGMENT_H// 内核代码段寄存器初始值#define __KERNEL_CS 0x10// 内核数据段寄存器初始值#define __KERNEL_DS 0x18// 用户进程代码段寄存器初始值#define __USER_CS 0x23// 用户进程数据段寄存器初始值#define __USER_DS 0x2B#endif &emsp;&emsp;这里需要介绍一下段寄存器, RPL 为所要求的特权级别, 共分为 4 级, 00 为最高权限, 11 为最低权限, Linux 在实现时只使用了这两个级别. TI 为 0 时表示使用 GDT, 为 1 时表示使用 LDT. Index 表示对应段描述符表的下标. &emsp;&emsp;通过之前介绍, 解析 Linux 段寄存器初始值: &emsp;&emsp;TI 值均为 0, 说明都是 GDT, 没有使用 LDT, 在 Linux 中 LDT 只在 VM86模式 下使用. RPL 内核使用 00 级, 普通进程使用 11 级. index 为固定值. &emsp;&emsp;在 Linux 实现时会将 GDT 初始化为固定的值, GDT 第一项(下标为 0)会初始化为 0x0000000000000000, 这是为了防止加电后段寄存器未经初始化就进入保护模式并使用 GDT. 第 2 ~ 5 项对应之前四中段寄存器. 12345678910111213141516171819202122// arch/i386/kernel/head.S/* * This contains typically 140 quadwords, depending on NR_CPUS. * * 这通常包含140个四字(64位), 取决于NR_CPUS. * * NOTE! Make sure the gdt descriptor in head.S matches this if you * change anything. * * 注意! 如果你改变任何东西, 请确保 head.S 中的 gdt 描述符与此匹配. */// 初始化 GDTENTRY(gdt_table) .quad 0x0000000000000000 /* NULL descriptor */ .quad 0x0000000000000000 /* not used */ .quad 0x00cf9a000000ffff /* 0x10 kernel 4GB code at 0x00000000, __KERNEL_CS 指向的空间 */ .quad 0x00cf92000000ffff /* 0x18 kernel 4GB data at 0x00000000, __KERNEL_DS 指向的空间 */ .quad 0x00cffa000000ffff /* 0x23 user 4GB code at 0x00000000, __USER_CS 指向的空间 */ .quad 0x00cff2000000ffff /* 0x2b user 4GB data at 0x00000000, __USER_DS 指向的空间 */ .quad 0x0000000000000000 /* not used */ .quad 0x0000000000000000 /* not used */ 将 2 ~ 5 项按照二进制展开: 再按照段描述符表项内容进行分析: 相同: B0~B15, B16~B31 都是 0. 段基址全为 0. L0~L15, L16~L19 都是 1. 段长度全为 0xfffff. G 位都是 1. 段长度单位均为 4KB. D 位都是 1. 对四个段的访问指令都是 32 位指令. P 位都是 1. 四个段都在内存中. 结论: 每个段都是从 0 地址开始的整个 4G 虚拟空间, 虚拟地址到线性地址的映射保持原值不变. 不同: __KERNEL_CS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __KERNEL_DS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. __USER_CS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __USER_DS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. 页式映射&emsp;&emsp;每个进程都有其自身的页目录 PGD, 指向这个目录的指针保存在每个进程的 mm_struct 数据结构(数据结构中介绍)中. 每当一个进程运行时, 内核都要为其设置控制寄存器 CR3, 而 MMU 的硬件总是从 CR3 中取得指向当前页目录的指针. CPU 在执行过程中使用的是虚拟地址, 而 MMU 硬件在进行映射时使用的是物理地址, 这其中的计算则是通过 基本框架 中介绍的 __ps 进行计算的. 这里存在一个问题: 使用不同的页目录, 不会使程序不能连续执行吗? 答案是不会. 因为所有进程的 PGD 对系统空间的 1G 空间映射完全相同. &emsp;&emsp;在获取到 PGD 地址后获取线性地址的最高 10 位作为下标, 在这个 PGD 表项中保存着 PT 的地址. 然后将线性地址接下来的 10 位作为 PT 的下标, 获取到对应的物理页面地址. 线性地址的最低 12 位为物理页面中的偏移量, 就是线性地址在物理内存中的地址. &emsp;&emsp;在页面映射的过程中, i386 CPU 需要访问三次内存. 第一次访问 PGD, 第二次访问 PT, 第三次才是真正的目标. 所以高效的虚拟内存有赖于两方面: 高速缓存(cache)的实现. 除第一次访问需要这三步, 之后就可以在高速缓存中找到. 这个过程由硬件实现, 速度很快. 本文参考自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本框架]]></title>
    <url>%2F2018-01-23-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[i386 内存映射&emsp;&emsp;i386 CPU中采用的页式内存管理, 基本思路是：通过页目录和页表两层实现线性地址到物理地址的映射. 优点: 大多数情况下可以节省页表所占的内存空间。当页表为空时只需要将对应页目录项置为空，就可以节省对相应页表的空间. 缺点: 适用最大内存为 4G 的内存. Linux 内存映射&emsp;&emsp;由于 Linux 需要考虑不同CPU上的实现, 所有需要设计出一种通用的内存映射模型模型. Linux 内核的映射机制设计成三层, 在 i386 的页目录和页表的基础上在中间增设了一层”中间目录”. 在源码中, 页目录称为 PGD, 中间目录称为 PMD, 页表称为 PT. 三者均为数组. 相应的逻辑上也将线性地址由高到低分为四个段位, 分别作用于页目录 PGD 的下标, 中间目录 PMD 的下标, 页表 PT 的下标以及物理页面中的位移. &emsp;&emsp;对于 i386 中的段式内存映射在 Linux 内存映射时(除用来模拟80286的 VM86模式[^1]), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. i386 在 Pentium Pro 开始引入了物理地址扩充功能 PAE, 可以将地址宽度从32位上升为36位. 所以在 Linux 的内存映射模型对应到 i386 CPU时, 如果设置了 PAE 则使用三层映射, 否则跳过中间的 PMD 层次, 使用两层映射. 123456789101112131415161718192021222324// include/asm-i386/pgtable.h/* * The Linux x86 paging architecture is 'compile-time dual-mode', it * implements both the traditional 2-level x86 page tables and the * newer 3-level PAE-mode page tables. * * Linux x86 分页架构是'编译时双模式', 它实现了传统两层 x86 页表和新的三层 PAE 模式页表两种映射方式. */#ifndef __ASSEMBLY__#if CONFIG_X86_PAE // 编译时设置# include &lt;asm/pgtable-3level.h&gt; // PAE模式三层映射#else# include &lt;asm/pgtable-2level.h&gt; // 两层映射#endif#endif#define __beep() asm("movb $0x3,%al; outb %al,$0x61")#define PMD_SIZE (1UL &lt;&lt; PMD_SHIFT)#define PMD_MASK (~(PMD_SIZE-1))// 每个页目录项所指向空间的大小#define PGDIR_SIZE (1UL &lt;&lt; PGDIR_SHIFT)#define PGDIR_MASK (~(PGDIR_SIZE-1)) 12345678910111213141516171819202122// include/asm-i386/pgtable-2level.h/* * traditional i386 two-level paging structure: * 传统 i386 两层分页结构 */// PGD 数组的下标在线性地址中的起始位置, 即线性地址的 23 ~ 32 位(从 0 开始)#define PGDIR_SHIFT 22// 每个 PGD 中的指针数, 即 PGD 中页目录项的数量, i386 中指针所用空间为 4 个字节, 则 PGD 所占空间为 1024 * 4 = 4KB#define PTRS_PER_PGD 1024/* * the i386 is two-level, so we don't really have any * PMD directory physically. * * 因为 i386 是两层分页结构, 所以我们不会有真正物理上的 PMD 目录. */// PMD 数组的下标在线性地址中的起始位置, 与 PGDIR_SHIFT 相同, 即 PMD 在线性地址中不存在, 长度为 0#define PMD_SHIFT 22// 每个 PMD 中的指针数, 只有 1 个, 直接指向 PT#define PTRS_PER_PMD 1 &emsp;&emsp;32位地址意味着4G字节的虚存空间, Linux 内核将这4G字节的空间分成两个部分. 将最高的1G字节(从虚拟地址 0xC0000000 至 0xFFFFFFFF), 用于内核本身, 称为系统空间. 而将较低的3G字节(从虚拟地址 0x00000000 至 0xBFFFFFFF), 用作各个进程的用户空间, 理论上每个进程拥有独立的3G字节的用户空间. 系统空间是所有进程逻辑上共用的1G字节空间, 每一个进程通过系统调用从用户空间进入内核, 在系统空间中运行. 即每一个进程都拥有4G的虚拟空间, 较低的3G虚拟空间独立使用, 最高的1G虚拟空间与所用进程及内核共享. 这里独立的虚拟空间只是在逻辑上独立, 但是在物理上所有的进程共用3G的物理内存. &emsp;&emsp;系统空间在虚拟内存中占据最高的1G空间, 但是在物理内存中却是从最低地址(0)开始, 处于最低1G空间. 123456789101112131415161718192021222324// include/asm-i386/page.h/* * This handles the memory map.. We could make this a config * option, but too many people screw it up, and too few need * it. * * 这处理内核的内存映射. 我们可以可以将其设置为配置选项, 但是有许多人搞砸它, 并且很少需要它. * * A __PAGE_OFFSET of 0xC0000000 means that the kernel has * a virtual address space of one gigabyte, which limits the * amount of physical memory you can use to about 950MB. * * 值为 0xC0000000 的 __PAGE_OFFSET 意味着内核有 1GB 的虚拟空间, 这限制了可以内核使用的物理空间大约 950MB. * * If you want more physical memory than this then see the CONFIG_HIGHMEM4G * and CONFIG_HIGHMEM64G options in the kernel configuration. * * 如果你想要超过这些的物理内存, 请参阅内核配置中的 CONFIG_HIGHMEM4G * 和 CONFIG_HIGHMEM64G 选项 */// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define __PAGE_OFFSET (0xC0000000) 12345678// include/asm-i386/page.h// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)// 计算系统空间在虚拟内存中对应物理空间中的地址#define __pa(x) ((unsigned long)(x)-PAGE_OFFSET)// 计算系统空间在物理内存中对应虚拟空间中的地址#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET)) 123456789// include/asm-i386/processor.h/* * User space process size: 3GB (default). * * 用户空间进程大小: 3GB(默认) */// 用户空间进程大小.#define TASK_SIZE (PAGE_OFFSET) 本文参考自《Linux内核源代码情景分析》 [^1]: VM86模式 是为采用保护模式的系统提供 实模式(real-mode) 软件的兼容性, 用来在保护模式下模拟运行实模式的软件.]]></content>
      <categories>
        <category>操作系统</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[etcd gateway]]></title>
    <url>%2F2018-01-02-etcd-gateway.html</url>
    <content type="text"><![CDATA[翻译自: etcd gateway etcd gateway 是什么?etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持. 什么时候使用 etcd gateway?每个访问 etcd 的应用必须首先拥有 etcd 集群的地址. 如果是同一台服务器上的多个应用访问同一个 etcd 集群, 每个应用仍然需要知道这个 etcd 集群公布的地址. 如果这个 etcd 集群重新配置为拥有不同端点的集群, 则每个应用程序可能还需要更新其端点列表. 这种大规模的重新配置既枯燥又容易出错. etcd gateway 通过作为一个稳定的本地端点提供服务解决了这个问题. 一个典型的 etcd gateway 配置是让每一个机器运行一个监听本地端口的 gateway, 同时每一个 etcd 应用连接到这个本地 gateway. 这样在 etcd 集群重新配置时只有 gateway 需要更新它的端点配置, 而不是更新每一个应用. 总之, 为了自动传播 etcd 集群端点更改, etcd gateway 应该运行在为访问同一个 etcd 集群的多个应用程序提供服务的每台机器上. 什么时候不应该使用 etcd gateway? 提高性能gateway 不是为了提高 etcd 集群性能而设置. 它不提供缓存, watch 的合并或批处理. etcd 团队正在开发一个旨在提高集群可扩展性的缓存代理. 在集群管理系统上运行高级集群管理系统(如 Kubernetes) 本身支持服务发现, 应用程序可以使用有系统管理的 DNS 名称或虚拟 IP 地址访问 etcd 集群. 例如: kube-proxy等同于etcd网关. 启动 etcd gateway考虑一个具有以下静态端点的 etcd 集群: Name Address Hostname infra0 10.0.1.10 infra0.example.com infra1 10.0.1.11 infra1.example.com infra2 10.0.1.12 infra2.example.com 使用包含这些静态端点的命令启动etcd gateway:12$ etcd gateway start --endpoints=infra0.example.com,infra1.example.com,infra2.example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 或者, 如果使用 DNS 进行服务发现, 请考虑 DNS SRV 条目:1234$ dig +noall +answer SRV _etcd-client._tcp.example.com_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra0.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra1.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra2.example.com. 1234$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.cominfra0.example.com. 300 IN A 10.0.1.10infra1.example.com. 300 IN A 10.0.1.11infra2.example.com. 300 IN A 10.0.1.12 使用以下命令从 DNS SRV 条目获取端点启动 etcd gateway:12$ etcd gateway --discovery-srv=example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 配置选项etcd 集群–endpoints 逗号分隔的转发客户端连接的目标 etcd 集群列表 默认配置: 127.0.0.1:2379 无效示例: https://127.0.0.1:2379(gateway 不终止 TLS) –discovery-srv 通过 SRV 记录引导集群端点的 DNS 域名 默认配置: (不设置) 网络–listen-addr 接口和端口绑定接收客户端请求 默认: 127.0.0.1:23790 –retry-delay 重试连接到失败的端点之前的延迟时间 默认配置: 1m0s 无效示例: “123”(使用指定格式的时间单位) 安全–insecure-discovery 接收 SRV 记录是不安全或易受到中间人攻击的 默认配置: false –trusted-ca-file 用于 etcd 集群的客户端 TLS CA 文件路径. 用于认证端点. 默认配置: (不设置)]]></content>
      <categories>
        <category>数据库</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(3)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-3.html</url>
    <content type="text"><![CDATA[SDS 结构&emsp;&emsp;SDS 结构如下:12345678910111213141516171819202122232425262728293031323334353637struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;; &emsp;&emsp;其中: len 表示 sds 字符串的长度 alloc 表示 SDS 结构体剩余空间 flags 表示 SDS 结构体类型 buf 表示 sds 字符串&emsp;&emsp;4.0 版本将 3.0 版本时期统一的结构根据 SDS 结构体可以存储字符串的长度划分为不同的 5 种类型, 节省了内存占用的空间, 但是加大字符串操作的复杂度, 在字符串长度变动时需要改变 SDS 结构体类型. SDS 优势 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串时带来的内存重分配次数 二进制安全 兼容部分 C 字符串函数 SDS 内存分配策略 如果直接创建新结点, 会调用 sdsnewlen 函数根据指定字符串的长度创建一个新结点, 新结点没有空闲空间. 如果已有结点需要扩展空间时, 会调用 sdsMakeRoomFor 函数进行扩展.a. 已有结点 sds 字符串空间 &lt; SDS_MAX_PREALLOC, 则对 sds 字符串空间扩展一倍.b. 已有结点 sds 字符串空间 &gt;= SDS_MAX_PREALLOC(1024 * 1024), 则对 sds 字符串空间扩展 SDS_MAX_PREALLOC. SDS 会提供出一组接口使 SDS 的调用者需要释放或分配 SDS 相关的一些东西时可以使用. 同时将分配释放的宏封装起来可以在更换 SDS 分配器时不需要更改调用者中的分配器. SDS 应用 保存数据库中的字符串值. 用作缓冲区(buffer) AOF 模块中的 AOF 缓冲区. 客户端状态中的输入缓冲区. SDS 源码的思考 感觉没有必要使用 SDS_HDR_VAR, 会影响代码的可读性. sdsnewlen 中为什么把 len 和 alloc 设置相同的字符串的长度?len 表示字符串长度, alloc 表示字符串分配的空间, 这时分配空间是按照头结点长度 hdrlen + 字符串长度 initlen + null 终结符 1 进行计算, 分配给字符串的空间即为字符串长度, 所以这时的 len 等于 alloc. sdsnewlen 中为什么 initlen 为 0 时, 类型 5 不擅长?(后续关注对 SDS 的调用) sdsupdatelen 是否已经弃用?(后续关注对 SDS 的调用) sdsRemoveFreeSpace 的注释中 级联 是什么意思?(后续关注对 SDS 的调用) ssdsnew, sdsupdatelen, sdscat, sdscpy 不是二进制安全, sdscatrepr -&gt; sdscatprintf -&gt; sdscatvprintf -&gt; sdscat, sdsjoin -&gt; sdscat, 二级制不安全. 注意 sesdup 调用的 sdslen, 二进制安全的. zfree 的时间复杂度是 O(N)? sdsfree 时间复杂度是 O(N)?(后续关注对 SDS 的调用) sdscatvprintf 对于 buf 的处理为什么是将 -2 的位置置为 ‘\0’?因为在 vsnprintf(buf, buflen, fmt, cpy); 函数中, 无论真正的格式化输出字符串的长度是否超过 buflen, vsnprintf 函数都会将 buf[buflen - 1] 置为 ‘\0’, 所以如果用 -1 位置判断就会出错, 只能用最后一个可以判断的字符即 -2 位置判断. sdsfromlonglong 真的比 sdscatprintf 快吗?sdsfromlonglong 调用 sdsll2str 进行转换, sdscatprintf -&gt; sdscatvprintf -&gt; vsnprintf 函数进行转换, 使用了可变参数. 猜测 vsnprintf 底层转换与 sdsll2str 相似. 在我自己的机器上实测了一下, sdscatprintf 会比 sdsfromlonglong 慢 1us. sdscatrepr 中 ‘\\‘, ‘“‘, 为什么不和其他字符一样使用 sdscatlen?适用 SDS 中自带的测试集进行实测, 是可以实现的. sdssplitargs 如果处理类似 “ test\”aaa\” “ 会将参数识别为 test\”aaa\” 不影响吗?(后续关注对 SDS 的调用) 本文部分内容参考《Redis 设计与实现》一书.]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(2)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-2.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的实现. sds.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785/* SDSLib 2.0, 一个 C 实现的 strings 库 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;#include "sds.h"#include "sdsalloc.h"// 获取不同类型 sds 结构体大小// T = O(1)static inline int sdsHdrSize(char type)&#123; switch(type &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return sizeof(struct sdshdr5); case SDS_TYPE_8: return sizeof(struct sdshdr8); case SDS_TYPE_16: return sizeof(struct sdshdr16); case SDS_TYPE_32: return sizeof(struct sdshdr32); case SDS_TYPE_64: return sizeof(struct sdshdr64); &#125; return 0;&#125;// 根据 string 长度确定存储的 sds 类型// T = O(1)static inline char sdsReqType(size_t string_size)&#123; if(string_size &lt; 1 &lt;&lt; 5) // 最大 31 &#123; return SDS_TYPE_5; &#125; if(string_size &lt; 1 &lt;&lt; 8) // 最大 255 &#123; return SDS_TYPE_8; &#125; if(string_size &lt; 1 &lt;&lt; 16) // 最大 65535 &#123; return SDS_TYPE_16; &#125;#if(LONG_MAX == LLONG_MAX) if(string_size &lt; 1ll &lt;&lt; 32) //最大 2 ^ 32 - 1 &#123; return SDS_TYPE_32; &#125;#endif return SDS_TYPE_64; //最大 2 ^ 64 - 1&#125;// 二进制安全: 只会严格的按照二进制的数据存取. 不会妄图已某种特殊格式解析数据./* 使用 'init' 指针和 'initlen' 指定的内容创建一个新的 sds string. * 如果 'init' 是 NULL, 那么 string 将被初始化为 0 字节. * * 字符串始终为空终止(\0)(所有的 sds 字符串都是, 都总是) * 因此即使你创建一个这样的 sds 字符串: * * mystring = sdsnewlen("abc", 3); * * 你可以使用 printf() 打印字符串, 因为字符串的末尾有一个隐含的 \0. * 同时因为字符串长度保存在 sds 头结点中, 字符串是二进制安全的, \0也可以被包含在 sds 字符串中. * 也就是说 当 mystring = sdsnewlen("abc", 4); 时, \0 也是 sds 字符串中的一部分, 是二进制安全. */// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化// T = O(N)sds sdsnewlen(const void *init, size_t initlen)&#123; void *sh; sds s; // 通过长度获取存储字符串的 SDS 类型 char type = sdsReqType(initlen); /* 为了添加字符串, 空字符串经常被创建. * 使用类型 8, 因为类型 5 在这里不适用. */ if(type == SDS_TYPE_5 &amp;&amp; initlen == 0) &#123; type = SDS_TYPE_8; &#125; // 通过 SDS 类型获取 SDS 头结点大小 int hdrlen = sdsHdrSize(type); unsigned char *fp; /* 标记指针 */ sh = s_malloc(hdrlen + initlen + 1); if(!init) &#123; memset(sh, 0, hdrlen + initlen + 1); &#125; if(sh == NULL) &#123; return NULL; &#125; s = (char *)sh + hdrlen; fp = ((unsigned char *)s) - 1; // 初始化 SDS 头结点 switch(type) &#123; case SDS_TYPE_5: &#123; *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS); break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; &#125; // 如果指定初始化内容, 将它们复制到 sdshdr 的 buf 中 // T = O(N) if(initlen &amp;&amp; init) &#123; memcpy(s, init, initlen); &#125; // 字符串以 \0 结尾 s[initlen] = '\0'; // 返回 buf 部分, 而不是整个 sdshdr return s;&#125;/* 创建一个空(长度为 0) sds 字符串. * 在这种情况下字符串总是含有一个 null(\0) 终结符. */// 创建并返回一个只保存了空字符串 "" 的 sds// T = O(1)sds sdsempty(void)&#123; return sdsnewlen("", 0);&#125;/* 根据一个空终止(\0)的 C 字符串开始创建一个新的 sds 字符串. */// 也只适合 C 字符串// 根据给定字符串 init 创建一个包含同样字符串的 sds// T = O(N)sds sdsnew(const char *init)&#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;/* 复制一个 sds 字符串 */// 复制给定 sds 的副本// T = O(N)sds sdsdup(const sds s)&#123; return sdsnewlen(s, sdslen(s));&#125;/* 释放 sds. 如果 s 为空, 则不需要干什么 */// T = O(N)void sdsfree(sds s)&#123; if(s == NULL) &#123; return ; &#125; s_free((char *)s - sdsHdrSize(s[-1]));&#125;/* 设置 sds 字符串长度为通过 strlen() 获取的长度, * 因此要考虑到内容只能到达第一个 null(\0) 字符. * * 当 sds 字符串被黑客以某种手动方式入侵时, 这个函数是很有用的, * 如下例所示: * * s = sdsnew("foobar"); * s[2] = '\0'; * sdsupdatelen(s); * printf("%d\n", sdslen(s)); * * 输出将会是 2, 如果我们注释调用 sdsupdatelen() 的部分, * 输出将会是 6, 因为字符串被修改, 但是逻辑长度依然是 6. */// 更新 sds 的长度// T = O(1)void sdsupdatelen(sds s)&#123; int reallen = strlen(s); sdssetlen(s, reallen);&#125;/* 修改一个字符串, 使它立刻变成空(长度为 0). * 但是所有现有的缓冲区不会被丢弃, 而是设置为可用空间, * 以便下一次增加操作不需要预先分配可用的字节数. */// 清空 sds 字符串的内容// T = O(1)void sdsclear(sds s)&#123; sdssetlen(s, 0); s[0] = '\0';&#125;/* 在 sds 字符串的尾部扩增可用空间, 以便确保该函数的调用者在调用该函数后可以 sds 字符串末尾写入 addlen 个字节. * 再在末尾加上一个 null 终结符. * * 注意: 注意这个函数不会改变 sdslen() 返回的 sds 字符串的 *length*, * 只能改变我们拥有的可用缓冲区空间. */// 当 sds 字符串空间充足时, 直接返回, 空间不足时, 重新分配空间, 设置 sds 头结点, 字符串内容// T = O(N)sds sdsMakeRoomFor(sds s, size_t addlen)&#123; void *sh; void *newsh; // 获取当前空闲空间大小 size_t avail = sdsavail(s); size_t len; size_t newlen; char type; // 获取当前 sds 的类型 char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; /* 如果空间足够, 立刻返回 */ if(avail &gt;= addlen) &#123; return s; &#125; len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); newlen = (len + addlen); // 如果需要新分配给 sds 字符串的空间的长度小于 sds 最大预分配给 sds 字符串的空间长度 if(newlen &lt; SDS_MAX_PREALLOC) &#123; newlen *= 2; &#125; else &#123; // 如果需要新分配给 sds 字符串的空间的长度大于最大预分配给 sds 字符串的空间长度时, 每次增长最大预分配给 sds 字符串的空间长度 newlen += SDS_MAX_PREALLOC; &#125; // 根据需要新分配给 sds 字符串的空间的长度计算新的 sds 需要的类型 type = sdsReqType(newlen); /* 不要使用类型 5: 当用户扩增字符串时, 由于类型 5 不能记住空闲空间, * 因此调用 sdsMakeRoomFor() 时必须进行扩增操作 */ if(type == SDS_TYPE_5) &#123; type = SDS_TYPE_8; &#125; hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; // 如果新类型与原来的类型相同, 重新分配新长度的 sds 并将原来 sds 字符串(包括头结点和 null 终结符)拷贝到新空间. newsh = s_realloc(sh, hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; /* 由于头结点大小改变, 需要将字符串向前移动, 不能直接使用 realloc */ // 如果新类型与原来的类型不同, 重新分配新类型新长度的 sds newsh = s_malloc(hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; // 将原来的 sds 字符串拷贝到新 sds 中 memcpy((char *)newsh + hdrlen, s, len + 1); // 释放原来的 sds s_free(sh); s = (char *)newsh + hdrlen; // 设置新 sds 类型, 长度 s[-1] = type; sdssetlen(s, len); &#125; // 更新分配空间大小 sdssetalloc(s, newlen); return s;&#125;/* 为了使 sds 字符串结尾没有可用空间, 对其重新分配空间. * 剩下的 sds 字符串没有改变, 但是下一个级联操作将需要重新分配空间. * * 在被调用后, 通过这个函数的 sds 字符串不能变的更长, 所有的指针必须被调用返回的新指针替换 */// 将 sds 字符串的空间缩短到字符串自身的长度.// T = O(N)sds sdsRemoveFreeSpace(sds s)&#123; void *sh; void *newsh; char type; char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; size_t len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); type = sdsReqType(len); hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; newsh = s_realloc(sh, hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; newsh = s_malloc(hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; memcpy((char *)newsh + hdrlen, s, len + 1); s_free(sh); s = (char *)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); &#125; sdssetalloc(s, len); return s;&#125;/* 返回指定 sds 字符串分配总空间的大小 * 包括: * 1) 指针前的 sds 头结点. * 2) 字符串. * 3) 结尾若干可用缓冲区. * 4) 隐含的 null 终结符. */// 获取分配给 sds 的总空间// T = O(1)size_t sdsAllocSize(sds s)&#123; size_t alloc = sdsalloc(s); return sdsHdrSize(s[-1]) + alloc + 1;&#125;/* 返回 sds 真实的分配总空间(通常, sds 字符串作为字符串缓冲区开始的参考) */// 获取 sds 总空间的指针// T = O(1)void *sdsAllocPtr(sds s)&#123; return (void *)(s = sdsHdrSize(s[-1]));&#125;/* 根据 'incr' 增加 sds 字符串长度, 并减小字符串左侧可用空间. * 同时在新的字符串结尾设置 null 终结符. * * 使用这个函数是为了在用户调用 sdsMakeRoomFor() 函数后, 在当前字符串的结尾写入一些东西, * 最后需要设置字符串新长度是修改字符串的长度. * * 注意: 可以使用负增量来从右侧缩减字符串. * * 用法示例: * * 使用以下模式调用 sdsIncrLen() 和 sdsMakeRoomFor(), 可以将字符串直接从内核挂载连接到 * sds 字符串末尾, 不需要复制到中间缓冲区. * * oldlen = sdslen(s); * s = sdsMakeRoomFor(s, BUFFER_SIZE); * nread = read(fd, s + oldlen, BUFFER_SIZE); * ... 检查 nread &lt;= 0 并处理它 ... * sdsIncrLen(s, nread); */// 修改 sds 字符串长度// T = O(1)void sdsIncrLen(sds s, int incr)&#123; unsigned char flags = s[-1]; size_t len; // 修改 sds 字符串长度 switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char oldlen = SDS_TYPE_5_LEN(flags); assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr))); *fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS); len = oldlen + incr; break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; default: len = 0; /* 只是为了避免编译警告 */ &#125; s[len] = '\0';&#125;/* 将 sds 字符串的长度增长到指定长度. 增长的长度初始化为 0. * * 如果指定的长度比当前 sds 字符串的短, 则不执行任何操作. */// 增长字符串, 并将增加的部分置为 0// T = O(N)sds sdsgrowzero(sds s, size_t len)&#123; size_t curlen = sdslen(s); if(len &lt;= curlen) &#123; return s; &#125; // 扩增 sds 字符串分配的空间 s = sdsMakeRoomFor(s, len - curlen); if(s == NULL) &#123; return NULL; &#125; /* 确保添加的区域不包含垃圾 */ // 将添加区域初始化为 0 memset(s + curlen, 0, (len - curlen + 1)); sdssetlen(s, len); return s;&#125;/* 在 sds 字符串 's' 后添加二进制安全的 len 个字节的 't' 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加长度为 len 的字符串// T = O(N)sds sdscatlen(sds s, const void *t, size_t len)&#123; size_t curlen = sdslen(s); // 空间足够直接返回, 空间不足获取空间 s = sdsMakeRoomFor(s, len); if(s == NULL) &#123; return NULL; &#125; memcpy(s + curlen, t, len); sdssetlen(s, curlen + len); s[curlen + len] = '\0'; return s;&#125;/* 在 sds 字符串后添加指定以 null 终止的 C 字符串. * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定以 null 终止的 C 字符串.// T = O(N)sds sdscat(sds s, const char *t)&#123; return sdscatlen(s, t, strlen(t));&#125;/* 在现有 sds 字符串后添加指定 sds 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定 sds 字符串.// T = O(N)sds sdscatsds(sds s, const sds t)&#123; return sdscatlen(s, t, sdslen(t));&#125;/* 破坏性的修改 sds 字符串来保存指定的长度为 'len' 字节的二进制安全的字符串 't'. */// 拷贝二进制安全字符串 't' 到 sds 字符串中.// T = O(N)sds sdscpylen(sds s, const char *t, size_t len)&#123; // 查看字符串空间是否足够 if(sdsalloc(s) &lt; len) &#123; s = sdsMakeRoomFor(s, len - sdslen(s)); if(s == NULL) &#123; return NULL; &#125; &#125; memcpy(s, t, len); s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 类似 sdscpylen() 但是 't' 必须是一个以 null 终结的字符串, 以便通过 strlen() 获取字符串长度. */// 对 C 字符串进行拷贝// T = O(N)sds sdscpy(sds s, const char *t)&#123; return sdscpylen(s, t, strlen(t));&#125;/* 帮助 sdscatlonglong() 进行实际的数字 -&gt; 字符串的转换. * 's' 必须指向一个最少 SDS_LLSTR_SIZE 字节的字符串空间. * * 这个函数返回存储在 's' 中的以 null 终结的字符串表示的长度 */// long long 类型转换为 string 类型// T = O(N)#define SDS_LLSTR_SIZE 21int sdsll2str(char *s, long long value)&#123; char *p; char aux; unsigned long long v; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ // 将 long long 反转存储在字符串中 v = (value &lt; 0) ? -value : value; p = s; // T = O(N) do &#123; // 只能适用于 C 语言字符集 *p++ = '0' + (v % 10); v /= 10; &#125;while(v); if(value &lt; 0) &#123; *p++ = '-'; &#125; /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ // 将反转的字符串反转就是 long long 的顺序字符串表示 // T = O(N) p --; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 与 sdsll2str() 相同, 但是这个函数是针对 unsigned long long 类型. */// unsigned long long 类型转换为 string 类型// T = O(N)int sdsull2str(char *s, unsigned long long v)&#123; char *p; char aux; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ p = s; do &#123; *p++ = '0' + (v % 10); v /= 10; &#125;while(v); /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 根据一个 long long 值创建一个 sds 字符串. 这要比以下方式快很多: * * sdscatprintf(sdsempty(), "%lld\n", value); */// long long 类型转换为 sds 类型// T = O(N)sds sdsfromlonglong(long long value)&#123; char buf[SDS_LLSTR_SIZE]; int len = sdsll2str(buf, value); return sdsnewlen(buf, len);&#125;/* 类似 sdscatprintf() 但是获取的是 va_list 而不是可变参数 */// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// T = O(N)sds sdscatvprintf(sds s, const char *fmt, va_list ap)&#123; va_list cpy; char staticbuf[1024]; char *buf = staticbuf; char *t; size_t buflen = strlen(fmt) * 2; /* 我们尝试开始使用静态缓冲区来提升速度. * 如果不可能, 我们回到使用堆分配. */ if(buflen &gt; sizeof(staticbuf)) &#123; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; &#125; else &#123; buflen = sizeof(staticbuf); &#125; /* 每次当我们使用当前缓冲区大小无法适应字符串时, 尝试使用缓冲区的两倍大小. */ while(1) &#123; buf[buflen - 2] = '\0'; va_copy(cpy, ap); vsnprintf(buf, buflen, fmt, cpy); va_end(cpy); if(buf[buflen - 2] != '\0') &#123; // 缓冲区大小无法适应字符串. if(buf != staticbuf) &#123; // 在堆上分配的空间, 释放 s_free(buf); &#125; // 重新分配两倍大小的空间 buflen *= 2; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; continue; &#125; // 直到适应字符串 break; &#125; /* 最后将获得的字符串添加到 sds 字符串并返回它. */ // 将字符串添加到 sds 字符串后 t = sdscat(s, buf); if(buf != staticbuf) &#123; s_free(buf); &#125; return t;&#125;/* 将使用类似 printf 指定格式获得的字符串添加到 sds 字符串. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("Sum is: "); * s = sdscatprintf(s, "%d+%d = %d", a, b, a + b); * * 通常, 你需要使用类似 printf 格式从头创建一个字符串. * 当你需要时, 只需要使用 sdsempty() 作为字符串: * * s = sdscatprintf(sdsempty(), "... your format ...", args); */// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串// T = O(N)sds sdscatprintf(sds s, const char *fmt, ...)&#123; va_list ap; char *t; va_start(ap, fmt); t = sdscatvprintf(s, fmt, ap); va_end(ap); return t;&#125;/* 这个函数类似 sdscatprintf, 但是要快很多, 它没有依靠 libc 中通常很慢的 sprintf() 系列函数. * 此外, 将 sds 字符串作为被连接新数据直接处理提供了性能改进. * * 然而, 这个函数只处理类似 printf 的格式说明符的不兼容子集. * * %s - C 字符串 * %S - SDS 字符串 * %i - 有符号整形 * %I - 64 位有符号整形(long long, int64_t) * %u - 无符号整形 * %U - 64 位无符号整形(unsigned long long, uint64_t) * %% - % 字符 */// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串// T = O(N)sds sdscatfmt(sds s, char const *fmt, ...)&#123; size_t initlen = sdslen(s); const char *f = fmt; int i; va_list ap; // 开始遍历参数 va_start(ap, fmt); f = fmt; /* 遍历格式化输出字符串中格式说明符下一个要处理的字节. */ i = initlen; /* 写入目标字符串下一个字节的位置. */ // 遍历格式化输出字符串 while(*f) &#123; char next, *str; size_t l; long long num; unsigned long long unum; /* 确保至少有一个字节的空间 */ // 确保当该字符不是说明符时有可以存储的 1 字节空间 if(sdsavail(s) == 0) &#123; s = sdsMakeRoomFor(s, 1); &#125; // 处理有可能为说明符的情况, 即 *f 为 %. switch(*f) &#123; case '%': next = *(f + 1); f++; switch(next) &#123; case 's': case 'S': str = va_arg(ap, char *); l = (next == 's') ? strlen(str) : sdslen(str); // 空间不足时扩容 if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; // 将字符串添加到 sds 字符串后 memcpy(s + i, str, l); sdsinclen(s, l); i += l; break; case 'i': case 'I': if(next == 'i') &#123; num = va_arg(ap, int); &#125; else &#123; num = va_arg(ap, long long); &#125; // 将 long long 转换为字符串 char buf[SDS_LLSTR_SIZE]; l = sdsll2str(buf, num); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; case 'u': case 'U': if(next == 'u') &#123; unum = va_arg(ap, unsigned int); &#125; else &#123; unum = va_arg(ap, unsigned long long); &#125; char buf[SDS_LLSTR_SIZE]; l = sdsull2str(buf, unum); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; default: /* 处理 %%, 通常为 %&lt;unknown&gt;. */ s[i++] = next; sdsinclen(s, 1); break; &#125; break; // 处理不是 % 开头的可能为说明符的情况 default: s[i++] = *f; sdsinclen(s, 1); break; &#125; f++; &#125; va_end(ap); /* 添加 null 终结符 */ s[i] = '\0'; return s;&#125;/* 从字符串左边和右边分别删除 sds 字符串的一部分, 删除的字符串为在 'cset' 中找到的字符组成的连续字符, * 'cset' 字符串是一个 null 终结的 C 字符串. * * 在调用这个函数后, 被修改 sds 字符串不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("AA...AA.a.aa.aHellWorld :::"); * s = sdstrim(s, "Aa. :"); * printf("%s\n", s); * * 只输出 "Hello World" */// 删除 sds 字符串首尾在 'cset' 中存在的字符串// T = O(M*N)，M 为 SDS 长度, N 为 cset 长度sds sdstrim(sds s, const char *cset)&#123; char *start; char *end; char *sp; char *ep; size_t len; sp = start = s; ep = end = s + sdslen(s) - 1; // 从头向尾遍历 // T = O(M * N) while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) &#123; sp++; &#125; // 从尾向头遍历 while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) &#123; ep--; &#125; len = (sp &gt; ep) ? 0 : ((ep - sp) + 1); // 移动剩余部分 if(s != sp) &#123; memmove(s, sp, len); &#125; s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串. * * start 和 end 可以是负数, 其中 -1 表示字符串的最后一个字符, -2 表示倒数第二个字符, 等等. * * 间隔是包含的, 因此开始和结束字符是生成字符串的一部分. * * 字符串就地被修改. * * 例如: * * s = sdsnew("Hello World"); * sdsrange(s, 1, -1); // =&gt; "ello World" */// 将 sds 字符串缩短为 'start' 到 'end' 之间, 闭区间// T = O(N)void sdsrange(sds s, int start, int end)&#123; size_t newlen; size_t len = sdslen(s); if(len == 0) &#123; return ; &#125; // 如果指定 'start' 是负数 if(start &lt; 0) &#123; start = len + start; if(start &lt; 0) &#123; // 赋值负数超出字符串范围的 start 为 0 start = 0; &#125; &#125; if(end &lt; 0) &#123; end = len + end; if(end &lt; 0) &#123; end = 0; &#125; &#125; // 计算 start 和 end 指定子串的长度, 包含 start 和 end newlen = (start &gt; end) ? 0 : (end - start) + 1; if(newlen != 0) &#123; if(start &gt;= (signed)len) &#123; newlen = 0; &#125; else if(end &gt;= (signed)len) &#123; end = len - 1; newlen = (start &gt; end) ? 0 : (end - start) + 1; &#125; &#125; else &#123; // 这里 newlen = 0, 一定进入下一个 if start = 0; &#125; // 清楚 start 前的字符 if(start &amp;&amp; newlen) &#123; memmove(s, s + start, newlen); &#125; // newlen 为 0 时, 清空字符串. // 即为 s[newlen] = '\0'; s[newlen] = 0; sdssetlen(s, newlen);&#125;/* 对 sds 字符串 's' 的每一个字符调用 tolower() */// 将 sds 字符串 's' 中的字母转换为小写字母// T = O(N)void sdstolower(sds s)&#123; int len = sdslen(s); int j; // 转换每一个字符 for(j = 0; j &lt; len; j++) &#123; s[j] = tolower(s[j]); &#125;&#125;/* 对 sds 字符串 's' 的每一个字符调用 sdstoupper() */// 将 sds 字符串 's' 中的字母转换为大写字母// T = O(N)void sdstoupper(sds s)&#123; int len = sdslen(s); int j; for(j = 0; j &lt; len; j++) &#123; s[j] = toupper(s[j]); &#125;&#125;/* 使用 memcmp() 比较两个 sds 字符串 s1 和 s2. * * 返回值: * * 如果 s1 &gt; s2, 返回正数. * 如果 s1 &lt; s2, 返回负数. * 如果s1和s2是完全相同的二进制字符, 则为0. * * 如果两个字符串共享完全相同的前缀, 但是其中的一个长度更长, 则较长的字符串被认为大于较小的字符串. */// 比较两个字符串// T = O(N)int sdscmp(const sds s1, const sds s2)&#123; size_t l1; size_t l2; size_t minlen; int cmp; l1 = sdslen(s1); l2 = sdslen(s2); // 获取最小长度 minlen = (l1 &lt; l2) ? l1 : l2; // 比较最小长度空间中的字符 cmp = memcmp(s1, s2, minlen); if(cmp == 0) &#123; // 最小长度空间中字符相同, 返回长度的差值, 为 0 则两个字符串相同 return l1 - l2; &#125; // 返回最小长度空间中不同字符的差 return cmp;&#125;/* 使用分隔符 'sep' 分割 's'. 返回 sds 字符串数组. * *count 将会被指针设置为 sds 的数量. * * 内存溢出, 空字符串, 空分隔符将会返回 NULL. * * 注意: 'sep' 可以是一个由多个字符组成的分隔符. 例如: * sdssplit("foo_-_bar", "_-_"); * 将返回 "foo" 和 "bar" 两个元素. * * 这个函数的版本是二级制安全的, 但是需要参数长度. * sdssplit() 是只针对 NULL 终结的字符串的相同函数. */// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾// T = O(N ^ 2)sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count)&#123; int elements = 0; int slots = 5; int start = 0; int j; sds *tokens; if(seplen &lt; 1 || len &lt; 0) &#123; return NULL; &#125; tokens = s_malloc(sizeof(sds) * slots); if(tokens == NULL) &#123; return NULL; &#125; if(len == 0) &#123; *count = 0; return tokens; &#125; // 遍历字符串 // T = O(N ^ 2) for(j = 0; j &lt; (len - (seplen - 1)), j++) &#123; /* 确保下一个元素和最后一个元素有空间 */ if(slots &lt; elements + 2) &#123; sds *newtokens; slots *= 2; newtokens = s_realloc(tokens, sizeof(sds) * slots); if(newtokens == NULL) &#123; goto cleanup; &#125; tokens = newtokens; &#125; /* 搜索分隔符 */ // T = O(N) if((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) &#123; // 找到分隔符 tokens[elements] = sdsnewlen(s + start, j - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; start = j + seplen; // 麻蛋, -1 是因为 for 循环自己加了 1 j = j + seplen - 1; /* 跳过分隔符 */ &#125; &#125; /* 添加最后一个元素. 我们确定在标记数组中存在空间. */ tokens[elements] = sdsnewlen(s + start, len - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; *count = elements; return tokens; // 错误处理 cleanup: &#123; int i; // 清理空间 for(i = 0; i &lt; elements; i++) &#123; sdsfree(tokens[i]); &#125; s_free(tokens); *count = 0; return NULL; &#125;&#125;/* 释放 sdssplitlen() 返回的结果, 或者当 'tokens' 为 NULL 时什么都不做. */// 释放分割的结果// T = O(N)void sdsfreesplitres(sds *tokens, int count)&#123; if(!tokens) &#123; return ; &#125; while(count--) &#123; sdsfree(tokens[count]); &#125; s_free(tokens);&#125;/* 为 sds 字符串 's' 添加将所有无法打印的字符(使用 isprint() 测试) * 变成 "\n\r\a..." 或 "\x&lt;hex-number&gt;" 转移的形式组成的转义字符串的表示. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. */// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.// T = O(N)sds sdscatrepr(sds s, const char *p, size_t len)&#123; s = sdscatlen(s, "\"", 1); while(len--) &#123; switch(*p) &#123; case '\\': case '"': s = sdscatprintf(s, "\\%c", *p); break; // case '\\': s = sdscatlen(s, "\\\\", 2); break; // case '"': s = sdscatlen(s, "\\\"", 2); break; case '\n': s = sdscatlen(s, "\\n", 2); break; case '\r': s = sdscatlen(s, "\\r", 2); break; case '\t': s = sdscatlen(s, "\\t", 2); break; case '\a': s = sdscatlen(s, "\\a", 2); break; case '\b': s = sdscatlen(s, "\\b", 2); break; default: if(isprint(*p)) &#123; s = sdscatprintf(s, "%c", *p); &#125; else &#123; s = sdscatprintf(s, "\\x%02x", (unsigned char) *p); &#125; break; &#125; p++; &#125; return sdscatlen(s, "\"", 1);&#125;/* sdssplitargs() 的辅助函数, 如果 'c' 是有效的十六进制, 则返回非零. */// 测试字符是否为十六进制字符// T = O(1)int is_hex_digit(char c)&#123; return (c &gt;= '0' &amp;&amp; c &lt;='9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F');&#125;/* sdssplitargs() 的辅助函数, 将十六进制数转换为从 0 到 15 的整数. */// 将十六进制转换为从 0 到 15 的整数.// T = O(1)int hex_digit_to_int(char c)&#123; switch(c) &#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; default: return 0; &#125;&#125;/* 把一行文本切割成多个参数, 每个参数可以有以下的类编程语言 REPL 格式: * * foo bar "newline are suported\n" and "\xff\x00otherstuff" * * 参数的数量存储在 *argc 中, 这个函数会返回一个 sds 数组. * * 调用者应该调用 sdsfreesplitres() 函数释放生成的 sds 数组. * * 注意: sdscatrepr() 可以将一个字符串转换为一个带引号的字符串, * 相同格式的字符串可以被 sdssplitargs() 函数解析. * * 即使当输入出现空字符串, 函数仍然会将成功处理的字符串返回. * 或当输入不对应的引号或后引号后面没有跟空格例如: "foo"bar 或 "foo' 时返回 NULL. */// * 这个函数主要用于 config.c 中对配置文件进行分析, 将字符串按照 REPL 格式切分成一个 sds 参数数组.// * // * 例如:// * sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");// * 会得出:// * arr[0] = "timeout"// * arr[1] = "10086"// * arr[2] = "port"// * arr[3] = "123321"// * T = O(N)sds *sdssplitargs(const char *line, int *argc)&#123; const char *p = line; char *current = NULL; char **vector = NULL; *argc = 0; while(1) &#123; // 遇到空格跳过 // T = O(N) while(*p &amp;&amp; isspace(*p)) &#123; p++; &#125; if(*p) &#123; /* 获取一个标记 */ int inq = 0; /* 如果遇到引号设置为 1 */ int insq = 0; /* 如果遇到单引号设置为 1 */ // 当前参数结束了设置为 1 int done = 0; // 获取一个 sds 存储参数 if(current == NULL) &#123; current = sdsempty(); &#125; // T = O(N) while(!done) &#123; if(inq) &#123; // 前面遍历过前引号 if(*p == '\\' &amp;&amp; *(p + 1) == 'x' &amp;&amp; is_hex_digit(*(p + 2)) &amp;&amp; is_hex_digit(*(p + 3))) &#123; // 遇到十六进制表示, 转换为字符 unsigned char byte; byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3)); current = sdscatlen(current, (char *)&amp;byte, 1); p += 3; &#125; else if(*p == '\\' &amp;&amp; *(p + 1)) &#123; // 遇到转义字符, 转换为对应的字符 char c; p++; switch(*p) &#123; case 'n': c = '\n'; break; case 'r': c = '\r'; break; case 't': c = '\t'; break; case 'b': c = '\b'; break; case 'a': c = '\a'; break; default: c = *p; break; &#125; current = sdscatlen(current, &amp;c, 1); &#125; else if(*p == '"') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; // 不是执行错误处理代码 goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ // 没有后引号就结束 goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else if(insq) &#123; // 前面遍历过前单引号 if(*p == '\\' &amp;&amp; *(p + 1) == '\'') &#123; // 遇到转义的单引号 p++; current = sdscatlen(current, "'", 1); &#125; else if(*p == '\'') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后单引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else &#123; // 不在引号内的字符 switch(*p) &#123; // 分隔参数的符号 case ' ': case '\n': case '\r': case '\t': case '\0': done = 1; break; // 前引号 case '"': inq = 1; break; // 后引号 case '\'': insq = 1; break; // 普通字符 default: current = sdscatlen(current, p, 1); break; &#125; &#125; // 指针向后移动 if(*p) &#123; p++; &#125; &#125; /* 在 vector 中添加标记 */ // 将参数添加到参数数组 vector 中 // T = O(N) vector = s_realloc(vector, ((*argc) + 1) * sizeof(char *)); vector[*argc] = current; (*argc)++; current = NULL; &#125; else &#123; /* 即使是空字符串仍然返回一些内容, 不会返回 NULL */ // 字符串遍历结束 if(vector == NULL) &#123; vector = s_malloc(sizeof(void *)); &#125; return vector; &#125; &#125; err: &#123; // 出错时, 清理内存空间, 返回 NULL while((*argc)--) &#123; sdsfree(vector[*argc]); &#125; s_free(vector); if(current) &#123; sdsfree(current); &#125; *argc = 0; return NULL; &#125;&#125;/* 将 sds 字符串中所有 'from' 字符串中指定的字符集出现的字符替换为 'to' 数组中相应位置的字符. * * 例如: * sdsmapchars(mystring, "ho", "01", 2); * 将具有将字符串 "hello" 转换为 "0ell1" 的效果. * * 这个函数返回 sds 字符串指针, 它总是与输入指针大小相同, 因此不需要调整大小. */// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符// T = O(M * N) M 为 setlen 的长度, N 为 s 的长度sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen)&#123; size_t j; size_t i; size_t l = sdslen(s); for(j = 0; j &lt; l; j++) &#123; for(i = 0; i &lt; setlen; i++) &#123; if(s[j] == from[i]) &#123; s[j] = to[i]; break; &#125; &#125; &#125; return s;&#125;/* 使用指定分隔符(C 字符串)将一个 C 字符串数组组合成一个 sds 字符串. * 以 sds 字符串形式返回结果 */// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全// T = O(N)sds sdsjoin(char **argv, int argc, char *sep)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscat(join, argv[j]); if(j != argc - 1) &#123; join = sdscat(join, sep); &#125; &#125; return join;&#125;/* 类似 sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串. */// T = O(N)sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscatsds(join, argv[j]); if(j != argc - 1) &#123; join = sdscatlen(join, sep, seplen); &#125; &#125; return join;&#125;/* 低等级函数作为 API 暴露给用户使用 *//* 封装被 SDS 使用的分配器. * 注意: 为了避免函数调用过程的付出开销, SDS 实际上只使用 sdsalloc.h 中定义的宏. * 这里, 我们定义这些封装只有在当链接 SDS 的程序想要接触 SDS 构件的时候使用, 即使它们使用的是不同的分配器. */// 在 SDS 的调用者需要释放或申请 SDS 相关的一些东西时可以使用这三个程序.// 将分配释放的宏封装起来应该是为了在更换 SDS 分配器时不需要更改调用者中的分配器.void *sds_malloc(size_t size)&#123; return s_malloc(size);&#125;void *sds_realloc(void *ptr, size_t size)&#123; return s_realloc(ptr, size);&#125;void sds_free(void *ptr)&#123; s_free(ptr);&#125;// 测试代码#if defined(SDS_TEST_MAIN)#include &lt;stdio.h&gt;#include "testhelp.h"#include "limits.h"#define UNUSED(x) (void)(x)int sdsTest(void) &#123; &#123; sds x = sdsnew("foo"), y; test_cond("Create a string and obtain the length", sdslen(x) == 3 &amp;&amp; memcmp(x,"foo\0",4) == 0) sdsfree(x); x = sdsnewlen("foo",2); test_cond("Create a string with specified length", sdslen(x) == 2 &amp;&amp; memcmp(x,"fo\0",3) == 0) x = sdscat(x,"bar"); test_cond("Strings concatenation", sdslen(x) == 5 &amp;&amp; memcmp(x,"fobar\0",6) == 0); x = sdscpy(x,"a"); test_cond("sdscpy() against an originally longer string", sdslen(x) == 1 &amp;&amp; memcmp(x,"a\0",2) == 0) x = sdscpy(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"); test_cond("sdscpy() against an originally shorter string", sdslen(x) == 33 &amp;&amp; memcmp(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0",33) == 0) sdsfree(x); x = sdscatprintf(sdsempty(),"%d",123); test_cond("sdscatprintf() seems working in the base case", sdslen(x) == 3 &amp;&amp; memcmp(x,"123\0",4) == 0) sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX); test_cond("sdscatfmt() seems working in the base case", sdslen(x) == 60 &amp;&amp; memcmp(x,"--Hello Hi! World -9223372036854775808," "9223372036854775807--",60) == 0) printf("[%s]\n",x); sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX); test_cond("sdscatfmt() seems working with unsigned numbers", sdslen(x) == 35 &amp;&amp; memcmp(x,"--4294967295,18446744073709551615--",35) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," x"); test_cond("sdstrim() works when all chars match", sdslen(x) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," "); test_cond("sdstrim() works when a single char remains", sdslen(x) == 1 &amp;&amp; x[0] == 'x') sdsfree(x); x = sdsnew("xxciaoyyy"); sdstrim(x,"xy"); test_cond("sdstrim() correctly trims characters", sdslen(x) == 4 &amp;&amp; memcmp(x,"ciao\0",5) == 0) y = sdsdup(x); sdsrange(y,1,1); test_cond("sdsrange(...,1,1)", sdslen(y) == 1 &amp;&amp; memcmp(y,"i\0",2) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,-1); test_cond("sdsrange(...,1,-1)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,-2,-1); test_cond("sdsrange(...,-2,-1)", sdslen(y) == 2 &amp;&amp; memcmp(y,"ao\0",3) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,2,1); test_cond("sdsrange(...,2,1)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,100); test_cond("sdsrange(...,1,100)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,100,100); test_cond("sdsrange(...,100,100)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); sdsfree(x); x = sdsnew("foo"); y = sdsnew("foa"); test_cond("sdscmp(foo,foa)", sdscmp(x,y) &gt; 0) sdsfree(y); sdsfree(x); x = sdsnew("bar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) == 0) sdsfree(y); sdsfree(x); x = sdsnew("aar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) &lt; 0) sdsfree(y); sdsfree(x); x = sdsnewlen("\a\n\0foo\r",7); y = sdscatrepr(sdsempty(),x,sdslen(x)); test_cond("sdscatrepr(...data...)", memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0) &#123; unsigned int oldfree; char *p; int step = 10, j, i; sdsfree(x); sdsfree(y); x = sdsnew("0"); test_cond("sdsnew() free/len buffers", sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0); /* Run the test a few times in order to hit the first two * SDS header types. */ for (i = 0; i &lt; 10; i++) &#123; int oldlen = sdslen(x); x = sdsMakeRoomFor(x,step); int type = x[-1]&amp;SDS_TYPE_MASK; test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen); if (type != SDS_TYPE_5) &#123; test_cond("sdsMakeRoomFor() free", sdsavail(x) &gt;= step); oldfree = sdsavail(x); &#125; p = x+oldlen; for (j = 0; j &lt; step; j++) &#123; p[j] = 'A'+j; &#125; sdsIncrLen(x,step); &#125; test_cond("sdsMakeRoomFor() content", memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0); test_cond("sdsMakeRoomFor() final length",sdslen(x)==101); sdsfree(x); &#125; &#125; test_report() return 0;&#125;#endif#ifdef SDS_TEST_MAINint main(void) &#123; return sdsTest();&#125;#endif]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(1)]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDS-1.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的头文件. SDS 的头文件包括两个文件: sds.h 和 sdsalloc.h. sds.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/* SDSLib 2.0, 一个 C 实现的 strings 库 */#ifndef __SDS_H#define __SDS_H// 最大预分配给 sds 字符串的空间长度(分配给 sds 字符串的空间最大增长长度)#define SDS_MAX_PREALLOC (1024 * 1024)#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdint.h&gt;// 类别名, 用于指向 sdshdr 的 buf 属性typedef char *sds;// lsb 最低有效位/* 注意: sdshdr5 是永远不会被使用的, 它只是被我们用来直接获取 flags 标记字节. * 这里是记录 SDS strings类型 5 的布局. */struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3// 麻蛋, C 实现的多态... 吓尿了... // 但是感觉在代码中突然冒出一个 sh 会影响程序的可读性.#define SDS_HDR_VAR(T, s) struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)))#define SDS_HDR(T, s) ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))#define SDS_TYPE_5_LEN(f) ((f) &gt;&gt; SDS_TYPE_BITS)// 获取 sds 实际保存的字符串的长度// T = O(1)static inline size_t sdslen(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;len; &#125; return 0;&#125;// 获取 sds 分配给 sds 字符串的空间的长度与保存的字符串长度之差, 即空闲空间// T = O(1)static inline size_t sdsavail(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125;// 设置 sds 实际保存的字符串长度// T = O(1)static inline void sdssetlen(sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len = newlen; break; &#125;&#125;// 设置 sds 实际保存字符串增加的长度// T = O(1)static inline void sdsinclen(sds s, size_t inc)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char newlen = SDS_TYPE_5_LEN(flags) + inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); //=============================感觉没有必要呀 &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len += inc; break; &#125;&#125;/* sdsalloc() = sdsavail() + sdslen() */// 获取 sds 分配给 sds 字符串的空间的长度// T = O(1)static inline size_t sdsalloc(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;alloc; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;alloc; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;alloc; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;alloc; &#125; return 0;&#125;// 设置分配给 sds 字符串的空间长度// T = O(1)static inline void sdssetalloc(const sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: /* 不需要做什么事, 这个类型没有分配给 sds 字符串的空间信息 */ break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;alloc = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;alloc = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;alloc = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;alloc = newlen; break; &#125;&#125;sds sdsnewlen(const void *init, size_t initlen); // 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化sds sdsnew(const char *init); // 根据给定字符串 init 创建一个包含同样字符串的 sdssds sdsempty(void); // 创建并返回一个只保存了空字符串 "" 的 sdssds sdsdup(const sds s); // 复制给定 sds 的副本void sdsfree(sds s); // 释放 sds. 如果 s 为空, 则不需要干什么sds sdsgrowzero(sds s, size_t len); // 增长字符串, 并将增加的部分置为 0sds sdscatlen(sds s, const void *t, size_t len); // 在 sds 字符串后添加长度为 len 的字符串sds sdscat(sds s, const char *t); // 在 sds 字符串后添加指定以 null 终止的 C 字符串.sds sdscatsds(sds s, const sds t); // 在 sds 字符串后添加指定 sds 字符串.sds sdscpylen(sds s, const char *t, size_t len); // 拷贝二进制安全字符串 't' 到 sds 字符串中.sds sdscpy(sds s, const char *t); // 对 C 字符串进行拷贝sds sdscatvprintf(sds s, const char *fmt, va_list ap); // 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串#ifdef __GNUC__sds sdscatprintf(sds s, const char *fmt, ...) __attribute__((format(printf, 2, 3)));#elsesds sdscatprintf(sds s, const char *fmt, ...);#endifsds sdscatfmt(sds s, char const *fmt, ...); // 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串sds sdstrim(sds s, const char *cset); // 删除 sds 字符串首尾在 'cset' 中存在的字符串void sdsrange(sds s, int start, int end); //将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.void sdsupdatelen(sds s); // 更新 sds 的长度void sdsclear(sds s); // 清空 sds 字符串的内容int sdscmp(const sds s1, const sds s2); // 比较两个字符串sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count); // 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾void sdsfreesplitres(sds *tokens, int count); // 释放分割的结果void sdstolower(sds s); // 将 sds 字符串 's' 中的字母转换为小写字母void sdstoupper(sds s); // 将 sds 字符串 's' 中的字母转换为大写字母sds sdsfromlonglong(long long value); // long long 类型转换为 sds 类型sds sdscatrepr(sds s, const char *p, size_t len); // 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.sds *sdssplitargs(const char *line, int *argc); // 将字符串按照 REPL 格式切分成一个 sds 参数数组sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen); // 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符sds sdsjoin(char **argv, int argc, char *sep); // 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen); // 类似sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串/* 低等级函数作为 API 暴露给用户使用 */sds sdsMakeRoomFor(sds s, size_t addlen);void sdsIncrLen(sds s, int incr);sds sdsRemoveFreeSpace(sds s);size_t sdsAllocSize(sds s);void *sdsAllocPtr(sds s);/* 将 SDS 使用的分配器输出给调用 SDS 的程序使用. * 有时链接 SDS 的程序可能会设置不同的迭代器, 但是可能想要分配或释放 SDS 分别释放或分配的一些东西. */// 封装 SDS 分配器给调用者使用void *sds_malloc(size_t size);void *sds_realloc(void *ptr, size_t size);void sds_free(void *ptr);#ifdef REDIS_TESTint sdsTest(int argc, char *argv[]);#endif#endif sdsalloc.h12345678910111213/* SDSLib 2.0, 一个 C 实现的 strings 库 *//* SDS 选择分配器. * * 使用这个文件是为了在编译时可以改变 SDS 的分配器. * 只需要根据你需要使用的分配器定义宏. * 也需要根据需要 include(导入) 你用来替换的分配器的库 * (使用默认分配器不需要). */#include "zmalloc.h"#define s_malloc zmalloc#define s_realloc zrealloc#define s_free zfree]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析]]></title>
    <url>%2F2017-12-14-Redis-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.&emsp;&emsp;以前一直没有阅读过真正大项目的源码, 真正开始阅读才发现Redis的源码对我来说真的是好庞大, 一个文件上千行代码, 利用工作之余阅读, 尽量做到认真阅读每行代码, 大于要花大半个月的时间, 算算时间可能阅读完Redis源码需要花费的时间要超过一年. 回顾以往经历, 对自己能否坚持下来很是担心. 正好这两天我也在看一个大神的博客, 想自己搞个博客, 写点东西. 所以搞个博客记录一下自己的学习. 一方面可以归纳总结自己所学到的东西, 有不对的地方也可以被其他人指正; 另一方面有人阅读我的文章也是对我的一种激励, 避免一个人独自学习因为无聊而放弃.最开始在网上找到了一份关于Redis 2.8 的中文注释源码, 就开始阅读这份源码. 在阅读过程中查资料时发现了 Redis设计与实现 , 感觉这个本书写的挺不错, 而且也附带有一份关于Redis 3.0 的中文注释源码, 同时由于发现了一处Redis源码中的小问题在向Redis提交代码是发现最新的Redis已经到了4.0版本. 于是决定参考2.8和3.0的源码阅读Redis 4.0版本的源码. 由于对redis还没有一个整体的认识, 所以在阅读过程中可能存在一些错误的认识, 欢迎大家指正. Redis 学习资源 Redis 官网 Redis 中文官方网站 Github 上 Redis 源码 线上 Redis 示范环境 Redis 使用教程 如何阅读 Redis 源码? Redis 设计与实现 Redis 3.0中文注释源码 Redis 2.8源码解析 Reids 2.8中文注释源码]]></content>
      <categories>
        <category>数据库</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
