<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[raft 算法论述]]></title>
    <url>%2Fraft_conclusion.html</url>
    <content type="text"><![CDATA[raft 是一种用来管理日志复制的一致性算法. 在 raft 中服务器一共分为三种状态: Leader: 通过超过半数的服务器投票选举成为 Leader, 具有管理日志复制的绝对权力. 所有客户端的请求都是由 Leader 处理, 在这个过程中会生成新的日志条目, 将其复制到其他服务器上并告诉它们何时将日志条目应用到它们的状态机上是安全的 Follower: 通过对 Leader 日志的复制实现对其状态的复制, 只响应其他服务器的请求 Condidate: 由 Follower 在发现 Leader 失效(选举超时)转换而来, 获得超过半数的服务器投票选举成功转换为 Leader raft 允许小于半数的服务器失效. Raft 一致性算法数据Leader名称描述状态currentTerm服务器已知的最后一个任期号(第一次启动时初始化为 0, 持续递增)在所有服务器上处于持久化状态(在稳定存储(硬盘)上更新)votedFor在当前任期中获得投票的候选人 id(如果没有为 null)log[]日志条目集; 每个条目包含用于状态机的命令和领导人收到条目时的任期(第一个索引值为 1)commitIndex已知已经被提交的日志条目的最大索引值(初始化为 0, 单调递增)在所有服务器上处于易失化状态(存储在内存上)lastApplied已经应用到状态机的日志条目的最大索引值(初始化为 0, 单调递增)nextIndex[]对于每一个服务器, 需要发送给它的下一个日志条目的索引值(初始化为领导人最后索引值 +1)在领导人上处于易失化状态(存储在内存上)(选举后重新初始化)matchIndex[]对于每一个服务器, 已经复制给它的日志的最高索引值(初始化为 0, 单调递增) Condidate名称描述状态currentTerm服务器已知的最后一个任期号(第一次启动时初始化为 0, 持续递增)在所有服务器上处于持久化状态(在稳定存储(硬盘)上更新)votedFor在当前任期中获得投票的候选人 id(如果没有为 null)log[]日志条目集; 每个条目包含用于状态机的命令和领导人收到条目时的任期(第一个索引值为 1)commitIndex已知已经被提交的日志条目的最大索引值(初始化为 0, 单调递增)在所有服务器上处于易失化状态(存储在内存上)lastApplied已经应用到状态机的日志条目的最大索引值(初始化为 0, 单调递增) Follower名称描述状态currentTerm服务器已知的最后一个任期号(第一次启动时初始化为 0, 持续递增)在所有服务器上处于持久化状态(在稳定存储(硬盘)上更新)votedFor在当前任期中获得投票的候选人 id(如果没有为 null)log[]日志条目集; 每个条目包含用于状态机的命令和领导人收到条目时的任期(第一个索引值为 1)commitIndex已知已经被提交的日志条目的最大索引值(初始化为 0, 单调递增)在所有服务器上处于易失化状态(存储在内存上)lastApplied已经应用到状态机的日志条目的最大索引值(初始化为 0, 单调递增) 消息AppendEntries RPC用来 Leader 复制日志, 也用作 heartbeat: 参数 描述 term Leader 的任期 leaderId Leader 的 ID, Follower 可用来重定向客户端请求 prevLogIndex 紧接新日志条目之前的日志条目的 index prevLogTerm prevLogIndex 所指日志条目的 term entries[] 要存储的条目(空时为 heartbeat; 可能发送多个以提高效率) leaderCommit Leader 的 commitIndex 返回: 参数 描述 term currentTerm, 用于 Leader 更新自己的状态 success 如果 Follower 包含与 prevLogIndex 和 prevLogTerm 匹配的条目, 则返回真 RequestVote RPC用于 Condidate 收集选票: 参数 描述 term Condidate 的任期 candidateId 请求选票的 Condidate 的 ID lastLogIndex Condidate 的最后一条日志条目的 index lastLogTerm Condidate 的最后一条日志条目的 term 返回: 参数 描述 term currentTerm, 用于 Condidate 更新自己的状态 voteGranted 真意味着 Condidate 收到选票 InstallSnapshot RPC用于 Leader 向 Follower 发送快照块. Leader 总是有序的发送快照块: 参数 描述 term Leader 的任期 leaderId Leader 的 ID, Follower 可用来重定向客户端请求 lastIncludedIndex 快照将调换直到包含这个 index 的所有条目 lastIncludedTerm lastIncludedIndex 所在的任期 offset 快照块定位在快照文件中的字节偏移 data[] 快照块的原始字节, 从 offset 开始 done 如果是最后一块数据, 则为真 返回: 参数 描述 term currentTerm, 用于 Leader 更新自己的状态 规则Leader 如果 commitIndex &gt; lastApplied, 自增 lastApplied 并应用 log[lastApplied] 到状态机 如果 RPC 请求或响应中包含的 term T 有 term T &gt; currentTerm, 设置 currentTerm = T 并转换为 Follower 选举成功: 向每个服务器发送初始空 AppendEntries RPC(心跳), 并在一定的空闲时间后重复发送以防止选举超时 如果收到客户端的指令, 添加条目到本地日志, 该条目被应用到状态机后响应 如果最后一条日志的 index 大于为某个Follower 记录的 nextIndex: 发送携带从 nextIndex 开始的日志条目的 AppendEntries RPC 如果成功, 为 Follower 更新 nextIndex 和 matchIndex 如果 AppendEntries 因为日志不一致而失败递减 nextIndex 如果这条日志存在, 发送重试 如果这条日志已经被丢弃, 发送快照 如果存在 N 有 N &gt; commitIndex, 过半的 matchIndex[i] ≥ N, 并且 log[N].term == currentTerm: 设置 commitIndex = N 如果 Leader 收到更高 term 的 RequestVote RPC 或 AppendEntries RPC 如何处理? 如果 Leader 能够发送心跳给大多数服务器, 它就不会被更大的任期号废黜 在任期开始时提交一个空白的没有任何操作的日志条目以确保自己有被提交日志的最新信息 在处理只读的请求之前必须通过与集群中过半服务器交换心跳信息确认自己有没有被废黜 在一个 term 里在指定的 index 位置最多只创建一条日志条目, 同时日志条目在日志中的位置也从来不会改变 Leader 从来不会覆盖或者删除自己的日志 Leader 只提交当前任期内的日志 已提交的日志持久化, 并使用快照对日志进行压缩 集群配置变化时, 如果集群的 Leader 可能不是新配置(C~new~)的一员, 提交新配置(C~new~)后转换为 Follower Condidate 如果 commitIndex &gt; lastApplied, 自增 lastApplied 并应用 log[lastApplied] 到状态机 如果 RPC 请求或响应中包含的 term T 有 term T &gt; currentTerm, 设置 currentTerm = T 并转换为 Follower 转换为 Condidate 后立即开始选举 自增 currentTerm 给自己投票 在一个固定的范围内随机选择重置选举超时计时器 发送 RequestVote RPC 给其他所有服务器 如果收到超过半数服务器的投票: 变为 Leader 如果收到新的 Leader 发送的 AppendEntries RPC: 转换为 Follower 如果选举过程超时, 再次发起新的选举 如果收到不小于当前 term 的 AppendEntries RPC, 承认 Leader 合法并转换为 Follower 已提交的日志持久化, 并使用快照对日志进行压缩 Follower 如果 commitIndex &gt; lastApplied, 自增 lastApplied 并应用 log[lastApplied] 到状态机 如果 RPC 请求或响应中包含的 term T 有 term T &gt; currentTerm, 设置 currentTerm = T 并转换为 Follower 响应 Leader 和 Condidate 的 RPC, 并在一个固定的范围内随机选择重置选举超时计时器 如果在超过选举超时时间之前没有收到 Leader 的 AppendEntries RPC 或为 Condidate 投票, 转换为 Condidate 每次开始选举之前, 至少等待一个最小选举超时时间, 如果在最小选举超时时间内收到 RequestVote RPC 则忽略, 如果在最小选举超时时间内收到 term 更高的 AppendEntries RPC 呢? 一个 term 最多只投出一张选票 当收到 RequestVote RPC, 按照先来先服务原则, 如果当前任期 votedFor 为空或者为 candidateId, 并且 Condidate 的日志至少和自己的一样新(新的定义: log[last].term &lt;= lastLogTerm || log[last].index &lt;= lastLogIndex), 则投票给它 当收到 AppendEntries RPC 如果日志在 prevLogIndex 位置不包含 term 为 prevLogTerm 的日志条目, 则返回 false 如果现有条目与新条目冲突(在相同的 index 位置具有不同的 term), 则删除现有条目及其后的所有条目(Leader 处理不一致是通过强制 Follower 直接复制自己的日志来解决, 这意味着在 Follower 中冲突的日志条目会被 Leader 的日志覆盖) 附加日志中尚未存在的任何新条目 如果 aderCommit &gt; commitIndex, 设置 commitIndex = min(leaderCommit, index of last new entry) 如果新条目已存在, 忽略 如果收到客户端请求, 拒绝客户端请求并返回最新一次从 AppendEntries 中接收到的 Leader 的信息 已提交的日志持久化, 并使用快照对日志进行压缩 集群配置变化时, 新加入的 Follower 以没有投票权身份加入到集群中(可以复制日志, 但是不能投票, 也不考虑它们是大多数), 直到日志追赶上其他服务器, 恢复正常 特性 特性 描述 选举安全(Election Safety) 在给定的任期中最多只能选举一位领导人 Leader 只附加(Leader Append-Only) Leader 永远不会覆盖或删除其日志中的条目; 它只附加新的条目 日志匹配(Log Matching) 如果两份日志中包含具有相同的 index 和 term 的条目, 那个在这个 index 之前的所有条目都是相同的 Leader 完整(Leader Completeness) 如果在给定的 term 中提交了一个日志条目, 那么这个条目一定会出现在所有具有更高 term 的 Leader 的日志中 状态机安全(State Machine Safety) 如果一个服务器已经应用了一个给定 index 的日志条目到其状态机, 那么将没有其他服务器会在相同 index 位置应用不同的日志条目 raft 确保每个特性在任何时候都是正确的. Follower 规则 6 和 Condidate 规则 4 确保选举安全(Election Safety) Leader 规则 12 确保 Leader 只附加(Leader Append-Only) Follower 规则 8.1, Leader 规则 5 和规则 11 确保日志匹配(Log Matching) Leader 规则 11 确保不同的日志中两个拥有相同的 index 和 term 的条目存储了相同的指令 Follower 规则 8.1 和 Leader 规则 5 确保不同的日志中两个拥有相同的 index 和 term 的条目之前的所有日志条目也全部相同 Follower 规则 7 确保 Leader 完整(Leader Completeness) Leader 选举当 Leader 失效, Follower 在选举超时时间内没有收到任何消息时, 就会转换为 Condidate 发起选举. 选举会出现三种结果: 获得过半选票赢得选举, 转换为 Leader 其他服务器赢得选举, 转换为 Follower 超过选举超时时间没有获得过半选票, 开始新一轮选举 Follower 规则 3 和 Condidate 规则 3.3 避免选票无限次被瓜分. 日志复制Leader 通过 AppendEntries RPC 和 InstallSnapshot RPC 进行日志复制. 通过 日志条目的传送是单向的, 只从 Leader 传给 Follower Leader 只附加(Leader Append-Only) 日志匹配(Log Matching) Leader 完整(Leader Completeness) Follower 规则 8.2: 确保错误的日志被覆盖, Follower 与 Leader 日志保持一致 确保日志复制的可靠. Follower 和 Condidate 崩溃Follower 和 Condidate 崩溃会导致 RPC 无限次重试. 通过 Raft 的 RPC 是幂等的(Follower 规则 8.5) 确保重试的可靠. 集群成员变化为了确保集群成员变化出现的集群配置由老(C~old~)到新(C~new~)变化过程中的安全性, 防止两个 Leader 等问题的出现, Raft 使用两个阶段切换集群配置, 其中集群配置在复制日志中以特殊的日志条目来存储和通信: 共同一致(joint consensus): 过渡阶段, 新老配置结合(C~old,new~) 日志条目被复制给两个配置中的所有服务器: 任一配置的任何服务器都可以成为 Leader 达成(针对选举和提交)需要分别在两种配置上获得大多数的支持: 配置转换过程中仍然可以处理客户端请求 新集群配置: 切换完成(C~new~) 一旦一个服务器将新的配置日志条目增加到它的日志中, 它就会用这个配置来做出未来所有的决定(服务器总是使用最新的配置, 无论这个条目是否已经被提交). 集群配置变化过程可以看作两条日志同步的过程, 在同步过程中由于配置日志条目的生效, 集群对应的服务器出现了变化, 但是 Leader 选举和日志复制的具体过程还是不变的. 在集群配置变化的过程中存在三个问题: 新的服务器可能初始化没有存储任何的日志条目, 需要一段时间追赶日志, 无法提交新日志, 影响可用性: Follower 规则 11 集群的 Leader 可能不是新配置(C~new~)的一员: Leader 规则 15 被移除不在新配置(C~new~)中的服务器可能会扰乱集群: Follower 规则 5 和 Leader 规则 8 日志压缩日志如果不压缩存在两个问题: 日志在日常操作中不断增长, 占用资源越来越多, 重置服务器花费时间越来越多 同步长时间隔离或崩溃的服务器需要花费大量时间和带宽 &emsp;&emsp;使用快照进行日志压缩, 快照记录 最后一条被压缩日志条目的 term 和 index 状态机状态 集群配置作为最后一个条目 每个服务器独立的创建快照, 只包括已经被提交的日志. 快照也通过 InstallSnapshot RPC 被用于 Leader 日志条目已经被压缩丢弃时同步日志(Leader 规则 5.2.2), 接收者需要 保存快照文件, 丢弃已有的快照或有更小的 index 的部分快照 如果接收者现有日志有快照最后一条日志条目, 保留其后的日志条目, 丢弃其他日志, 否则丢弃全部日志 使用快照重置状态机(并加载快照的集群配置) 快照性能存在的两个问题: 服务器必须决定什么时候应该创建快照 写入快照不能影响正常操作: 写时复制 客户端 Follower 规则 9 和 Leader 规则 4 确保所有的请求被 Leader 可靠处理 Raft 支持序列化语义: 客户端对于每一条指令都赋予一个唯一的序列号, 状态机跟踪每条指令最新的序列号和相应的响应, 如果接收到序列号已执行的指令, 直接返回结果 Leader 规则 9 和 10 确保只读操作不会读到脏数据 优化方向 learner 集群成员变化 参考 Raft lecture (Raft user study) 我对Raft的理解 - One raft论文 raft论文中文版 etcd raft cap 理解 分布式事务通用解决方案 raft协议-集群成员变化处理 深入浅出 Raft - Optimization 深入浅出 Raft - Membership Change]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>raft</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动过程]]></title>
    <url>%2Fcomputer_startup.html</url>
    <content type="text"><![CDATA[系统启动标准系统启动有两种标准: BIOS(Basic Input/Output System) 固化到计算机主板上的程序 包括系统设置, 自检程序和系统自启动程序 BIOS-MBR: 通过 BIOS 加载主引导记录(MBR, Main Boot Record) 在多个分区中选择具体的活动分区来启动系统 BIOS-GPT: MBR 最大只能描述 4 个主分区, 每个主分区占 16 字节. 当主分区大于 4 时, 就需要 GPT(全局唯一标识分区表), 可以在分区表中描述更多的分区结构 PXE: 网络启动的标准, 在 BIOS 中添加网络协议栈, 功能更加复杂 UEFI(Unified Extensible Firmware Interface) 接口标准 在所有平台上一致的操作系统启动服务 今天介绍的是 BIOS. 计算机启动过程内存布局BIOS 的内存地址空间&emsp;&emsp;计算机启动后, 当 CPU 加电电流稳定时, CPU 寄存器会有一个初始状态. 这时有一个约定, CPU 寄存器中 CS(code segment, 代码段寄存器) 和 IP(instruction pointer, 指令指针寄存器, 32 位为 EIP) 的初始状态应为 CS:IP = 0xf000:fff0, 即 PC(programme counter, 程序计数器) 的初始值, 作为第一条指令地址. 这时系统处于实模式(real mode)下, 下文会详细介绍. 然后执行第一条指令, 第一条指令在只读存储内存(ROM) 即 BIOS 启动固件中, 因为系统处于实模式, 地址总线只有 20 位可用, 即内存可用区域只有 2^20 即 1MB, 所以开机执行的代码只能保存在在内存前 1MB 内的一小块, BIOS 启动固件保存在 640KB 到 1MB 之间的空间. 加载程序的内存地址空间 BIOS 初始化完成后: 将读取磁盘上的引导扇区中的加载程序(bootloader), 引导扇区长度只有 512 字节, 将加载到 0x7c00 位置 跳转到 0x7c00(CS:IP = 0x0000:7c00), 然后将控制权转交给从磁盘上读取的程序, 即加载程序 加载程序执行任务: 将操作系统代码和数据从硬盘上加载到内存中 跳转到操作系统的起始位置, 将控制权转交给操作系统 系统启动流程概述 在上文说到过系统加电 BIOS 初始化硬件完成后直接读取加载程序(bootloader), 但是这只是为了更直观的展示启动过程中的内存布局. 实际这一步并不能直接进行, 以前磁盘空间小只有一个分区的时候可以直接到这个分区的引导扇区读取加载程序, 但是现在计算机磁盘上都不止一个分区, 且每个分区都可能装有不同的系统, 所以不能直接进行 这时就使用了主引导记录 MBR, BIOS 会读取其中的主引导扇区代码到内存中, 将 CPU 控制权转交给主引导扇区代码(执行). MBR 处于磁盘的第一个扇区中, 共 512 个字节 每个活动分区都有自己的引导扇区, 主引导扇区代码会确定加载程序所在的活动分区, 并读取该活动分区的引导扇区代码到内存中, 然后将 CPU 控制权转交给活动分区的引导扇区代码(执行) 活动分区的引导扇区代码读取当前分区上文件系统的加载程序到内存中, 然后将 CPU 控制权转交给当前文件系统的加载程序(执行) 当前文件系统的加载程序加载文件系统上的操作系统到内存中, 然后将 CPU 控制权转交给操作系统(执行), 操作系统启动 详细流程CPU 初始化 在 x86-32 CPU 加电启动后, CPU 会进行初始化, 设置中断使能标志. 这时所有寄存器都有一个缺省值, 这其中最重要的有代码段寄存器 CS 和指令指针寄存器 EIP(IP), 它们结合在一起形成了一个加电(启动) 后的地址, 这个地址将是计算机执行的第一条指令, 缺省值 CS = 0xf000, EIP = 0x0000fff0 为了兼容早期的 CPU, 如 8086, 计算机启动时是处于 16 位的实模式, 计算机的寻址方式按照实模式的寻址方式: 段基址(base) + 偏移量(offset) = 物理地址(address). 段基址(base) 为段寄存器左移 4 位, 即 base = CS &lt;&lt; 4 = 0xf0000, 为了和 32 位的 EIP 相加扩展为 base = 0xffff0000; 偏移量(offset) 即为 EIP 的值; 物理地址(address) 即为 base + offer = 0xffff0000 + 0x0000fff0 = 0xfffffff0, 由于处于 16 位的实模式, 地址总线只有 20 位可用, 可寻址空间只有内存起始位置的 1MB 空间, 所以物理地址(address) 即为 0xffff0. 这个物理地址就是加电后的第一条指令地址, 这个地址指向 BIOS 的 EPROM(Erasable Programmable Read Only Memory), 只读. 这个指令通常是一个长跳转指令(这时 CS 和 EIP 值都会更新), 会跳转进入 BIOS 中做初始化工作 BIOS 初始化 硬件自检 POST 检测系统中的内存和显卡等关键部件的存在和工作状态 查找执行显卡等接口卡 BIOS, 进行设备初始化 执行系统 BIOS, 进行系统检测 检测和配置系统中安装的即插即用设备 更新 CMOS 中的扩展系统配置数据 ESCD ESCD: 系统配置表, 保存扩展系统配置数据 指定启动设备顺序 以中断方式提供基本的 I/O 系统调用: 从外设(磁盘, 键盘等)读取数据, 在显示器上显示等 BIOS 系统调用 INT 10h: 字符显示 INT 13h: 磁盘扇区读写 INT 15h: 检测内存大小 INT 16h: 键盘输入 只能在 x86 的实模式下访问 主引导记录 MBR 格式 启动代码: 446 字节 检查分区表正确性 加载并跳转到活动分区的引导程序 硬盘分区表: 64 字节 描述分区状态和位置 每个分区描述信息占据 16 字节 结束标志字: 2 字节(0x55 0xAA) 主引导记录的有效标志 分区引导扇区格式 跳转代码(JMP): 跳转到启动代码 与平台相关代码 文件卷头: 文件系统描述信息, 可以识别文件系统 启动代码: 跳转到加载程序 结束标志: 0x55AA 512 字节, 启动代码可以修改, 只要指向加载程序即可, 加载程序位置随意 加载程序 可以识别文件系统 从文件系统中读取启动配置信息: 每种系统都有自己的启动配置信息格式, 不同的系统就有属于自己的加载程序的格式. 从实模式使能到保护模式(protection mode), 为后续操作系统的执行做准备, 这时的寻址能力从 1MB 扩展到 4GB. 保护模式下段机制(segment-level protection) 会自动使能, bootloader 会创建 GDT 清理环境: 禁止中断, 将段寄存器清 0 等 开启 A20: 通过将键盘控制器上的 A20 线置为高电位, 使 32 条地址总线均可用, 实现最大 4GB 的寻址 初始化 GDT 进入保护模式: 通过将 cr0 寄存器 PE 位(第 0 位) 置 1 开启保护模式 设置段寄存器, 建立堆栈 加载程序的启动菜单配置操作系统内核列表和加载参数 依据配置加载 kernal in ELF 格式的操作系统内核到内存中固定的位置, 并跳转到内核的入口点(entry point)执行, 这时控制权到了操作系统内核 引申BIOS 能直接从磁盘上读取数据, 为什么不用 BIOS 直接从磁盘上将操作系统读取到内存中?&emsp;&emsp;磁盘上存在文件系统, 文件依照文件系统的特定格式写入磁盘. 文件系统多种多样, 而 BIOS 在计算机出厂是就已经写入, 不可能在出厂是限定用户使用某种文件系统, 同时也不能为了增加灵活性, 在 BIOS 中添加已知的所有文件系统代码. 所以, 这里有一个基本约定, BIOS 不需要认识文件系统的格式也能从磁盘的第一个扇区读取其中的启动代码, 然后通过启动代码识别文件系统, 读取加载程序, 继而读取操作系统内核代码, 并将其加载到内存中. 参考 关于程序计数器 PC 与 CS:IP 的区别 CS、IP和PC寄存器 学堂在线操作系统课程]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言函数调用的实现]]></title>
    <url>%2Fc_function_call.html</url>
    <content type="text"><![CDATA[基础知识寄存器 ebp: 基址指针寄存器, 保存栈底指针 esp: 堆栈指针寄存器, 保存栈顶指针 汇编 Intel 汇编指令: 从右向左读 AT&amp;T 汇编指令: 从左往右读 函数调用堆栈(stack) 分析C 语言代码&emsp;&emsp;分析 C 语言函数调用首先需要有一份用于分析的 C 语言代码. 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int sum(int a, int b)&#123; int temp = 0; temp = a + b; return temp;&#125;int main()&#123; int a = 10; int b = 20; int ret = 0; ret = sum(a, b); printf("%d\n", ret); return 0;&#125; 汇编代码分析执行主调函数(main)&emsp;&emsp;在这里, 需要通过查看汇编指令分析函数调用的具体处理过程, 我使用的 IDE 是 Visual Studio. 查看图一的汇编代码可以发现: 源代码的第一条指令并不是真正的第一条指令 一个栈顶一个栈底就可以标识一个栈的位置 这里用于标记栈顶和栈底的就是前文提过的 esp 和 ebp 指针. 其中 esp 和 ebp 之间的区域就表示 main 函数的栈帧, 具体汇编指令的含义在下文执行被调函数(sum) 时说明. &emsp;&emsp;程序继续向下执行, 当执行完 int ret = 0; 时, 变量 a, b, ret 被分别放入 main 函数栈帧 [ebp - 4], [ebp - 8], [ebp - 0Ch] 中, 然后进行函数调用: 函数调用先从右往左压实参入栈: 将 b([ebp - 8]) 存入 eax 寄存器中, 将 eax 寄存器中的值入栈, 栈顶指针下移 将 a([ebp - 4]) 存入 ecx 寄存器中, 将 ecx 寄存器中的值入栈, 栈顶指针下移 执行完前四行汇编代码后 main 函数的栈帧如图三所示: 由图三可以看出形参变量在主调函数(main) 的栈帧上开辟空间保存. 这时应该执行汇编代码: 1call _sum (03910FAh) 为了在调用函数完成后可以回到主调函数(main) 中继续执行下一条指令, call 指令有两个功能: 将 call 的下一次汇编指令地址(00391400) 入栈 调用函数执行 当调用函数过程完成, 进入 sum 函数, 这时 main 函数栈帧上的操作暂时完成, 开始执行 sum 中的指令. 执行被调函数(sum)&emsp;&emsp;sum 函数的汇编代码如图四所示: 100391460 push ebp 将主调函数(main) 栈底指针 ebp 入栈, 方便退出被调函数(sum) 时 ebp 重新指向主调函数(main) 的栈底, 恢复主调函数(main) 函数栈帧. 1200391461 mov ebp,esp00391463 sub esp,0CCh 第一句将 ebp 指针移至栈顶, 第二句将 esp 向下移动 0CCh 个字节, 这是在为被调函数(sum) 开辟栈帧, 长度为 0CCh(204). 这是回顾图一可以发现 main 函数也开辟了栈帧, 但是长度为 0E4h(228). 12300391469 push ebx0039146A push esi0039146B push edi 这三句是在保存主调函数(main) 运行的现场, 即, 将主调函数(main) 使用的寄存器入栈保存, 以便退出被调函数(sum) 时恢复主调函数(main) 现场环境. 12340039146C lea edi,[ebp-0CCh]00391472 mov ecx,33h010D1477 mov eax,0CCCCCCCCh010D147C rep stos dword ptr es:[edi] 这四句将被调函数(sum) 开辟栈帧时的所有空间都初始化为 CCh, 这里 rep stos 类似于 for 循环, 代表从 edi(ebp - 0CCh, 即被调函数(sum) 刚刚开辟栈帧时的 esp) 开始, 一次拷贝 4 个字节(dword), 拷贝的内容为 eax(0CCCCCCCCh), 拷贝 ecx(33h) 次, 也就是拷贝了 $4 * 33h = CCh$ 的内存, 正是被调函数(main) 初始化时的栈帧(栈帧在主调函数(main) 保存现场环境时入栈了三个寄存器, 栈帧增长, 这次初始化没有覆盖这些值). 所以在 windows 中全局变量未初始化时打印值为 0(进程启动时操作系统会负责将进程虚拟地址空间上的 .bss 段全部初始化为 0), 局部变量未初始化时打印为 0xCCCCCCCC(-858993460, 即 “烫烫烫烫”). 12 int temp = 0;010D147E mov dword ptr [temp],0 将被调函数(sum) 的局部变量存入栈帧中, 通过 ebp - 4 寻址存入的空间. 1234 temp = a + b;00051485 mov eax,dword ptr [a]00051488 add eax,dword ptr [b]0005148B mov dword ptr [temp],eax 前面提到过, 被调函数(sum) 的形参保存在主调函数(main) 的栈帧上, 所以这时的 a 位于 ebp + 8, b 位于 ebp + 0Ch(ebp + 4 保存主调函数(main) 将要执行的下一条指令地址, ebp 指向的空间保存主调函数(main) 的栈底地址). 这里将 a 先存入 eax 中, 再将 b 与 eax 中的值相加存入 eax 中, 最后将 eax 中的值存入 ebp - 4(temp) 中. 12 return temp;0005148E mov eax,dword ptr [temp] 返回结果时, 将 ebp - 4(temp) 中的值放入 eax 中, 当回到主调函数(main) 时, 再通过 eax 获取返回值, 没有产生临时变量.(仅限于小于等于 4 字节的返回值) 12300051491 pop edi00051492 pop esi00051493 pop ebx 恢复主调函数(main) 现场环境. 1200051494 mov esp,ebp00051496 pop ebp 进行栈帧回退, 对于栈帧的操作即是对于 esp 和 ebp 的操作. 将 esp 移至 ebp, 释放被调函数(sum) 栈帧, 这时 ebp/esp 指向的空间保存的是主调函数(main) 的栈底地址 出栈到 ebp, 即在图四中被调函数(sum) 执行第一条指令时入栈的主调函数(main) 栈底指针出栈到 ebp, 使 ebp 重新指向主调函数(main) 栈底 这时 esp 和 ebp 已经重新指向主调函数的栈帧. 100051497 ret 这时 esp 指向的空间中保存的是主调函数(main) 需要执行的下一条指令的地址, ret 将其出栈到 IP 寄存器(非 intel 厂家称为 PC)中, 使 CPU 下一次执行该指针所指向的代码(call 的下一条指令). 回到主调函数(main)&emsp;&emsp;这时回到了主调函数(main), 继续执行 call 的下一条指令. 100051400 add esp,8 将 esp 上移 8 个字节, 即将形参 a, b 出栈. 100051403 mov dword ptr [ret],eax 函数返回值通过 eax 带回, 所以将 eax 赋值给 ebp - 0Ch(ret). &emsp;&emsp;这时整个函数调用过程完成. 注意: 在汇编指令访问局部变量的过程中, 都是通过 ebp 进行访问. 函数调用过程图解 引申为什么参数入栈时要从右往左入栈?&emsp;&emsp;参数从右往左入栈是为了实现可变参编程. 可变参编程需要通过第一个参数判断参数的数量, 如果参数从左往右入栈, 编译器必须先知道参数的个数才能确定第一个参数的位置; 如果参数从右往左入栈, 编译器可以直接通过 ebp + 4 获取第一个参数的值. 寄存器是否可以被寻址?&emsp;&emsp;寄存器不可以寻址, 凡是可以寻址的东西都在内存上. 在汇编上有一种寄存器寻址是指寄存器中的值被 CPU 当做地址对待. 寄存器并没有像内存单元一样有一个可寻址的地址.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编译链接</tag>
        <tag>C&amp;C++</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP 头部封装]]></title>
    <url>%2FTCP_header.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;TCP 头部包括以下字段: 源端口(Source Port, 16 bits): 发送端进程端口号, 用于标识发送进程. 目的端口(Destination Port, 16 bits): 接收端进程端口号, 用于标识接收进程. IP 和端口被称为端点(endpoint) 或套接字(socket), 一对端点(目的 IP, 目的端口, 源 IP, 源端口四元组)唯一标识一个连接. 序列号(Sequence Number, 32 bits): 记录数据包中第一个数据在整个连接中的位置, 以字节为单位. 初始序列号(Initial Sequence Number, ISN) 由系统生成, 在 SYN(下文介绍) 报文段选择 ISN 时需要随时间增长且无法被预测. 随时间增长避免一个连接上到达某一个端点上的报文段在一段时间内, 旧的实例报文段的序列号不会与新的实例报文段的序列号相同, 如果相同则 TCP 将无法识别这是一个异常的报文段(不考虑 TSopt 选项, 下文介绍), 可能会导致传输数据错误. 这段时间需要大于一个报文段在网络中的存活时间为 MSL, 而 SN 随时间增长回绕到相等时通常远大于 MSL. 无法被预测避免其他人猜测到当前 SN 进行攻击, 例如攻击者可以发送具有当前 SN 的 RST(下文介绍)报文段到对端破坏连接, 也可以发送具有当前 SN 的错误数据报文段到对端使传输的数据出错. 如果无法猜测到当前 SN, 即使发送了错误报文段, SN 不在窗口范围内也会被 TCP 主动抛弃. 确认号(Acknowledgment Number, 32 bits): 对接收到的数据包进行确认, 设置 ACK 标志位(下文介绍)时生效, 值为接收到报文段 SN + 数据长度, 即下一个应该接收到的报文段的 SN, 例如当收到一个 SN 为 1 数据长度为 200 的报文段, 应回复的确认号值为 201. TCP 可以进行累计确认, 例如当收到 SN 为 1 数据长度为 200 和 SN 为 201 数据长度为 200 的报文段时可以回复一个确认号为 401 的报文段. 头部长度(Header Length, 4 bits): 统计 TCP 报文段头部长度, 以 4 字节为单位, 所以 TCP 头部最大长度为 (2 ^ 4) - 1 * 4 = 60 字节. 保留(Recv, 4 bits): 保留后续改进 TCP 预留的字段, 值必须为 0. 其中最低一位在试验性质的 RFC 文件 RFC3540 中被定义为随机数和(nonce sum, NS). CWR: 拥塞窗口减小标志位, 当接收端通过 ECE 标志位(下文介绍)通知发送端出现拥塞时, 发送端降低发送速率, 回复该标志. ECE: 显式拥塞通知(ECN)回显标志位, IP 协议 ToS 字段两个最低有效位(第 15 ~ 16 位) 用于表示是否支持 ECN: 00 表示不支持, 01/10 表示支持, 11 表示发生拥塞(CE). 当传输层支持 ECN 时, 如果发生拥塞, 路由器将不丢包, 而是设置 CE. 在三次握手中协商 ECN 成功时, 如果接收端收到 CE 标志, 则会一直设置该标志位通知直到接收到 CWR 标志位. 详情参考显式拥塞通知. URG: 紧急指针标志位, 用于发送紧急数据时设置, 使紧急指针生效. ACK: 确认标志位, 用于确认接收到的数据包时设置, 使确认号字段生效. PSH: 推送标志位, 用于通知接收端将接收到的所有数据提交给接收进程, 所有数据包括与该标志位一起到达的数据和已经接收到但未提交给接收进程的数据. 在 linux(Berkeley socket) 中, 系统没有提供设置 PSH 的 API, 系统会在发送数据清空发送缓冲区时自动进行置位; 同时由于系统一般不会推迟将接收到的数据提交给应用程序, 所以系统会忽略接收到的 PSH. RST: 连接重置标志位, 用于连接出现异常或错误时立即断开连接时设置. 设置了该标志位的数据包, 不需要确认. SYN: 连接建立标志位, 用于建立连接时设置. FIN: 连接断开标志位, 用于断开连接时设置. 窗口大小(Window Size, 16 bits): 指定对端可以发送从确认号字段开始的字节数, 单位由 WSopt 选项指定(下文介绍). TCP 连接的每一端中都存在一个发送窗口和一个接受窗口用于进行流量控制和拥塞控制(见后续文章), 当前大小指定了对端发送窗口大小, 即本端接收窗口大小. 检验和(TCP Checksum, 16 bits): 用于伪头部, TCP 头部, TCP 数据的校验和. 紧急指针(Urgent Pointer, 16 bits): URG 置位时生效, 用于指明紧急数据结束的位置, 即正常数据开始位置, 在 Linux 中称为带外数据. 选项(可变)(Options, variable): 源码&emsp;&emsp;TCP 在 Linux 中定义如下: 12345678910111213141516171819202122232425262728293031323334struct tcphdr &#123; __be16 source; __be16 dest; __be32 seq; __be32 ack_seq;#if defined(__LITTLE_ENDIAN_BITFIELD) __u16 res1:4, doff:4, fin:1, syn:1, rst:1, psh:1, ack:1, urg:1, ece:1, cwr:1;#elif defined(__BIG_ENDIAN_BITFIELD) __u16 doff:4, res1:4, cwr:1, ece:1, urg:1, ack:1, psh:1, rst:1, syn:1, fin:1;#else#error "Adjust your &lt;asm/byteorder.h&gt; defines"#endif __be16 window; __sum16 check; __be16 urg_ptr;&#125;; &emsp;&emsp;其中 __be16 和 __sum16 为 unsigned short, __be32 为 unsigned int, __LITTLE_ENDIAN_BITFIELD 表示小端比特序, __BIG_ENDIAN_BITFIELD 表示大端比特序. 其中大端比特序与人类思维方式一致, 可以通过对比大端序与上文中图二 TCP 头部字段加深了解. 同时通过源码可以看出 Linux 并没有实现 NS 标志位. Reference TCP/IP Illustrated, Volume 1: The Protocols (2nd Edition) • Chapter 12 TCP: The Transmission Control Protocol (Preliminaries) TCP/IP Illustrated, Volume 1: The Protocols (2nd Edition) • Chapter 13 TCP Connection Management TCP Header Source Byte and Bit Order Dissection 注: 本文源码来自 Linux v4.19.]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[write() 函数]]></title>
    <url>%2Fwrite_function.html</url>
    <content type="text"><![CDATA[*注: 基于 release 4.16 of the Linux man-pages project 整理 APUE 中未进行说明或与 Linux 存在不同的内容. 参考 write(2). 函数声明123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count); 描述 以下三种情况可能出现写入字节数小于 count 的情况: 底层物理存储空间不足. 遇到 RLIMIT_FSIZE 的资源限制(参考 setrlimit(2)). 调用在写入小于 count 时被一个信号回调中断. 对于一个可查找的文件(即, 可以使用 lseek 函数, 例如普通文件), 在文件偏移量位置进行写入, 并且文件偏移量增加实际写入的字节数. 如果使用指定了 O_APPEND 的 open(2) 函数打开一个文件, 文件偏移量会在写入前移动到文件的结尾. 文件偏移量的调整和写操作是以一个原子操作进行执行的. POSIX 规定一个 write() 返回成功后可以被 read(2) 读取到新写入的数据. 请注意, 不是所有的文件系统都符合 POSIX. 根据 POSIX.1, 如果 count 参数超过 SSIZE_MAX 时, 其行为由具体实现定义. 注意 write() 执行成功并不保证数据已经写入硬盘. 在包括 NFS 的一些文件系统中执行成功甚至不保证在磁盘中保留写入数据的空间. 在这种情况下, 一些错误可能会被延迟到将来执行 write(2), fsync(2) 甚至是 close(2) 执行时才能发现. 唯一保证数据被写入的方法是在所有数据执行 write() 后执行 fsync(2). 如果 write() 函数在写入任意数据前被信号回调中断, 那么这次调用将失败, 并产生 EINTR 错误; 如果至少写入了一个字节后被中断, 那么这次调用成功, 并返回写入的字节数. 在 Linux 中, write()(和类似的系统调用) 一次最多传输 0x7ffff000(2,147,479,552) 个字节, 会返回实际传输的字节数. (无论是 32 位还是 64 位的系统这都是正确的.) BUGS 根据 POSIX.1-2008/SUSv4 Section XSI 2.9.7 (普通文件的线程交互操作): 当对普通文件或符号链接操作时, 以下所有函数应该遵守 POSIX.1-2008 中指定的效果相互原子化: … 随后列出的 API 中包括 write() 和 writev(2). 它们跨线程(和进程)操作的效果应该是原子操作的更新文件文件偏移量. 但是, 在 Linux 3.14 之前的版本情况并非如此: 如果共享打开文件描述(参考 open(2)) 的两个进程同时执行 read()(或 readv(2)), 那么 I/O 操作更新文件偏移量将不会遵守原子操作的规则, 从而导致两个进程的读取操作可能(错误的) 获取到重叠的数据块. 这个问题在 Linunx 3.14 中被解决.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>文件I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数 read()]]></title>
    <url>%2Fread_function.html</url>
    <content type="text"><![CDATA[注: 基于 release 4.16 of the Linux man-pages project 整理 APUE 中未进行说明或与 Linux 存在不同的内容. 参考 read(2). 函数声明123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count); 描述 支持 lseek() 操作的文件的读操作从文件偏移量位置开始, 文件偏移量会增加读取的位数. 当文件偏移量在文件结尾或超出文件结尾, 没有数据可读, read() 将返回 0. 如果 count 参数是 0, 读操作可以用于检测错误. 如果没有任何错误或 read() 操作没有检测到错误, count 参数为 0 的 read() 操作将返回 0, 并不会产生其他的影响. 根据 POSIX.1, 当 count 参数超过 SSIZE_MAX 时的行为有具体的实现定义; 在注意中查看 Linux 中 count 的上限. 返回值出错时返回 -1, errno 被设置为适合的值. 在这种情况下, 没有指定文件偏移量(如果有) 的变化. 注意 size_t 和 ssize_t 分别是被POSIX.1 指定的无符号和有符号整型数据类型. 在 Linux 中, read()(和类似的系统调用) 一次最多传输 0x7ffff000(2,147,479,552) 个字节, 会返回实际传输的字节数. (无论是 32 位还是 64 位的系统这都是正确的.) 在 NFS 文件系统中, 读取少量数据可能只会在第一次读取时更新时间戳, 随后的调用可能不会. 这是客户端的缓存属性导致, 因为大多数 NFS 客户端将 st_atime(last file access time) 的更新留给了服务器, 当客户端从自身的缓存中读到了足够的数据时, 就不会从服务端读取, 也就不会导致服务端 st_atime 的更新. UNIX 语义可以通过关闭客户端的缓存属性使 st_atime 更新, 但是大多数情况下这种做法都会增加服务器负载, 降低性能. BUGS 根据 POSIX.1-2008/SUSv4 Section XSI 2.9.7 (普通文件的线程交互操作): 当对普通文件或符号链接操作时, 以下所有函数应该遵守 POSIX.1-2008 中指定的效果相互原子化: … 随后列出的 API 中包括 read() 和 readv(2). 它们跨线程(和进程)操作的效果应该是原子操作的更新文件文件偏移量. 但是, 在 Linux 3.14 之前的版本情况并非如此: 如果共享打开文件描述(参考 open(2) 的两个进程同时执行 read()(或 readv(2)), 那么 I/O 操作更新文件偏移量将不会遵守原子操作的规则, 从而导致两个进程的读取操作可能(错误的) 获取到重叠的数据块. 这个问题在 Linunx 3.14 中被解决.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>文件I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数 close()]]></title>
    <url>%2Fclose_function.html</url>
    <content type="text"><![CDATA[注: 基于 release 4.16 of the Linux man-pages project 整理 APUE 中未进行说明或与 Linux 存在不同的内容. 参考 close(2). 函数声明123#include &lt;unistd.h&gt;int close(int fd); 描述 调用 close() 函数时, 如果 fd 参数是最后一个指向底层打开文件描述(参考 open(2))的文件描述符, 资源关联的打开文件描述会被释放; 如果这个文件描述符是一个被使用 unlink(2) 删除了文件名引用的文件最后的引用, 这个文件将被彻底删除. 注意 成功关闭文件描述符并不保证数据已经成功保存到磁盘中, 因为内核使用缓冲区缓存来推迟写入. 通常, 文件系统在关闭一个文件时不会刷新缓冲区. 如果你需要确保数据物理的存储在底层磁盘上, 可以使用 fsync(2). (这将取决于磁盘硬件.) close-on-exec 文件描述符标志可以被用来确保成功调用 execve(2) 时自动关闭一个文件描述符; 详细描述参考 fcntl(2). 关闭可能正在被同一进程的其他线程的系统调用使用的文件描述符可能是不明智的. 因为一个文件描述符可能会被重用, 这是一些可能导致意料之外副作用的隐蔽竞态条件. 处理 close() 返回的错误 一个谨慎的程序员会去检查 close() 的返回值, 因为之前的 write(2) 操作产生的错误很可能只有在最后调用释放打开文件描述的 close() 时才会被通知. 当关闭一个文件时没有检查返回值可能会导致数据无声的丢失. 特别是在使用 NFS 或磁盘空间不足时可以观察到这种情况. 但是需要注意错误的返回应该仅用于诊断的目的(即, 向应用程序发出一个这里可能仍有待处理的 I/O 或可能存在 I/O 故障的警告) 或补救的目的(例如, 再次写文件或创建一个备份文件). 在一个错误的返回产生后重新尝试调用 close() 函数是一个错误的做法, 因为这可能会导致其他线程重用的文件描述符被关闭. 会出现这种情况是因为 Linux 内核总是在关闭操作的早期释放文件描述符以便可以重用; 可能返回错误的步骤(例如将数据刷新到文件系统或设备中)仅发生在关闭操作的后期. 其他类似的实现即使它们之后会通过 close() 返回一个错误也总是会关闭文件(除了 EBADF 的情况, 这意味着文件描述符是无效的). POSIX.1 标准目前在这一点上保持沉默, 但有计划在标准的下一个大版本中强制要求此行为. 一个谨慎的程序员想要知道是否存在 I/O 错误可能会在 close() 之前先调用 fsync(2). EINTR 是一个有些特殊的情况. 关于 EINTR 错误, POSIX.1-2013 规定: 如果 close() 因为捕获信号而被中断, 它应该会返回 -1 并将 errno 设置为 EINTR, 这时文件描述符的状态是未定义的. 在 Linux 和许多其他实现中采用 EINTR 像 close() 可能产生的其他错误一样保证文件描述符被关闭的行为. 然而, 另一种可能也是被运行的: 采用返回 EINTR 错误并保持文件描述符是打开状态的实现.(根据文档, HP-UX 中的 close() 是这样做的.) 然后调用者再次调用 close() 去关闭文件描述符, 避免文件描述符泄漏. 实现行为的差异为可移植程序带来了一个困难的障碍. 因为在许多实现中, 出现 EINTR 错误之后不能再次调用 close(); 而在至少一个的实现中, 出现 EINTR 错误之后必须再次调用 close(). 在 POSIX.1 标准的下一个大版本中有机会解决这个难题.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>文件I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数 lseek()]]></title>
    <url>%2Flseek_function.html</url>
    <content type="text"><![CDATA[注: 基于 release 4.16 of the Linux man-pages project 整理 APUE 中未进行说明或与 Linux 存在不同的内容. 参考 lseek(2). 函数声明1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 描述 lseek() 运行将文件偏移量设置到文件结尾之外(但是这不会改变文件的大小). 如果在这之后数据被写入了这个位置, 则后续在这个间隙(“空洞(hole)”)的读操作将会返回空字节(\0), 直到数据实际被写入间隙. 寻找文件中的数据和空洞 从 3.1 版本开始, Linux 开始支持以下 whence 参数的新增值: SEEK_DATA: 将文件偏移量调整到文件中大于或等于 offset 参数的包含数据的下一个位置. 如果 offset 参数指向数据, 那么就把文件偏移量设置为 offset 参数. SEEK_HOLE: 将文件偏移量调整到文件中大于或等于 offset 参数的下一个空洞. 如果 offset 参数指向一个空洞中, 那么就把文件偏移量设置为 offset 参数. 如果 offset 参数后没有空洞了, 那么就把文件偏移量调整为文件结尾(即, 任何文件的结尾都隐含一个空洞). 以上的情况在 offset 参数指向超过文件结尾时调用 lseek() 都会失败. 这些操作使得应用程序可以在一个稀疏分配的文件中映射到一个空洞. 这种操作对类似文件备份工具等应用程序非常有用, 如果文件备份工具有发现空洞的机制, 就可以通过保留空洞在创建备份时节省空间. 在这些操作中, 空洞是指一系列没有写入底层文件存储中的零. 但是文件系统不被强制要求在文件存储中反映空洞, 因此这些操作对映射的文件实际分配的存储空间没有保障机制(即, 文件系统是不会确保在文件映射到存储空间时存在空洞, 因为那一系列零可以被写入底层存储). (此外, 实际已经写入底层存储的一系列零可能不会被作为一个空洞被反馈.) 在最简单的实现中, 文件系统可以通过使 SEEK_HOLE 始终返回文件结尾的偏移量来支持 SEEK_HOLE 操作, 使 SEEK_DATA 始终返回 offset 参数来支持 SEEK_DATA 操作(即, 即使 offset 参数指向的位置是一个空洞, 也可以认为它是由一系列零的数据组成). 在 CentOS Linux release 7.5.1804 实测发现当一系列零被写入底层存储时不会被认为是一个空洞, 写入数据时以 4096 为一个块进行写入. 数据在紧跟一系列零时, 如果数据不满 4096 的倍数时, 会写入紧跟的零进行不全, 这部分零将不算是空洞的一部分. 而剩下的零至少要大于等于 4096 才会形成空洞. 所以空洞开始位置是 4096 的倍数, 结束位置减去开始位置大于等于 4096. 为了可以在 &lt;unistd.h&gt; 中获取到 SEEK_DATA 和 SEEK_HOLE 的定义, 必须定义 _GNU_SOURCE 特征测试宏. 以下的文件系统支持 SEEK_DATA 和 SEEK_HOLE 操作: Btrfs (Linux 3.1 引入) OCFS (Linux 3.2 引入) XFS (Linux 3.5 引入) ext4 (Linux 3.8 引入) tmpfs(5) (Linux 3.8 引入) NFS (Linux 3.18 引入) FUSE (Linux 4.5 引入) 注意 POSIX.1 规定 off_t 类型是一个有符号整型. 一些设备不能使用 lseek(), POSIX 没有规定设备必须支持 lseek(). 在 Linux 上, 对管道文件, FIFO, socket 文件或终端设备使用 lseek() 会失败并生成 ESPIPE 错误.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>文件I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数 open(), creat() 和 openat()]]></title>
    <url>%2Fopen_creat_and_openat_function.html</url>
    <content type="text"><![CDATA[注: 基于 release 4.16 of the Linux man-pages project 整理 APUE 中未进行说明或与 Linux 存在不同的内容. 参考: open(2). 函数声明1234567891011#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);int creat(const char *pathname, mode_t mode);int openat(int dirfd, const char *pathname, int flags);int openat(int dirfd, const char *pathname, int flags, mode_t mode); 描述 成功, 返回值是一个非负的整数作为文件描述符用来标识打开的文件, 该值是当前进程文件描述符未使用的最小值; 失败返回 -1. 默认情况下文件偏移量指向文件开始位置. 调用 open() 时会创建一个打开文件描述(open file description), 它是整个系统范围内打开文件表中的一项条目. 这个条目记录了当前文件偏移量和文件状态标志(见 APUE 3rd 图 3-7). 文件描述符是打开文件描述的引用; 当 pathname 在之后被删除或被修改指向其他文件, 这个文件描述符也不会受到影响. 对于打开文件描述的进一步介绍, 参考后文注意. UNIX 系统中指定 flags 参数的标志中必选且只能选一种的访问模式: O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH. 而 Linux 实现了 O_RDONLY, O_WRONLY, O_RDWR 三种访问模式(O_PATH 特例, 参考下文介绍). UNIX 系统中指定 flags 参数的剩余标志中, Linux 没有实现 O_TTY_INIT 和 O_RSYNC 标志, 新增了一些标志(只介绍新增的标志或 APUE 3rd 中介绍不全面的标志). Linux 将剩余的标志分为两种: 文件创建标志: 影响打开操作本身的语义, 文件描述符标志. 非新增标志: O_CLOEXEC(Linux 2.6.23 引入): 注意, 在一些多线程程序中使用此标志是必要的. 因为使用一个单独的 fcntl(2) F_SETFD 操作去设置 FD_CLOEXEC 标志无法避免产生竞态条件, 即当一个线程打开一个文件描述符尝试使用 fcntl(2) 去设置 FD_CLOEXEC 标志时而另一个线程同时使用 fork(2) 和 execve(2). 根据执行的顺序, 竞争有可能导致 open() 返回的文件描述符被无意泄漏给由 fork(2) 创建的子进程执行的程序. 原则上来说, 这种竞争可能发生在任何创建文件描述符的系统调用中, 它们都应该设置执行时关闭(close-on-exec) 标志, 其余各种 Linux 系统调用也都提供了等同于 O_CLOEXEC 标志去处理这个问题(例如, socket(2) 的 SOCK_CLOEXEC 标志. O_CREAT: 新建文件的所有者(UID) 被设置为当前进程的有效 UID(euid). 新建文件的所属组(GID) 被设置为当前进程的有效 GID(egid)(System V 语义) 或父目录的 GID(BSD 语义). 在 Linux 上, 具体的行为依赖于父目录的 set-group-ID 权限位是否被设置: 如果这个权限位被设置, 就应用 BSD 语义; 否则就应用 System V 语义. 在一些文件系统中, 具体的行为也依赖于 mount(8) 中描述的 badgroups 和 sysvgroups 挂载选项. mode 参数在 flag 参数中设置了 O_CREAT 和 O_TMPFILE 时必须设置. 使用 open() 创建一个只读文件可能会返回一个可读/写文件描述符(在 centos release 6.5/7.5.1804 上实测没有发现). O_TRUNC: 如果文件已存在并且是常规文件且访问权限允许写入(即，使用 O_RDWR 或 O_WRONLY), 文件的长度将被截断为 0. 如果文件是 FIFO 或终端设备文件, 就忽略 O_TRUNC 标志. 否则, O_TRUNC 的影响未定义. O_RDONLY | O_TRUNC 的效果(未定义) 是随着具体的实现变化的. 在许多系统上, 文件实际上已被截断.(CentOS Linux release 7.5.1804 上实测已截断.) 新增标志: O_TMPFILE (Linux 3.11 引入): 创建一个没有名字的临时文件. pathname 参数指定一个目录; 在这个目录的文件系统中会创建一个没有命名的 inode. 任何对生成文件的写操作都将会在最后文件描述符被关闭时丢弃, 除非为文件设置一个名字. 指定 O_TMPFILE 时必须指定 O_RDWR 或 O_WRONLY 之一, O_EXCL 为可选项. 如果没有指定 O_EXCL, 可以使用 linkat(2) 将临时文件链接到文件系统, 使其成为永久文件, 使用如下代码: 1234567char path[PATH_MAX];fd = open("/path/to/dir", O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);/* File I/O on 'fd'... */snprintf(path, PATH_MAX, "/proc/self/fd/%d", fd);linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file", AT_SYMLINK_FOLLOW); 在这种情况下, 通过 open() 的 mode 参数确定文件的权限, 就像使用 O_CREAT 一样. 为 O_TMPFILE 关联指定 O_EXCL 标志可以防止临时文件以上述方式链接到文件系统.(注意: 这种情况下 O_EXCL 的含义和其他情况下 O_EXCL 的含义是不同的.) 两种使用 O_TMPFILE 的主要情景是: 改进 tmpfile(3) 功能: 无竞争创建的临时文件: 在关闭时自动删除. 永远不能通过任何路径访问. 不受符号链接攻击. 不需要调用者设计唯一的名称. 创建一个原始不可见的文件, 然后填充数据并调整为具有适当的文件系统属性(fchown(2), fchmod(2), fsetxattr(2) 等), 然后在完全形成的状态下原子行的链接到文件系统中(使用之前介绍的 linkat(2)). O_TMPFILE 需要底层文件系统支持; 只有一个 Linux 文件系统的一个子集提供支持. 在最初的实现中, ext2, ext3, ext4, UDF, Minix 和 shmem 文件系统提供支持. 随后添加了对其他文件系统的支持, 如 XFS(Linux 3.15), Btrfs(Linux 3.16), F2FS(Linux 3.16) 和 ubifs(Linux 4.9). 文件状态标志: 影响后续 I/O 操作的语义. 非新增标志: O_APPEND: 每次 write(2) 之前都会像使用 sleek(2) 一样将文件偏移量移动到文件末尾. 文件偏移量的移动和写操作被作为一个原子操作来完成. 如果多进程同时追加数据到同一个文件, 可能导致 NFS 文件系统上的文件损坏. 这是因为 NFS 不支持在文件后追加的操作, 所以客户端内核必须模拟追加操作, 这(多进程追加操作)一定会产生竞态条件. O_DSYNC: 文件的写操作将完全符合同步 I/O 数据完整性实现(synchronized I/O data integrity completion)[^1] 的要求. 参考后文注意. 在 write(2)(或类似写入操作)返回之前, 输出数据以及读取这些数据所需要的元数据都已经被写入底层硬件设备了(即, 就像在每个 write(2) 操作后都调用一次 fdatasync(2)). 参考后文注意. O_EXCL: 当该标志与 O_CREAT 一起被指定, 如果 pathname 参数是一个符号链接, 那么无论符号链接指向何处, open() 函数都会失败. 通常情况下, 如果不使用 O_CREAT, 那么 O_EXCL 的行为将是未定义的. 在 Linux 2.6 及以后版本, 如果 pathname 参数如果指向一个块设备, O_EXCL 可以在没有 O_CREAT 的情况下使用. 如果这个块设备正在被系统使用(例如已经挂载), 那么 open() 将会失败, 并产生 EBUSY 错误. 在 NFS 中, O_EXCL 仅在 NFSv3 及以后版本运行在内核版本大于等于 2.6 的系统上时才会被支持. O_NOFOLLOW: 如果 pathname 参数是一个符号链接, 那么 open() 会出错并产生 ELOOP 错误. 注意: 这种情况下产生的 ELOOP 与因为在解析路径名前缀部分的组件发现太多符号链接而导致 open() 会出错而产生的 ELOOP 错误是无法区分的. O_NONBLOCK 或 O_NDELAY: 注意: 这个标志对普通文件或块设备不会生效; 无论是否设置 O_NONBLOCK, I/O 操作在将在需要设备活动时(暂时)阻塞. 因此在为常规文件和块设备指定此标志时, 应用程序不应依赖于阻塞行为. 有关FIFO(有名管道)的处理, 参考 fifo(7). O_NONBLOCK 一般用来为 ioctl(2) 提供一个设备的文件描述符. O_SYNC: 文件的写操作将完全符合同步 I/O 文件完整性实现(synchronized I/O file integrity completion)[^1] 的要求(对比 O_DSYNC 中的同步 I/O 数据完整性实现(synchronized I/O data integrity completion)[^1]). 参考后文注意. 在 write(2)(或类似写入操作)返回之前, 输出数据和关联元数据都已经被写入底层硬件设备了(即, 就像在每个 write(2) 操作后都调用一次 fsync(2)). 参考后文注意. 新增标志: O_ASYNC: 启动信号驱动 I/O: 当返回的文件描述符变为可以输入或输出(也可能发生错误)时, 生成一个信号(默认为 SIGIO, 可以通过 fcntl(2) 修改). 仅适用于终端, 伪终端, 套接字, 管道(Linux 2.6 引入) 和 FIFO( Linux 2.6 引入). 详细信息参阅 fcntl(2). 当前存在 BUG, 调用 open() 指定 O_ASYNC 无法启动信号驱动 I/O, 需要使用 fcntl(2) 去启动这个标志. O_DIRECT(Linux 2.4.10 引入)[^1]: 尝试文件 I/O 最小化缓存的效果. 通常这会降低性能, 但是在例如应用需要操作自己的缓存这种特定的情况下会有用. 文件 I/O 会直接操作用户空间的缓冲区. 该标志自身会完成数据同步传输的工作, 但是不能保证像 O_SYNC 一样传输数据和元数据. 为了确保同步 I/O, 在设置 O_DIRECT 时必须设置 O_SYNC. O_LARGEFILE: 允许打开文件大小使用 off_t 不能表示(但是可以使用 off64_t 表示)的文件. 为了使这个标志生效必须定义 _LARGEFILE64_SOURCE 宏(在包含任何头文件之前). 将 _FILE_OFFSET_BITS 功能测试宏设置为 64 (而不是使用 O_LARGEFILE)是在 32 位系统上访问大文件更好的方式(参考 feature_test_macros(7)).[^2] O_NOATIME(Linux 2.6.8 引入): 当 read(2) 操作文件时, 不更新文件最后访问时间(inode 中的 st_atime). 只有以下两个条件中的一个成立时, 这个标志才能生效: 当前进程有效 UID(euid) 与 文件的所有者 UID 相匹配. 调用进程在他的用户命名空间[^3][^4][^5]具有 CAP_FOWNER 能力[^6] 并且文件的 UID 在命名空间中存在映射. 这个标志适用于所有或备份程序, 这时使用这个标志可以显著减少磁盘活动量. 这个标志可能不是在所有的文件系统上都生效, 例如使用 NFS 服务器会一直维护访问时间. O_PATH(Linux 2.6.39 引入): 获取的文件描述符可用于两个目的: 指示文件系统树上的一个位置, 并执行纯粹文件描述符级别的操作. 文件本身没有被打开, 其余的文件操作(例如 read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), ioctl(2), mmap(2)) 都会失败并生成 EBADF 错误. 获取的文件描述符可以执行下列操作: close(2). fchdir(2), 当这个文件描述符表示一个目录时(Linux 3.5 引入). fstat(2) (Linux 3.6 引入). fstatfs(2) (Linux 3.12 引入). 复制文件描述符(dup(2), fcntl(2) F_DUPFD, 等). 获取和设置文件描述符标志(fcntl(2) F_GETFD 和 F_SETFD). 使用 fcntl(2) F_GETFD 查看文件状态标志: 返回的标志包括 O_PATH 位. 使用这个文件描述符作为 openat() 和其他 *at() 系统调用的 dirfd 参数. 即使这个文件描述符指向的不是一个目录也可以用于使用 AT_EMPTY_PATH(或通过 procfs 使用 AT_SYMLINK_FOLLOW) 的 linkat(2). 通过 UNIX 域套接字将文件描述符传递给其他进程(参考 unix(7) 中的 SCM_RIGHTS). 当 flag 参数设置了 O_PATH, 除了 O_CLOEXEC, O_DIRECTORY 和 O_NOFOLLOW 以外的标志位将被忽略. 使用 O_PATH 表示打开文件或目录不需要检查对象本身的权限(但需要路径前缀的目录具有可执行权限). 而后续的操作可以对进件进行适合的权限检查(例如, fchdir(2)) 需要文件描述符指向的目录具有可执行权限). 相反的, 即使后续操作(例如, fchdir(2), fstat(2)) 的执行不需要对这个对象具有可读权限, 使用 O_RDONLY 标志打开文件系统上的一个对象也需要调用者具有对这个对象的可读权限. 如果 pathname 参数是一个符号链接, 并且设置了 O_NOFOLLOW 标志, 这次调用将返回一个指向这个符号链接的文件描述符. 在调用 fchownat(2), fstatat(2), linkat(2) 和 readlink(2) 路径相关参数为空时, 这个文件描述符可以作为 dirfd 参数用于对这个符号链接的操作. 如果 pathname 指向的是一个没有被触发的自动挂载节点, 这是没有任何文件系统挂载这个节点, 那么 open() 将返回指向自动挂载目录的文件描述符, 而不会触发挂载. 之后可以使用 fstatfs(2) 来确定它是否实际上是未触发的自动挂载点(.f_type == AUTOFS_SUPER_MAGIC). O_PATH 对于普通文件的一种用法是提供一种等价于 POSIX.1 中 O_EXEC 标志的功能. 这允许我们在只有可执行权限却没有可读权限时打开一个文件, 然后执行这个文件. 这类似与下面的步骤: 1234char buf[PATH_MAX];fd = open("some_prog", O_PATH);snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);execl(buf, "some_prog", (char *) NULL); 一个使用 O_PATH 打开的文件描述符也可以作为 fexecve(3) 的参数进行传递. creat() 等价于 flags 参数为 O_CREAT | O_WRONLY | O_TRUNC 的 open() 函数. openat() 用法参考 APUE 3.3. 注意 open() 可以打开一个指定的设备文件, 但是 create() 不能创建设备文件, 使用 mknod(2) 替代. 如果是新创建文件, 它的 st_atime, st_ctime, st_mtime 属性(分别是 time of last access, time of last status change, time of last modification, 参考 stat(2)) 和它的父目录的 st_ctime, st_mtime 设置为当前时间. 除此之外, 如果文件在设置 O_TRUNC 标志时被修改, 它的 st_ctime, st_mtime 也被设置为当前时间. /proc/[pid]/fd 目录中的文件表示 PID 为 pid 的进程打开的文件描述符. /proc/[pid]/fdinfo 目录中的文件表示这些文件描述符的详细信息. 可以参考这些目录在 proc(5) 中的进一步介绍. 打开文件描述(Open file descriptions) 术语打开文件描述(Open file description) 是 POSIX 中规定的整个系统范围内打开文件表中的条目. 在其他的情境中, 这个对象也被称为 open file object, file handle, open file table entry 或被内核开发者称为 struct file. 当复制(使用 dup(2) 或类似方式) 一个文件描述符时, 副本和原始的文件描述符引用的是同一个打开文件描述, 这导致两个文件描述符共享文件偏移量和文件状态标志. 这样的共享也可发生在两个不同的进程中: 子进程通过 fork(2) 复制了父进程的所有文件描述符, 副本和原始的文件描述符引用的是相同的打开文件描述. 每次调用 open() 会生成一个新的打开文件描述, 因此可能会有多个打开文件描述对应同一个文件 inode.(参考 APUE 中 3.10.) 在 Linux 中, 可以使用 kcmp(2) KCMP_FILE 操作去测试是否有两个文件描述符(在同一个进程或不同进程)指向了同一个打开文件描述. 同步 I/O(Synchronized I/O) 在 POSIX.1-2008 中 synchronized I/O 定义了不同的变种, 它定义了 open() 用于控制同步行为的 O_SYNC, O_DSYNC 和 O_RSYNC 标志. 无论具体的实现是否支持不同的同步行为, 它都至少必须支持普通文件的 O_SYNC. Linux 实现了 O_SYNC 和 O_DSYNC, 但是没有实现 O_RSYNC.(准确的说, glibc 中将 O_RSYNC 定义为与 O_SYNC 相同). O_SYNC 提供同步 I/O 文件完整性实现(synchronized I/O file integrity completion)[^1]: 这意味着写操作将会刷新数据和所有关联的元数据到底层硬件. O_DSYNC 提供同步 I/O 数据完整性实现(synchronized I/O data integrity completion)[^1]: 这意味着写操作将会刷新数据到底层硬件, 但是对于元数据只会刷新后续成功完成读操作所需要更新的元数据. 数据完整性实现可以减少不需要文件完整性实现保证的应用的磁盘操作次数. 要理解这两种不同实现的区别需要考虑两个文件元数据: 最后修改时间戳(st_mtime) 和文件长度. 所有的写操作都会更新最后修改时间戳, 但是只有在文件为追加写数据时才会改变文件长度. 成功完成一个读操作不需要确保最后修改时间戳是正确的, 但是文件长度需要. 因此 O_DSYNC 只需要保证刷新文件长度元数据的更新(而 O_SYNC 总是也需要刷新最后修改时间戳元数据). 在 Linux 2.6.33 之前, Linux 为 open() 只实现了 O_SYNC 标志. 然而当指定这个标志时, 大多数文件系统实际提供相当于同步 I/O 数据完整性实现(synchronized I/O data integrity completion)[^1] 的操作(即, O_SYNC 实际上实现了相当于 O_SYNC 的功能). 从 Linux 2.6.33 开始, 提供了正确的 O_SYNC 的支持. 然而为了确保二进制向后兼容, O_DSYNC 被定义为和就以前的 O_SYNC 相同的标志值, O_SYNC 被定义为一个包含 O_DSYNC 的新标志值(占两位). 这样可以确保使用新的头文件编译的应用程序在 2.6.33 之前的内核上至少可以使用 O_DSYNC 功能. C 函数库和内核的差异 从 glibc 2.26 开始, 使用 openat() 系统调用封装 open() 函数, 而不是使用内核的 open() 系统调用. 在某些架构中, glibc 2.26 之前的版本也是这样的. NFS NFS 基础协议中存在许多不足之处, 其中包括 O_SYNC 和 O_NDELAY. 当 NFS 文件系统开启 UID 映射时, open() 函数可能会返回一个文件描述符, 但是会出现如 read(2) 请求被拒绝产生 EACCES 错误的情况. 这是因为客户端执行 open() 是会检查权限, 但是 UID 映射时由服务器在读操作和写操作请求时执行的. 文件访问模式 与在 flags 参数中能指定的其他值不同, 访问模式 O_RDONLY, O_WRONLY 和 O_RDWR 不能指定单独的位. 相反, 它们被一起定义在 flags 参数的低两位表示, 分别是 0, 1 和 2. 也就是说 O_RDONLY 和 O_WRONLY 一起指定是一种逻辑错误, 与 O_RDWR 没有相同含义. Linux在 flags 中保留特殊的非标准访问模式 3 (二进制 11), 它意味着: 检查文件的读写权限并返回一个不能用于读操作或写操作的文件描述符. 某些 Linux 驱动程序使用这个非标准访问模式来返回仅用于特定设备的 ioctl(2) 操作的文件描述符. openat() 和其他目录文件描述符 APIs 的基本原理 加入目录文件描述符参数的 openat(), 其他系统调用和 C 库函数(即 execveat(2), faccessat(2), fanotify_mark(2), fchmodat(2), fchownat(2), fstatat(2), futimesat(2), linkat(2), mkdirat(2), mknodat(2), name_to_handle_at(2), readlinkat(2), renameat(2), statx(2), symlinkat(2), unlinkat(2), utimensat(2), mkfifoat(3) 和 scandirat(3)) 解决了它们之前旧接口存在的两个问题. 这里虽然是对 openat() 调用的说明, 但是其他接口的基本原理类似. 第一, openat() 可以使应用程序避免当使用 open() 函数打开一个工作目录以外的目录中的文件时产生的竞态条件. 这种竞态条件的产生是由于提供给 open() 函数的目录前缀的某些部件在调用 open() 函数时被并行修改了. 例如, 假设 dir1/dir2/xxx 文件已经存在, 我们希望创建 dir1/dir2/xxx.dep 文件. 问题是在进行文件是否存在的检查和创建文件两个步骤之间, dir1 或 dir2(可能是符号链接) 可以被改变指向一个不同的地点. 因此, 通过先打开目标目录的文件描述符, 然后再将这个文件描述符作为(举例) fstatat(2) 或 openat() 的 dirfd 参数使用就可以避免这种竞态. dirfd 文件描述符的使用也有以下的好处: 文件描述符是使用目录的稳定引用, 即使使用的目录被改名也不会影响; 打开的文件描述符可以防止底层文件系统被卸载, 就好像像在文件系统上有一个进程当前的工作目录一样. 第二, openat() 可以通过应用程序维护目录文件描述符实现每个线程一个”当前工作目录”.(这个功能也可以通过基于使用 /proc/self/fd/dirfd 的技巧获得, 但这种做法的效率较低.) BUGS 目前无法通过调用 open() 函数指定 O_ASYNC 标志的方式启动信号驱动 I/O; 应使用 fcntl(2) 开启. 在尝试确定内核是否支持 O_TMPFILE 功能时, 必须检查两个不同的错误代码 EISDIR 和 ENOENT. 当在 flags 参数中指定了 O_CREAT 和 O_DIRECTORY 标志且 pathname 指定的文件不存在时, open() 函数将创建一个普通文件(即, 忽略 O_DIRECTORY)(在 centos release 6.5/7.5.1804 上实测生成的文件会具有 setuid 和 setgid 权限). 参考资料 UNIX高级环境编程（14）文件IO - O_DIRECT和O_SYNC详解 Linux下生成1TB的超大文件 namespace(7) user_namespaces(7) Linux Namespace : User capability(7)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>文件I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSIX Threads Programming]]></title>
    <url>%2FPOSIX_Threads_Programming.html</url>
    <content type="text"><![CDATA[翻译自: POSIX Threads Programming 摘要在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于UNIX 系统, IEEE POSIX 1003.1c 标准已经规定了一个标准化的 C 语言线程编程接口. 遵循此标准的实现称为 POSIX线程 或 Pthreads. 本教程首先介绍使用Pthreads的概念, 动机和设计意图. 然后介绍 Pthreads API 中三大种类每一种示例程序: 线程管理, 互斥变量和条件变量. 示例代码始终被用来演示一个新的 Pthreads 程序员所需要的如何使用大多数 Pthread. 本教程最后讨论了 LLNL 细节以及如何将 MPI 与 Pthreads 混合使用. 还包括一个实验练习, 其中包含大量示例代码(C语言). 水平/先决条件: 本教程非常适合那些不熟悉Pthreads并行编程的人. 需要对 C 中的并行编程有基本的了解. 对于那些一般不熟悉并行编程的人来说, EC3500: Introduction to Parallel Computing 中的内容有所帮助. Pthreads Overview(Pthreads 概述)什么是线程? 从技术上讲, 线程被定义为一个可以被操作系统调度运行的独立指令流. 但是这是什么意思? 对于软件开发者来说, 独立于其主程序运行的 procedure(过程) 的概念可能可以最好的描述一个线程. 更进一步来说, 假设一个一个主程序(a.out)有多个过程, 这些过程可以被操作系统调度的同时和/或独立运行. 这被称作一个 multi-threaded 程序. 这是如何完成的? 在理解线程之前, 首先需要理解 UNIX 进程. 进程由操作系统创建, 需要相当数量的开销负担. 进程包含有关程序资源和程序执行状态的信息如下: 进程ID, 进程组ID, 用户ID, 用户组ID 环境变量 工作目录 寄存器 栈 堆 文件描述符 信号 动态库 进程间通信工具(如消息队列, 管道, 信号量或共享内存) 线程使用进程的资源并存在于进程中, 但是线程能够由操作系统调度并作为独立实体运行, 主要是因为线程只复制了使它们可以作为可执行代码存在的基本必需资源. 这种独立的控制流程能够完成是因为线程维持了它独有的: 堆栈指针 寄存器 调度属性(例如策略或优先级) 一组待处理和阻止的信号 总而言之, UNIX 环境中的一个线程: 存在于一个进程中, 并使用该进程的资源. 只要线程的父进程存在且操作系统支持, 它就有自己独立的控制流程. 仅复制其可独立调度所需的基本资源. 可以与其他线程共享进程资源, 这些线程同样是独立地, 并且依赖于进程存在. 如果父进程死亡则死亡(or something similar). 是 lightweight(轻量级) 的, 因为大部分开销已经通过创建进程完成了. 因为同一进程中的线程共享资源: 所有其他线程将看到一个线程对共享系统资源(例如关闭文件)所做的更改. 具有相同值的两个指针指向相同的数据. 可以读取和写入相同的存储器位置, 因此需要程序员进行显式同步. 什么是 Pthreads? 在历史上, 硬件供应商已经实现了他们自己专有的线程版本. 这些实现彼此差异很大使得程序员很难开发具有可移植性的线程应用程序. 为了充分利用线程提供的功能, 需要标准化的编程接口: 对于 UNIX 系统, 该接口已由 IEEE POSIX 1003.1c 标准(1995)指定. 遵循此标准的实现称为 POSIX 线程或 Pthreads. 除了专有 API 之外，大多数硬件供应商现在都提供 Pthreads. POSIX 标准(包括 Pthreads 规范)仍在不断发展和修订. 一些有用的链接: standards.ieee.org/findstds/standard/1003.1-2008.html www.unix.org/version3/ieee_std.html www.unix.org/version3/ieee_std.html Pthread 被定义为一组 C 语言类型和函数调用, 使用 pthread.h 头文件和一个线程库实现(尽管在某些实现中该库可能是另一个库的一部分, 例如 libc). 为什么选择 Pthreads?轻量级 与创建和管理进程的成本相比, 可以创建一个具有更少操作系统开销的线程. 管理线程比管理进程需要更少的系统资源. 例如, 下表比较了 fork() 子函数和 pthread_create() 子函数的计时结果. 使用 time 程序计时反映了50000个进程/线程创建, 单位是秒, 没有使用编译优化. 注意: 不要期望 sys time + user time 等于 real time, 因为这是具有多个 CPUs/cores 的 SMP 系统同时处理该问题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*==============================================================================C Code for fork() creation test==============================================================================*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NFORKS 50000void do_nothing() &#123;int i;i= 0;&#125;int main(int argc, char *argv[]) &#123;int pid, j, status;for (j=0; j&lt;NFORKS; j++) &#123; /*** error handling ***/ if ((pid = fork()) &lt; 0 ) &#123; printf ("fork failed with error code= %d\n", pid); exit(0); &#125; /*** this is the child of the fork ***/ else if (pid ==0) &#123; do_nothing(); exit(0); &#125; /*** this is the parent of the fork ***/ else &#123; waitpid(pid, status, 0); &#125; &#125;&#125; /*==============================================================================C Code for pthread_create() test==============================================================================*/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NTHREADS 50000void *do_nothing(void *null) &#123;int i;i=0;pthread_exit(NULL);&#125; int main(int argc, char *argv[]) &#123;int rc, i, j, detachstate;pthread_t tid;pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);for (j=0; j&lt;NTHREADS; j++) &#123; rc = pthread_create(&amp;tid, &amp;attr, do_nothing, NULL); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; /* Wait for the thread */ rc = pthread_join(tid, NULL); if (rc) &#123; printf("ERROR; return code from pthread_join() is %d\n", rc); exit(-1); &#125; &#125;pthread_attr_destroy(&amp;attr);pthread_exit(NULL);&#125; source 高效的通信/数据交换 考虑在高性能计算环境中使用 Pthreads 的主要动机是为了实现最佳性能, 特别是当应用程序使用 MPI 进行节点间通信时, 通过使用 Pthreads 可以改善性能. MPI 对于Pthreads, 可以不需要中间内存复制, 因为线程在单个进程中共享同一地址空间; 可以通过指针方便的实现高效的数据传递. 在最坏的情况下, Pthreads 通信速度更多的变成了缓存到 CPU 或内存到 CPU 的带宽问题, 但是这样的速度仍然远高于 MPI 共享内存通信的速度. 例如: 这里有一些过去和当前的对比数据如下所示: 其他常见原因 与非线程应用程序相比, 线程应用程序在以下几个方面提供了潜在的性能提升和实用优势: 当进行 I/O 操作时使用 CPU: 例如, 一个程序可能有长时间 I/O 操作的部分, 当一个线程正在等待 I/O 系统调用完成时, 其他线程可以执行 CPU 密集型工作. 优先级/实时调度: 更重要的任务可以被调度取代或重大优先级更低的任务. 异步的事件处理: 可以交错执行有不确定频率和持续时间的服务事件的任务. 例如, Web 服务器既可以从先前的请求传输数据, 也可以管理新请求的到达. 一个完美的例子是典型的 Web 浏览器, 其中许多交错任务可以同时发生, 并且任务可以在优先级上变化. 另一个很好的例子是现代操作系统, 线程得到了广泛使用, MS Windows 操作系统和使用线程的应用程序的屏幕截图如下所示: 设计线程程序并行编程 在现代的多核机器上, Pthreads 非常适合并行编程. 适用于一般并发编程的都可以使用并发线程程序. 设计并行程序有很多注意事项, 例如: 使用什么类型的并行编程模型? 问题分区 负载均衡 通信 数据依赖性 同步和竞争条件 内存问题 I/O 问题 程序复杂性 程序员的努力/成本/时间 … 这些问题超出了本教程涵盖的范围, 但是感兴趣的读者可以在Introduction to Parallel Computing教程中快速了解概念. 通常, 为了能够利用 Pthreads, 程序必须能够组织成分散的可以并发执行的独立任务. 例如, 如果函数1和函数2可以被交替执行(实时交错和/或重叠), 它们将可以成为线程. 具有以下特征的程序可能非常适合 Pthreads: 同时由多个任务执行的工作或操作的数据 因为长时间 I/O 产生的阻塞 一些地方消耗大量 CPU 周期, 其他地方不消耗(CPU 使用不均匀) 必须响应的异步事件 有些工作比其他工作更重要(优先中断) 存在几种用于线程程序的常见模型 Manager/worker: 在一个线程(manager)中将工作分配给其他线程(worker). 通常, manager 处理所有输入和封装工作到其他任务中. 在 manager/worker 模式中至少有两种形式是常见的: 静态线程池和动态线程池. Pipeline: 任务被分解为一系列子操作, 每个子操作都是串行处理的, 但由不同的线程并行处理. 汽车装配线最能描述这种模型. Peer: 类似于 manager/worker 模型, 共享内存模型 所有线程都可以访问相同的全局共享内存 线程也有自己的私有数据 程序员负责同步访问(保护)全局共享数据 线程安全 线程安全: 简而言之, 指一个程序具有同时执行多个线程而不破坏共享数据或产生 race conditions 的能力. 例如, 假设你的应用程序创造几个线程, 每一个线程都调用同一个库函数: 这个库函数访问或修改一个全局结构体或指针. 每一个线程可能会调用这个函数在同一时间去尝试修改这个全局结构体或指针. 如果函数不使用某种同步的修改方式来防止数据损坏, 那么这个它就不是线程安全的. 这意味着使用外部库函数如果不能 100% 确定它是线程安全的, 那么就需要抓住机会解决可能出现的问题. 建议: 如果应用程序使用没有明确保证线程安全的库或对象, 请务必小心. 如果对线程安全有疑问, 那么除非另有证明, 否则假设它不是线程安全的. 可以通过有序访问有疑问的函数等方式保证线程安全. 线程限制 尽管 Pthreads API 是 ANSI/IEEE 标准, 但是它的实现方式标准并未指定, 通常在不同平台会有所变化. 因此, 在一个平台上运行良好的程序, 在另一个平台上运行可能失败或产生错误. 例如, 允许的最大线程数和默认线程堆栈大小是设计程序时要考虑的两个重要限制. 本教程后面将详细讨论几个线程的限制. The Pthreads API ANSI / IEEE POSIX 1003.1-1995 标准中定义了最初的 Pthreads API. POSIX 标准(包括 Pthreads 规范)在不断发展和修订. 标准的副本可以从IEEE购买或从其他网站免费下载. 组成 Pthreads API 的函数可以被非正式的划分为四个类别: 线程管理: 直接作用于线程的函数 - creating, detaching, joining, 等. 还包括设置/查询线程属性的函数(joinable, scheduling, 等). 互斥锁: 处理同步的函数, 被称为 mutex, 是 mutual exclusion 的缩写. 互斥函数提供 creating, destroying, locking 和 unlocking 互斥锁功能. 还包括用于设置或修改与互斥锁相关联属性的互斥锁属性函数. 条件变量: 解决共享互斥锁的线程之间的通信问题的函数. 这基于程序员指定的条件. 这一类包括基于指定条件变量的 create, destroy, wait 和 signal 函数. 还包括用于设置/查询条件变量属性的函数. 同步: 管理读写锁和同步屏障(barriers)的函数. 命名约定: 线程库以 pthread_ 开头作为标识. 如下有一些例子: Routine Prefix Functional Group pthread_ 线程本身和杂项的函数 pthread_attr_ 线程属性对象 Pthread_mutex_ 互斥锁 pthread_mutexattr_ 互斥锁属性对象 pthread_cond_ 环境变量 pthread_condattr_ 环境变量属性对象 pthread_key_ 用于特定线程的数据密钥 pthread_rwlock_ 读写锁 pthread_barrier_ 同步屏障 不透明对象的概念遍及API的设计. 基本调用用于创建或修改不透明对象 - 可以通过调用属性函数来修改和处理不透明对象. Pthreads API 包含大约100个子函数. 本教程将重点介绍其中的一部分 - 特别是那些对刚刚开始使用 Pthreads 的程序有用的内容. 为了可移植性, 在使用 Pthreas 库时应该将 pthread.h 包含在每个源文件中. 当前的 POSIX 标准仅针对 C 语言定义. Fortran 程序员可以使用 C 函数调用的封装. 一些 Fortran 编译器可能提供 Fortran pthreads API. 有很多关于Pthreads的优秀书籍. 其中一些列在本教程的参考部分中. 编译线程程序 下表列出了几个用于 Pthreads 代码的编译命令示例: 线程管理创建和终止线程函数12345int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);void pthread_exit(void *retval);int pthread_cancel(pthread_t thread);int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr); 创建线程 最开始, main() 函数包含一个默认线程. 所有其他线程必须由程序员显式创建. pthread_create 创建一个新的线程并执行它. 这个函数可以在代码任何位置任意调用. pthread_create 参数: thread: 输出参数, 新线程唯一的不透明标识符. attr: 可用于设置线程属性的不透明属性对象. 你可以指定一个线程属性对象或使用 NULL 的默认值. start_routine: 线程创建后执行的 C 函数. arg: 传递给 start_routine 的单个参数, 必须通过转换为 void 类型指针进行传递. 如果不传递参数, 可以使用 NULL. 进程可以创建的最大线程数取决于系统设置. 尝试超出限制的程序可能会失败或产生错误的结果. 这里以 Linux 为例, 介绍查询和设置系统的线程限制. 下图演示查询默认线程(软)限制, 然后将最大进程(包括线程)数设置为硬限制, 验证设置是否成功. 一旦创建完成, 线程之间就是平等的, 并且可以创建其他线程. 线程之间没有隐含的层次结构或依赖关系. 线程属性 在默认情况下, 使用某些属性创建一个线程. 这些属性可以被程序员通过线程属性对象修改. pthread_attr_init 和 pthread_attr_destroy 初始化/销毁线程属性对象. 之后使用其他函数查询/设置线程属性对象中的特定属性. 属性包括: Detached(已分离)或 joinable(可合并)状态 Scheduling inheritance Scheduling policy(调度策略) Scheduling parameters(调度参数) Scheduling contention scope 栈大小 栈地址 Stack guard (overflow) size 其中一些属性将在后面讨论. 线程的绑定和调度 问题: 当一个线程被创建后, 你如何知道: 操作系统何时调度它运行? 它将运行在哪个 CPU/core? 答案: 除非你使用 Pthreads 调度机制, 否则线程的执行位置和时间将由操作系统和系统设置决定. 健壮的程序不应该依赖于以特定顺序或在特定 CPU/core 执行的线程. Pthreads API 提供了几个用于指定线程执行调度方式的函数. 例如, 可以将线程以 FIFO(先进先出), RR(循环), OTHER(操作系统确定) 等方式调度. 它还提供了设置线程调度优先级的功能. 本教程没有涉及这个话题, 但是在 man page 的 sched_setscheduler 中有它 工作原理 的概述. Pthreads API 不提供将线程绑定到特定 CPU/core 的函数. 但系统的线程库可能提供了自己实现的这个功能 - 例如提供一个非标准的 pthread_setaffinity_np 函数. 请注意, 名称中的 _np 代表 非便携式. 此外, 操作系统自身也提供这种功能的方法, 例如 Linux 提供了 sched_setaffinity 函数. 终止线程 &amp; exit() 有几种方法可以终止一个线程: 线程执行完启动函数正常退出, 它已经完成工作. 线程调用 pthread_exit 子函数 - 无论其工作是否完成都会退出. 线程由另一个线程通过 pthread_cancel 函数取消. 线程调用 exec() 整个进程将终止被替换为另一个进程; 调用 exit() 这个进程将终止. 主线程 main() 首先完成, 其他线程将在没有调用 pthread_exit 的情况下终止. pthread_exit() 函数允许程序员指定一个可选的终止 retval 参数. 此可选参数通常返回到 joining 终止线程的线程中(稍后介绍). 除非想要传回可选参数, 否则在正常执行完成的子程序中, 可以省去调用 pthread_exit(). 清理: pthread_exit() 函数不会关闭文件; 在线程终止后, 线程内打开的任何文件都将保持打开状态. 在 main() 中调用 pthread_exit() 的讨论: 如果你没有显式调用 pthread_exit(), 但是 main() 函数先于它创建的线程退出, 那么肯定存在问题. main() 创建的所有线程都将终止, 因为它已经退出, 不在支持其他线程. main() 可以通过在最后显式调用 pthread_exit(), main() 将阻塞并保持活跃状态以支持它创建的线程, 直到它们完成为止. 示例: 线程的创建和终止 这是使用 pthread_create() 函数创建 5 个线程的简单示例代码. 每个线程输出 Hello World! 消息, 然后调用 pthread_exit() 退出. 1234567891011121314151617181920212223242526272829303132333435363738/******************************************************************************* FILE: hello.c* DESCRIPTION:* A "hello world" Pthreads program. Demonstrates thread creation and* termination.* AUTHOR: Blaise Barney* LAST REVISED: 08/09/11******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 5void *PrintHello(void *threadid)&#123; long tid; tid = (long)threadid; printf("Hello World! It's me, thread #%ld!\n", tid); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0;t&lt;NUM_THREADS;t++)&#123; printf("In main: creating thread %ld\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); if (rc)&#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; /* Last thing that main() should do */ pthread_exit(NULL);&#125; source output 将参数传递给线程 pthread_create() 线程允许程序员将一个参数传递给线程的启动函数. 对于必须传递多个参数的情况, 可以创建一个包含所有参数的结构体, 在 pthread_create() 函数中传递这个结构体的指针实现. 所有参数必须通过引用传递并转换为 (void *) 类型. 问题: 考虑在不确定线程是否启动和调度的情况下, 如何将数据安全的传递给新创建的线程? 答案: 确保所有的数据都是线程安全的 - 数据不能被其他线程更改. 接下来的三个示例说明什么是可以做的, 什么是不能做的. 线程参数传递示例 这个代码展示了如何将简单的整型传递给每一个参数. 使用唯一的数据结构变量调用线程, 以确保每个线程的参数在整个程序中保持不变. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/******************************************************************************* FILE: hello_arg1.c* DESCRIPTION:* A "hello world" Pthreads program which demonstrates one safe way* to pass arguments to threads during thread creation.* AUTHOR: Blaise Barney* LAST REVISED: 08/04/15******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8char *messages[NUM_THREADS];void *PrintHello(void *threadid)&#123; long taskid; sleep(1); taskid = (long) threadid; printf("Thread %d: %s\n", taskid, messages[taskid]); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; long taskids[NUM_THREADS]; int rc, t; messages[0] = "English: Hello World!"; messages[1] = "French: Bonjour, le monde!"; messages[2] = "Spanish: Hola al mundo"; messages[3] = "Klingon: Nuq neH!"; messages[4] = "German: Guten Tag, Welt!"; messages[5] = "Russian: Zdravstvuyte, mir!"; messages[6] = "Japan: Sekai e konnichiwa!"; messages[7] = "Latin: Orbis, te saluto!"; for(t=0;t&lt;NUM_THREADS;t++) &#123; taskids[t] = t; printf("Creating thread %d\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) taskids[t]); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 这个示例显示了如何通过结构体设置/传递多个参数. 每个线程都接收一个唯一的结构体实例. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/******************************************************************************* FILE: hello_arg2.c* DESCRIPTION:* A "hello world" Pthreads program which demonstrates another safe way* to pass arguments to threads during thread creation. In this case,* a structure is used to pass multiple arguments.* AUTHOR: Blaise Barney* LAST REVISED: 01/29/09******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8char *messages[NUM_THREADS];struct thread_data&#123; int thread_id; int sum; char *message;&#125;;struct thread_data thread_data_array[NUM_THREADS];void *PrintHello(void *threadarg)&#123; int taskid, sum; char *hello_msg; struct thread_data *my_data; sleep(1); my_data = (struct thread_data *) threadarg; taskid = my_data-&gt;thread_id; sum = my_data-&gt;sum; hello_msg = my_data-&gt;message; printf("Thread %d: %s Sum=%d\n", taskid, hello_msg, sum); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int *taskids[NUM_THREADS]; int rc, t, sum; sum=0; messages[0] = "English: Hello World!"; messages[1] = "French: Bonjour, le monde!"; messages[2] = "Spanish: Hola al mundo"; messages[3] = "Klingon: Nuq neH!"; messages[4] = "German: Guten Tag, Welt!"; messages[5] = "Russian: Zdravstvytye, mir!"; messages[6] = "Japan: Sekai e konnichiwa!"; messages[7] = "Latin: Orbis, te saluto!"; for(t=0;t&lt;NUM_THREADS;t++) &#123; sum = sum + t; thread_data_array[t].thread_id = t; thread_data_array[t].sum = sum; thread_data_array[t].message = messages[t]; printf("Creating thread %d\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) &amp;thread_data_array[t]); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 这个示例是不正确的参数传递方式. 传递变量 t 的地址会使所有线程可见并且共享内存地址空间. 12345678910111213141516171819202122232425262728293031323334353637383940/****************************************************************************** FILE: hello_arg3.c* DESCRIPTION:* This "hello world" Pthreads program demonstrates an unsafe (incorrect)* way to pass thread arguments at thread creation. In this case, the* argument variable is changed by the main thread as it creates new threads.* AUTHOR: Blaise Barney* LAST REVISED: 07/16/14******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8void *PrintHello(void *threadid)&#123; long taskid; sleep(1); taskid = *(long *)threadid; printf("Hello from thread %ld\n", taskid); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0;t&lt;NUM_THREADS;t++) &#123; printf("Creating thread %ld\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) &amp;t); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 合并和分离线程函数1234int pthread_join(pthread_t threadid, void **status);int pthread_detach(pthread_t threadid);int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);int pthread_attr_getdetachstate(const pthread_attr_t *attr, int detachstate); 合并(Joining) “Joining” 是一种完成后的线程与其他线程同步的方式. 例如: pthread_join() 子函数会阻塞当前的线程执行, 直到 threadid 指定的线程终止. 如果 status 参数在 threadid 指定的目标线程调用 pthread_exit() 中被设置, 那么程序员可以在目标线程终止时获取到 status. 一个合并的线程可以匹配一个 pthread_join() 调用. 尝试多次合并同一个线程是一个逻辑错误. 另外两种同步方式互斥和条件变量将在后面讨论. 是否为可合并的 当一个线程被创建时, 它的其中一个属性的定义就是该线程是可合并的还是已分离的. 只有以可合并属性创建的线程才可以被合并. 如果一个线程以已分离属性创建, 那么它将永远不能被合并. POSIX 标准的最终草案规定默认情况下线程应该以可合并属性创建. 想要显式的以可合并或已分离属性创建一个线程, 要使用 pthread_create() 函数中的 attr 参数. 典型的 4 步流程是: 声明一个 pthread_attr_t 数据类型的线程属性变量. 使用 pthread_attr_init() 初始化属性变量. 使用 pthread_attr_setdetachstate() 设置属性分离状态. 当设置完成时, 使用 pthread_attr_destroy() 释放使用的库资源. 分离 pthread_detach() 函数可以显式分离一个线程, 即使这个线程以可合并属性被创建. 没有作用相反的函数. 建议 如果一个线程需要合并, 请考虑显式的以可合并属性创建它. 这样做到了可移植性, 因为并非所有实现方式都是默认以可合并属性创建线程. 如果你提前知道一个线程将永远不会需要合并到另一个线程, 请考虑使用已分离状态创建它. 这样可以释放一些系统资源. 线程合并示例 这个示例演示了如何使用 Pthread join 函数”等待”线程完成. 因为一些 Pthread 的实现可能不是默认使用可合并状态创建线程, 所以这个示例中的线程是显式的使用可合并状态去创建, 以便后面进行合并. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/****************************************************************************** FILE: join.c* DESCRIPTION:* This example demonstrates how to "wait" for thread completions by using* the Pthread join routine. Threads are explicitly created in a joinable* state for portability reasons. Use of the pthread_exit status argument is * also shown. Compare to detached.c* AUTHOR: 8/98 Blaise Barney* LAST REVISED: 01/30/09******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 4void *BusyWork(void *t)&#123; int i; long tid; double result=0.0; tid = (long)t; printf("Thread %ld starting...\n",tid); for (i=0; i&lt;1000000; i++) &#123; result = result + sin(i) * tan(i); &#125; printf("Thread %ld done. Result = %e\n",tid, result); pthread_exit((void*) t);&#125;int main (int argc, char *argv[])&#123; pthread_t thread[NUM_THREADS]; pthread_attr_t attr; int rc; long t; void *status; /* Initialize and set thread detached attribute */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(t=0; t&lt;NUM_THREADS; t++) &#123; printf("Main: creating thread %ld\n", t); rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (void *)t); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; /* Free attribute and wait for the other threads */ pthread_attr_destroy(&amp;attr); for(t=0; t&lt;NUM_THREADS; t++) &#123; rc = pthread_join(thread[t], &amp;status); if (rc) &#123; printf("ERROR; return code from pthread_join() is %d\n", rc); exit(-1); &#125; printf("Main: completed join with thread %ld having a status of %ld\n",t,(long)status); &#125; printf("Main: program completed. Exiting.\n"); pthread_exit(NULL);&#125; source output 栈空间管理函数1234int pthread_attr_getstacksize(const pthread_addr_t *attr, size_t stacksize);int pthread_attr_setstacksize(pthread_addr_t *attr, size_t stacksize);int pthread_attr_getstackaddr(const pthread_addr_t *attr, size_t stacksize);int pthread_attr_setstackaddr(pthread_addr_t *attr, size_t stacksize); 防止栈空间出错 POSIX 标准没有规定一个线程的栈空间大小, 它取决于 POSIX 的实现和系统设置的变化. 超出默认栈空间限制经常是很容易出现的, 产生的后果是: 程序终止和/或数据被破坏. 具有安全性和可移植性的程序不能依赖于默认的栈空间大小, 而是通过 pthread_attr_setstacksize 为每个线程显式分配足够的栈空间. pthread_attr_getstackaddr 和 pthread_addrgetstackaddr 函数可以由特定环境中运行的应用程序使用, 在该环境中线程栈空间必须在放某个特定的内存区域中. LC 的一些实际例子 默认线程栈空间大小变化很大. 可以获取到的最大栈空间大小变化也很大, 且这也依赖于每个系统可以创建的线程数. 过去和现在的体系结构都显示出默认线程堆空间大小的广泛变化. 系统体系结构 #CPUs Memory(GB) Default Size(bytes) Intel Xeon E5-2670 16 32 2,097,152 Intel Xeon 5660 12 24 2,097,152 AMD Opteron 8 16 2,097,152 Intel IA64 4 8 33,554,432 Intel IA32 2 4 2,097,152 IBM Power5 8 32 196,608 IBM Power4 8 16 196,608 IBM Power3 16 16 98,304 栈空间管理示例 这个示例演示了如何获取和设置一个线程的栈空间大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#define NTHREADS 4#define N 1000#define MEGEXTRA 1000000pthread_attr_t attr;void *dowork(void *threadid)&#123; double A[N][N]; int i,j; long tid; size_t mystacksize; tid = (long)threadid; pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); printf("Thread %ld: stack size = %li bytes \n", tid, mystacksize); for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) A[i][j] = ((i*j)/3.452) + (N-i); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NTHREADS]; size_t stacksize; int rc; long t; pthread_attr_init(&amp;attr); pthread_attr_getstacksize (&amp;attr, &amp;stacksize); printf("Default stack size = %li\n", stacksize); stacksize = sizeof(double)*N*N+MEGEXTRA; printf("Amount of stack needed per thread = %li\n",stacksize); pthread_attr_setstacksize (&amp;attr, stacksize); printf("Creating threads with stack size = %li bytes\n",stacksize); for(t=0; t&lt;NTHREADS; t++)&#123; rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (void *)t); if (rc)&#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; printf("Created %ld threads.\n", t); pthread_exit(NULL);&#125; 杂项函数12pthread_t pthread_self(void);int pthread_equal(pthread_t t1, pthread_t t2); pthread_self 返回一个系统分配的唯一的当前调用线程的线程 ID(线程描述符). pthread_equal 对比两个线程 ID. 如果两个线程 ID 不同则返回 0, 否则返回一个非零整数. 注意: 对于这两个函数所使用的线程 ID 对象都是不透明的, 无法轻松检查. 因为线程 ID 是不透明的, 所以不应该使用 C 语言相等运算符 == 来比较两个线程 ID 或者将单个线程 ID 与另一个值进行比较. 1int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); pthread_once 在一个进程中只执行一次 init_routine. 由进程中的任何线程第一次调用该函数是执行给定的没有参数的 init_routine. 任何后续的调用都将是无效的. init_routine 函数通常是一个初始化的函数. once_control 参数是一个同步控制结构体，需要在调用 pthread_once 之前进行初始化. 例如: 1pthread_once_t once_control = PTHREAD_ONCE_INIT; 线程练习一入门和线程管理函数 概述: 使用你的用户名和OTP令牌登录一个LC集群 将练习文件复制到家目录 熟悉 LC 的 Pthreads 环境 写一个简单的“Hello World” Pthreads 程序 成功编译程序 成功运行程序 - 使用几种不同的方式 查看, 编译, 运行和/或调试一些相关的 Pthreads 程序(已提供) 在这里练习 互斥变量概述 Mutex 是 mutual exclusion 的缩写. 互斥变量是实现线程同步和发生多次写入时保护共享数据的方法之一. 互斥变量的行为类似以”锁定”的方式保护对共享数据资源的访问, 一般称作互斥锁. 在 Pthread 中使用互斥的基本概念指在任何时间内只有一个线程能锁定(或拥有[^1])一个互斥变量. 因此, 即使多个线程试图锁定互斥锁, 只有一个线程会成功. 在拥有该互斥锁的线程解锁该互斥锁之前，没有其他线程可以拥有该互斥锁. 互斥锁可以用于防止”竞争(race)”条件. 涉及银行交易竞争条件没有进行同步的示例如下所示: 在上面的示例中, 当线程使用共享数据资源时应该使用互斥锁来锁定”balance”. 通常, 拥有互斥锁的线程回去更新全局变量. 这是确保多个线程更新同一个变量时,一个安全的方法. 最终的结果与只有一个线程执行所有更新的结果是相同的. 正在更新的变量属于应该加锁的”关键部分”. 使用互斥锁的典型顺序如下: 创建并初始化互斥变量 几个线程试图锁定互斥锁 只有一个成功, 该线程拥有互斥锁 拥有锁的线程执行一些操作 拥有者解锁互斥锁 另一个线程获取互斥锁并重复该过程 最后互斥锁被销毁 当多个线程去竞争一个互斥锁时, 失败者将阻塞在 lock 调用处 - 通过 trylock 而不是 lock 可以做到非阻塞调用. 在保护共享数据时, 程序员的责任是确保每个需要使用互斥锁的线程都是这样做的. 例如, 如果4个线程正在更新同一个数据, 但只有一个线程使用了互斥锁, 那么数据仍然可能被破坏. 创建和销毁互斥锁函数1234int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutexattr_init(pthread_mutexattr_t *attr);int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); 用法 必须使用 pthread_mutex_t 类型声明互斥变量并且初始化后才能使用. 有两种方法可以初始化一个变量: 静态, 声明时初始化. 例如: 1pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; 动态, 使用 pthread_mutex_init() 函数初始化. 这个方法允许设置互斥对象属性 attr. 互斥锁初始化后默认是解锁的. pthread_mutex_init 中的 attr 对象用于为互斥对象设置属性, 如果使用必须是 pthread_mutexattr_t 类型(可以指定为 NULL 以使用默认值). Pthread 标准定义了三个可选的互斥锁属性: Protocol(协议): 指定用于防止互斥锁的优先级反转的协议. prioceiling: 指定已初始化的互斥锁的优先级上限. Process-shared: 指定互斥锁的进程共享. 请注意, 不是所有实现都可以提供了这三个可选的互斥锁属性. pthread_mutexattr_init 和 pthread_mutexattr_destroy 函数分别用于创建和销毁互斥锁属性对象. 应该使用 pthread_mutex_destroy 来释放不再需要的互斥对象. 锁定和解锁互斥锁函数123int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 用法 线程使用 pthread_mutex_lock() 对指定参数 mutex 变量进行锁定. 如果这个互斥锁已经被其他线程锁定了, 那么调用这个函数的线程将会阻塞在这个调用处直到这个互斥锁被其他线程解锁. pthread_mutex_trylock() 会去尝试锁定一个互斥锁. 然而, 如果这个互斥锁已经锁定, 这个函数将立即返回一个”忙碌”的错误代码. 这个函数可能会被用来防止死锁条件, 例如在优先级倒置的情况下. pthread_mutex_unlock 被拥有互斥锁的线程调用会解锁这个互斥锁. 如果其他线程获取正在包含数据的互斥锁(处于被锁定), 那么在线程完成对被保护数据的访问后需要调用这个函数. 如果出现以下错误, pthread_mutex_unlock 将返回错误: 如果互斥锁已经被解锁 如果互斥锁被另一个线程拥有 互斥锁并没有什么”神奇”的. 事实上, 它类似于所有参与共享数据访问的线程之间的”绅士协议”. 程序员需要确保必要的线程都能正确的使用锁定和解锁调用. 以下方案演示了一个逻辑错误: 问题: 当多个线程正在等待一个被锁定的互斥锁时, 那个线程在释放后将首先锁定这个互斥锁? 答案: 除非使用线程优先级调度(未被覆盖), 否则分配的权利将留给本机系统调度程序, 并且可能或多或少是随机的. 使用互斥锁的示例 这个示例程序展示了在一个计算点积的线程程序中使用互斥变量. 主要的数据通过全局可访问的结构体提供给所有线程. 每个线程处理不同的一部分数据. 主线程等待所有线程完成计算, 然后打印结果总和. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/****************************************************************************** FILE: dotprod_mutex.c* DESCRIPTION:* This example program illustrates the use of mutex variables * in a threads program. This version was obtained by modifying the* serial version of the program (dotprod_serial.c) which performs a * dot product. The main data is made available to all threads through * a globally accessible structure. Each thread works on a different * part of the data. The main thread waits for all the threads to complete * their computations, and then it prints the resulting sum.* SOURCE: Vijay Sonnad, IBM* LAST REVISED: 01/29/09 Blaise Barney******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* The following structure contains the necessary information to allow the function "dotprod" to access its input data and place its output into the structure. This structure is unchanged from the sequential version.*/typedef struct &#123; double *a; double *b; double sum; int veclen; &#125; DOTDATA;/* Define globally accessible variables and a mutex */#define NUMTHRDS 4#define VECLEN 100000DOTDATA dotstr; pthread_t callThd[NUMTHRDS];pthread_mutex_t mutexsum;/*The function dotprod is activated when the thread is created.As before, all input to this routine is obtained from a structure of type DOTDATA and all output from this function is written intothis structure. The benefit of this approach is apparent for the multi-threaded program: when a thread is created we pass a singleargument to the activated function - typically this argumentis a thread number. All the other information required by the function is accessed from the globally accessible structure. */void *dotprod(void *arg)&#123; /* Define and use local variables for convenience */ int i, start, end, len ; long offset; double mysum, *x, *y; offset = (long)arg; len = dotstr.veclen; start = offset*len; end = start + len; x = dotstr.a; y = dotstr.b; /*Perform the dot product and assign resultto the appropriate variable in the structure. */ mysum = 0; for (i=start; i&lt;end ; i++) &#123; mysum += (x[i] * y[i]); &#125; /*Lock a mutex prior to updating the value in the sharedstructure, and unlock it upon updating.*/ pthread_mutex_lock (&amp;mutexsum); dotstr.sum += mysum; printf("Thread %ld did %d to %d: mysum=%f global sum=%f\n",offset,start,end,mysum,dotstr.sum); pthread_mutex_unlock (&amp;mutexsum); pthread_exit((void*) 0);&#125;/* The main program creates threads which do all the work and then print out result upon completion. Before creating the threads,The input data is created. Since all threads update a shared structure, weneed a mutex for mutual exclusion. The main thread needs to wait forall threads to complete, it waits for each one of the threads. We specifya thread attribute value that allow the main thread to join with thethreads it creates. Note also that we free up handles when they areno longer needed.*/int main (int argc, char *argv[])&#123; long i; double *a, *b; void *status; pthread_attr_t attr; /* Assign storage and initialize values */ a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); for (i=0; i&lt;VECLEN*NUMTHRDS; i++) &#123; a[i]=1; b[i]=a[i]; &#125; dotstr.veclen = VECLEN; dotstr.a = a; dotstr.b = b; dotstr.sum=0; pthread_mutex_init(&amp;mutexsum, NULL); /* Create threads to perform the dotproduct */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(i=0;i&lt;NUMTHRDS;i++) &#123; /* Each thread works on a different set of data. * The offset is specified by 'i'. The size of * the data for each thread is indicated by VECLEN. */ pthread_create(&amp;callThd[i], &amp;attr, dotprod, (void *)i); &#125; pthread_attr_destroy(&amp;attr); /* Wait on the other threads */ for(i=0;i&lt;NUMTHRDS;i++) &#123; pthread_join(callThd[i], &amp;status); &#125; /* After joining, print out the results and cleanup */ printf ("Sum = %f \n", dotstr.sum); free (a); free (b); pthread_mutex_destroy(&amp;mutexsum); pthread_exit(NULL);&#125; Serial version source Pthreads version source 条件变量概述 条件变量为线程提供了另一种同步方式. 互斥锁通过控制对数据的线程访问来实现同步, 而条件变量允许线程根据数据的实际值进行同步. 如果没有条件变量, 程序员需要让线程去不断轮询(可能在关键部分)检查条件是否得到满足. 这可能是非常消耗资源的, 因为线程将在这个过程中持续忙碌. 条件变量是一种在不用轮询的情况下达到同一效果的方法. 条件变量始终与互斥锁一起使用. 使用条件变量的典型顺序如下所示: Main Thread 声明并初始化需要同步的全局数据/变量(例如“count”) 声明并初始化条件变量对象 声明并初始化关联的互斥锁 创建线程A和B来完成工作 Thread A 工作直到必须发生某种情况(例如“计数”必须达到指定值) 锁定关联的互斥锁并检查全局变量的值 全局变量的值不满足条件, 调用 pthread_cond_wait() 阻塞在这里等待 Thread B 的信号. 注意: 对 pthread_cond_wait() 的调用会自动并原子的解锁与条件变量关联的互斥锁, 以便 Thread B 可以使用它 收到信号后, 线程会从阻塞状态被唤醒. 与条件变量关联的互斥锁会自动并原子的锁定 明确的解锁互斥锁 继续 Thread B 工作 锁定与条件变量关联的互斥锁 更改 Thread A 正在等待的全局变量的值 检查 Thread A 等待的全局变量的值, 如果它满足所需条件，则向 Thread A 发出信号 解锁互斥锁 继续 Thread A 与 Thread B 并行运行. Main Thread ​ 合并/继续 创建和销毁条件变量函数1234int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);int pthread_cond_destroy(pthread_cond_t *cond);int pthread_condattr_init(pthread_condattr_t *attr);int pthread_condattr_destroy(pthread_condattr_t *attr); 用法 必须使用 pthread_cond_t 类型声明条件变量并且初始化后才能使用. 有两种方法可以初始化条件变量: 静态, 声明时初始化. 例如: 1pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER; 动态, 使用 pthread_cond_init() 函数初始化. 创建的条件变量的 ID 通过 condition 参数返回给调用线程. 这个方法允许设置条件变量对象属性 attr. 可选的参数 attr 对象用于设置条件变量属性. 条件变量只定义了一个属性: process-shared, 它允许条件变量被其他进程中的线程看到. 如果使用属性对象, 它必须是 pthread_condattr_t 类型(可以指定为 NULL 以使用默认值). 请注意, 并非所有实现都提供了 process-shared 属性. pthread_condattr_init 和 pthread_condattr_destroy 函数用于创建和销毁条件变量属性对象. 应该使用 pthread_cond_destroy 来释放不再需要的条件变量. 条件变量等待和发信号123int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); pthread_cond_wait() 在收到达到规定条件的信号之前会一直阻塞调用线程. 这个函数应该在锁定互斥锁后调用, 它会在等待时自动释放互斥锁. 当收到信号后会线程会被唤醒, 互斥锁将会被自动锁定以供线程使用. 然后程序员负责在线程处理完成后解锁互斥锁. 建议: 调用 pthread_cond_wait() 时使用 WHILE 循环而不是 IF 语句(可以参考下面示例中的 watch_count 函数)来检查等待的条件, 这样可以帮助处理几个潜在的问题, 例如: 如果多个线程在等待同一个唤醒信号, 当收到信号时, 它们将轮流获取互斥锁, 然后它们中的任何一个线程都可以修改它们等待条件. 如果线程由于程序错误而收到错误的信号. 线程库允许在不违反标准的情况下向等待的线程发出虚假唤醒. pthread_cond_signal() 函数用于发送信号给(或唤醒)另一个正在使用条件变量等待的线程. 必须在与 pthread_cond_wait() 参数 mutex 相同的互斥锁锁定后才能调用它, 同时为了 pthread_cond_wait() 自动加锁能够执行完成必须要对参数 mutex 相同的互斥锁进行解锁. 如果多个线程处于阻塞等待状态, 那么应该使用 pthread_cond_broadcast() 函数而不是 pthread_cond_signal(). 在调用 pthread_cond_wait() 之前调用 pthread_cond_signal() 是一个逻辑错误. 警告: 当使用这些函数时, 必须正确锁定和解锁相关联的互斥锁变量. 例如: 调用 pthread_cond_wait() 之前没有锁定互斥锁可能导致它不被阻塞. 调用 pthread_cond_signal 后没有解锁互斥锁可能不允许对应的 pthread_cond_wait 函数完成(它将保持阻塞状态). 使用条件变量的示例 这个简单的示例代码演示了几个 Pthread 条件变量相关函数的使用. main 函数创建了三个线程. 其中两个线程执行工作并更新 count 变量. 第三个线程等待, 直到 count 变量达到指定值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/******************************************************************************* FILE: condvar.c* DESCRIPTION:* Example code for using Pthreads condition variables. The main thread* creates three threads. Two of those threads increment a "count" variable,* while the third thread watches the value of "count". When "count" * reaches a predefined limit, the waiting thread is signaled by one of the* incrementing threads. The waiting thread "awakens" and then modifies* count. The program continues until the incrementing threads reach* TCOUNT. The main program prints the final value of count.* SOURCE: Adapted from example code in "Pthreads Programming", B. Nichols* et al. O'Reilly and Associates. * LAST REVISED: 03/07/17 Blaise Barney******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 3#define TCOUNT 10#define COUNT_LIMIT 12int count = 0;pthread_mutex_t count_mutex;pthread_cond_t count_threshold_cv;void *inc_count(void *t) &#123; int i; long my_id = (long)t; for (i=0; i &lt; TCOUNT; i++) &#123; pthread_mutex_lock(&amp;count_mutex); count++; /* Check the value of count and signal waiting thread when condition is reached. Note that this occurs while mutex is locked. */ if (count == COUNT_LIMIT) &#123; printf("inc_count(): thread %ld, count = %d Threshold reached. ", my_id, count); pthread_cond_signal(&amp;count_threshold_cv); printf("Just sent signal.\n"); &#125; printf("inc_count(): thread %ld, count = %d, unlocking mutex\n", my_id, count); pthread_mutex_unlock(&amp;count_mutex); /* Do some work so threads can alternate on mutex lock */ sleep(1); &#125; pthread_exit(NULL);&#125;void *watch_count(void *t) &#123; long my_id = (long)t; printf("Starting watch_count(): thread %ld\n", my_id); /* Lock mutex and wait for signal. Note that the pthread_cond_wait routine will automatically and atomically unlock mutex while it waits. Also, note that if COUNT_LIMIT is reached before this routine is run by the waiting thread, the loop will be skipped to prevent pthread_cond_wait from never returning. */ pthread_mutex_lock(&amp;count_mutex); while (count &lt; COUNT_LIMIT) &#123; printf("watch_count(): thread %ld Count= %d. Going into wait...\n", my_id,count); pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); printf("watch_count(): thread %ld Condition signal received. Count= %d\n", my_id,count); &#125; printf("watch_count(): thread %ld Updating the value of count...\n", my_id); count += 125; printf("watch_count(): thread %ld count now = %d.\n", my_id, count); printf("watch_count(): thread %ld Unlocking mutex.\n", my_id); pthread_mutex_unlock(&amp;count_mutex); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; int i, rc; long t1=1, t2=2, t3=3; pthread_t threads[3]; pthread_attr_t attr; /* Initialize mutex and condition variable objects */ pthread_mutex_init(&amp;count_mutex, NULL); pthread_cond_init (&amp;count_threshold_cv, NULL); /* For portability, explicitly create threads in a joinable state */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;threads[0], &amp;attr, watch_count, (void *)t1); pthread_create(&amp;threads[1], &amp;attr, inc_count, (void *)t2); pthread_create(&amp;threads[2], &amp;attr, inc_count, (void *)t3); /* Wait for all threads to complete */ for (i = 0; i &lt; NUM_THREADS; i++) &#123; pthread_join(threads[i], NULL); &#125; printf ("Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n", NUM_THREADS, count); /* Clean up and exit */ pthread_attr_destroy(&amp;attr); pthread_mutex_destroy(&amp;count_mutex); pthread_cond_destroy(&amp;count_threshold_cv); pthread_exit (NULL);&#125; source output Pthreads的监控，调试和性能分析工具略 LLNL特定信息和建议略 未涵盖的主题Pthreads API有几个功能本教程未涉及. 这些列在下面. 有关详细信息, 请参考Pthread 库函数参考部分. 线程调度 线程调度方式不同实现将导致线程的运行方式上有所不同. 在大多数情况下, 默认机制就足够了. Pthreads API 提供了显式设置线程调度策略和优先级的函数, 这些策略和优先级可能会覆盖默认机制. API 不需要特定的实现来支持这些功能. Keys: 线程特定数据(TSD) 当线程调用不同的函数或从不同的函数中返回时, 线程堆空间上的本地数据不断创建和销毁. 为了保留堆空间上的数据, 你通常需要将其作为参数从一个函数传递到下一个函数, 或者将数据存储在与线程关联的一个全局变量中. Pthread 提供了另一种通过 Keys 实现这个目的的方法, 这种方法可能更方便, 更多用途. 用于处理“优先级倒置”问题的互斥锁 Protocol 属性和互斥锁优先级管理. 条件变量共享 - 跨进程 线程取消(Thread Cancellation) 线程和信号 同步构造 - 屏障(barriers)和锁定 线程练习二互斥锁, 条件变量和带Pthreads的混合MPI 概述: 使用你的用户名和OTP令牌登录一个LC集群 将练习文件复制到家目录 熟悉 LC 的 Pthreads 环境 写一个简单的“Hello World” Pthreads 程序 成功编译程序 成功运行程序 - 使用几种不同的方式 查看, 编译, 运行和/或调试一些相关的 Pthreads 程序(已提供) 在这里练习 参考和更多信息 作者: Blaise Barney, Livermore Computing. POSIX 标准: www.unix.org/version3/ieee_std.html Pthreads Programming. B. Nichols et al. O’Reilly and Associates. Programming With POSIX Threads. D. Butenhof. Addison Wesley Programming With Threads. S. Kleiman et al. Prentice Hall Pthread 库函数参考为方便起见, 下面提供了按字母顺序排列的Pthread函数列表, 并链接到了相应的手册页. pthread_atfork pthread_attr_destroy pthread_attr_getdetachstate pthread_attr_getguardsize pthread_attr_getinheritsched pthread_attr_getschedparam pthread_attr_getschedpolicy pthread_attr_getscope pthread_attr_getstack pthread_attr_getstackaddr pthread_attr_getstacksize pthread_attr_init pthread_attr_setdetachstate pthread_attr_setguardsize pthread_attr_setinheritsched pthread_attr_setschedparam pthread_attr_setschedpolicy pthread_attr_setscope pthread_attr_setstack pthread_attr_setstackaddr pthread_attr_setstacksize pthread_barrier_destroy pthread_barrier_init pthread_barrier_wait pthread_barrierattr_destroy pthread_barrierattr_getpshared pthread_barrierattr_init pthread_barrierattr_setpshared pthread_cancel pthread_cleanup_pop pthread_cleanup_push pthread_cond_broadcast pthread_cond_destroy pthread_cond_init pthread_cond_signal pthread_cond_timedwait pthread_cond_wait pthread_condattr_destroy pthread_condattr_getclock pthread_condattr_getpshared pthread_condattr_init pthread_condattr_setclock pthread_condattr_setpshared pthread_create pthread_detach pthread_equal pthread_exit pthread_getconcurrency pthread_getcpuclockid pthread_getschedparam pthread_getspecific pthread_join pthread_key_create pthread_key_delete pthread_kill pthread_mutex_destroy pthread_mutex_getprioceiling pthread_mutex_init pthread_mutex_lock pthread_mutex_setprioceiling pthread_mutex_timedlock pthread_mutex_trylock pthread_mutex_unlock pthread_mutexattr_destroy pthread_mutexattr_getprioceiling pthread_mutexattr_getprotocol pthread_mutexattr_getpshared pthread_mutexattr_gettype pthread_mutexattr_init pthread_mutexattr_setprioceiling pthread_mutexattr_setprotocol pthread_mutexattr_setpshared pthread_mutexattr_settype pthread_once pthread_rwlock_destroy pthread_rwlock_init pthread_rwlock_rdlock pthread_rwlock_timedrdlock pthread_rwlock_timedwrlock pthread_rwlock_tryrdlock pthread_rwlock_trywrlock pthread_rwlock_unlock pthread_rwlock_wrlock pthread_rwlockattr_destroy pthread_rwlockattr_getpshared pthread_rwlockattr_init pthread_rwlockattr_setpshared pthread_self pthread_setcancelstate pthread_setcanceltype pthread_setconcurrency pthread_setschedparam pthread_setschedprio pthread_setspecific pthread_sigmask pthread_spin_destroy pthread_spin_init pthread_spin_lock pthread_spin_trylock pthread_spin_unlock pthread_testcancel [^1]: 译者注: 这里拥有的意思是当一个互斥变量被锁定时, 锁定的线程占有这个互斥变量的使用权, 其他线程无法使用.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KV API guarantees]]></title>
    <url>%2FKV_API_guarantees.html</url>
    <content type="text"><![CDATA[翻译自: KV API guarantees etcd 是一个具有小型事务支持的一致和持久的键值存储. 键值存储通过 KV APIs 操作. etcd 试图为分布式系统确保最强的一致性和持久化. 本规范列举了 etcd 提供的 KV API 保证. 需要考虑的 APIs 读取 APIs range watch 写入 APIs put delete 组合(read-modify-write) APIs txn etcd 的特殊定义操作已完成(Operation completed)当一个 etcd 操作达成共识被提交时, 该操作被认为已完成, 因此被 etcd 存储引擎执行(永久存储). 当客户端从 etcd 服务器接收到响应时, 就知道操作已经完成. 请注意, 如果某个操作超时或执行某个操作时客户端和 etcd 成员之间网络中断, 则客户端可能不确定该操作的状态. 在选举领导人时, etcd 也可能终止操作. 在这种情况下, etcd 不会向未完成的客户端请求发送中止(abort) 响应. Revision一个修改 etcd 键值存储的操作会被分配一个独立递增的 revision. 事务操作可能多次修改键值存储, 但是只会被分配一个 revision. 一个键值对的 revision 属性和最后一次修改这个键值对的操作的 revision 具有相同的值. 这个 revision 可以被用作键值存储的逻辑时钟. 具有较大 revision 的键值对在具有较小 revision 之后进行修改. 具有相同 revision 的两个键值对通过一个”相同(concurrently)”的操作进行修改. 提供保证原子性所有的 API 请求都是原子的, 一个操作要么完全完成, 要么一点也不执行. 对于 watch 请求, 一个操作产生的所有时间都将在一个 watch 响应中通知. watch 绝不观察一个独立操作产生的部分事件. 一致性所有的 API 调用确保顺序一致性, 为分布式系统提供最强的一致性保证. 无论客户端向哪个 etcd 成员服务器发出请求, 客户端都会以相同的顺序读取相同的事件. 如果两个 etcd 成员完成相同数量的操作, 则两个 etcd 成员的状态是一致的. 对于 watch 操作, etcd 确保对于同一修改版本的同一个 key 所有的 etcd 成员返回相同的 value. 对于 range 操作, etcd 对线性化访问有相同的保证. 序列化访问返回的 value1 可能会与当前法定数量的成员返回的 value2(正确值) 不同, value1 之后的修改无法获取. 与所有分布式系统一样, etcd 不可能确保严格一致性. 隔离etcd 确保序列化隔离#Serializable), 这是分布式系统中可用的最高等级的隔离. 读操作将永远不会获得任何中间值. 持久性任何已完成的操作都是持久化的. 所有可访问的数据都是持久化的数据. 读取将永远不可能返回没有持久化的数据. 线性化线性化(也成原子一致性或外部一致性)是介于严格一致性和顺序一致性之间的一致性等级. 对于线性化, 假设每个操作从一个宽松的全局同步时钟中获取一个时间戳. 当且仅当操作总是按照顺序排练执行完成, 且每个操作从出现到完成都是按照程序指定的顺序, 操作才是线性化的. 同样, 如果一个操作的时间戳先于另一个, 那么这个操作在执行顺序上也必须先于另外一个操作. 例如, 考虑一个客户端完成在时间点1(t1)完成写操作. 在 t2(t2 &gt; t1) 发出读操作的客户端应该接收到至少与之前在 t1 写入执行完成一样的值. 但是, 实际上完成读操作可能仅在 t3 完成. 线性化保证读取返回最新值. 如果没有线性化保证, 在 t2 发出读操作在 t3 返回的值可能是”过时”的, 因为一个并发的写操作可能在 t2 到 t3 时间内发生. etcd 对 watch 的操作不保证线性化. 用户被要求确认 watch 的响应去确保正确的顺序. etcd 对其他所有操作默认确保线性化. 然而线性化带来了成本, 因为线性化的请求必须经过 Raft 共识流程. 为了使读操作具有更低的等待时间和更高的 QPS, 客户端可以将请求的一致性模式设置为序列化模式. 这有可能访问到达到法定人数的过期数据, 但是可以消除线性化访问对实时共识依赖产生的性能损失.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存用户堆栈扩展]]></title>
    <url>%2FLinux_memoryout_user_stack_extension.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 越界访问 中, 对于 do_page_fault() 的分析只进行了部分, 只分析了 find_vma 返回 vma 紧邻其上的区间不是栈区的处理情况. 这里分析一下如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. &emsp;&emsp;当系统为一个进程分配的栈空间已经被使用完, 栈顶指针 %esp 已经指向已映射的栈区区间的开始地址(栈自顶而下分配空间)时, 如果出现新的函数调用, 就需要先将函数的参数入栈到 %esp - 4 的位置, 但是由于栈区区间已经到达开始地址, 再向下就是还没有映射的空洞. 在访问 %esp - 4 时, 就会发生一次页面出错异常. 12345678910111213141516171819202122232425262728293031323334353637383940// arch/i386/mm/fault.c [do_page_fault()] // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; // 内存映射的空洞紧邻其上的是一个栈区区间 // 处于用户模式 if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. * * 访问 %esp 所指向的栈顶之下的空间总是一个 bug. * 由于一些指令(如 pusha)会使 %esp 做递减, 并在更下面的位置, * 所以会 "+ 32" */ // 在参数入栈时一次入栈最多通过 pusha 入栈 32 个字节 // 所以如果访问的位置超出 32 个字节说明访问的页面出错异常不是堆栈扩展造成的 if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; // 本次页面出错异常是堆栈扩展造成的 // 扩展堆栈: expand_stack 建立页面映射并扩展栈区 if (expand_stack(vma, address)) goto bad_area; &emsp;&emsp;出现页面出错异常在 vma 排除其他三种情况(if (!vma), if (vma-&gt;vm_start &lt;= address), if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)))后, 剩下的就是如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. 这时也分为两种可能: 由于栈区空间被使用完, 栈空间自顶向下扩展时产生的页面出错异常. 由于内存非法越界访问, 访问的地址落入栈空间与堆空间的空洞中. &emsp;&emsp;区分这两种可能是使用访问地址的位置进行判断. 栈空间扩展都是先参数入栈, 然后再开辟栈帧. 当参数入栈时, 通常是一次压入 4 个字节, 这时访问的虚拟地址为 %esp - 4, 但在 i386 CPU 中有一个 pusha 指令, 一次可以将 32 个字节(8 个 32 位寄存器的内容)压入栈空间. 所以如果是栈区扩展产生的页面出错异常那么访问的虚拟地址就会在 %esp - 32 及其以上的区域, 否则访问的地址就会低于 %esp - 32, 出现这种情况的处理方式与 越界访问 中的处理方式相同. &emsp;&emsp;当确认页面出错异常为扩展栈空间的要求时, 就要开始从当前空洞的顶部为栈空间扩展: 建立页面映射, 并将之并入栈区区间(if (expand_stack(vma, address))). 扩展栈区123456789101112131415161718192021222324252627282930// include/linux/mm.h [do_page_fault() &gt; expand_stack()]/* vma is the first one with address &lt; vma-&gt;vm_end, * and even address &lt; vma-&gt;vm_start. Have to extend vma. * * 参数 vma 是第一个 address &lt; vma-&gt;vm_end 甚至 address &lt; vma-&gt;vm_start 的区间. * 必须扩展 vma * */// 将栈区自顶向下扩展static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)&#123; unsigned long grow; // 将地址按照页面边界对齐 address &amp;= PAGE_MASK; // 获取扩展页面数 grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT; // 进程栈空间的大小超过了限制的最大值或进程可用存储区超过了限制的最大长度 if (vma-&gt;vm_end - address &gt; current-&gt;rlim[RLIMIT_STACK].rlim_cur || ((vma-&gt;vm_mm-&gt;total_vm + grow) &lt;&lt; PAGE_SHIFT) &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur) return -ENOMEM; // 扩展栈区 vma-&gt;vm_start = address; vma-&gt;vm_pgoff -= grow; vma-&gt;vm_mm-&gt;total_vm += grow; if (vma-&gt;vm_flags &amp; VM_LOCKED) vma-&gt;vm_mm-&gt;locked_vm += grow; return 0;&#125; &emsp;&emsp;由于系统资源有限, 所以进程对各种资源的使用有限制. 每个进程的 task_struct 结构中都有一个 rlim 结构数组规定了每种资源分配的使用限制. 代码中的 RLIMIT_STACK 限制了栈的最大大小, RLIMIT_AS 限制了进程可用存储区的最大长度(字节). 如果扩展以后栈区大小超过了限制的最大值或者动态分配的页面总量超过了可用于该进程的资源限制, 就不能再扩展了, 返回一个 -ENOMEM 的出错代码. &emsp;&emsp;expand_stack() 函数扩展栈区以页面为单位进行扩展, 只是改变栈区的 vm_area_struct 结构, 并未建立起新扩展的页面对物理内存的映射. &emsp;&emsp;从 expand_stack() 函数中正确返回, 会进入 do_page_fault() 函数的 good_vma 中, 表示访问的地址在一个 vma 中, 这里会根据 error_code 判断页面出错异常出错原因. 1234567891011121314151617181920212223// arch/i386/mm/fault.c [do_page_fault()]/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code) &emsp;&emsp;出现页面出错异常是由于需要压栈, 即数据写入(error_code 中 bit 1 == 1). 已经扩展了 vm_area_struct 但是没有建立物理页面的映射, 即物理页面不存在(error_code 中 bit 0 == 0). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// arch/i386/mm/fault.c [do_page_fault()]/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. * * 对于这次内存访问, 我们有一个好的 vm_area_struct, 因此我们可以处理它.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */ /* 出错指令为读操作, 物理页面在内存中 */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ /* 出错指令为写操作, 物理页面不在内存中 */ // 检查当前 vma 是否可写 if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ /* 出错指令为读操作, 物理页面在内存中 */ goto bad_area; case 0: /* read, not present */ /* 出错指令为读操作, 物理页面不在内存中 */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. * * 如果因为任何原因我们无法处理错误, 请确保我们优雅的退出, 而不是无休止的重复处理错误. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ // 处理与 VM86 模式及 VGA 的图像存储区相关的特殊情况 if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return; &emsp;&emsp;所以 switch (error_code &amp; 3) 时会进入 case 2: 分支检查当前 vm_area_struct 是否可写, 不可写与 越界访问 处理方式相同. 可写进入 handle_mm_fault() 函数. 建立映射123456789101112131415161718192021222324252627282930// mm/memory.c [do_page_fault() &gt; handle_mm_fault()]/* * By the time we get here, we already hold the mm semaphore * * 当我们到达这里, 我们已经有了 mm */// 处理页面映射过程中的错误int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access)&#123; int ret = -1; pgd_t *pgd; pmd_t *pmd; // 获取当前虚拟地址所在的 pgd_t 指针 pgd = pgd_offset(mm, address); // 获取当前虚拟地址所在的 pmd_t 指针 pmd = pmd_alloc(pgd, address); // 如果虚拟地址所在 pmd_t 指针不为空 if (pmd) &#123; // 获取当前虚拟地址所在的 pte_t 指针 pte_t * pte = pte_alloc(pmd, address); // 如果虚拟地址所在 pte_t 指针不为空 if (pte) ret = handle_pte_fault(mm, vma, address, write_access, pte); &#125; return ret;&#125; &emsp;&emsp;先获取虚拟地址所在的页目录项指针. 页目录总是存在的. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; pgd_offset()]/* to find an entry in a page-table-directory. *//* 在页目录中查找虚拟地址所在的页目录项 */// 获取页目录中虚拟地址所在下标#define pgd_index(address) ((address &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))#define __pgd_offset(address) pgd_index(address)// 获取页目录中虚拟地址所在的页目录项的指针#define pgd_offset(mm, address) ((mm)-&gt;pgd+pgd_index(address)) &emsp;&emsp;然后获取虚拟地址所在的中间目录项指针. 由于 i386 CPU 中没有使用 PMD, 所以把页目录项当做只有一个表项的 PMD, 所以 pmd_alloc() 绝对不会执行失败. 所以 handle_mm_fault() 中的 pmd 绝对不会为 0. 12345678910// include/asm-i386/pgalloc-2level.h [do_page_fault() &gt; handle_mm_fault() &gt; pmd_alloc()]// 在中间目录中查找虚拟地址所在的中间目录项// i386 中没有启用 PMD, 把页目录项当做只有一个表项的 PMDextern inline pmd_t * pmd_alloc(pgd_t *pgd, unsigned long address)&#123; if (!pgd) BUG(); return (pmd_t *) pgd;&#125; &emsp;&emsp;其次获取虚拟地址所在的页表项指针. 中间目录项指针有可能指向一个存在的页表, 可以直接获取页表项指针; 也有可能中间目录项为空, 页表不存在, 需要在 getnew 中申请一个新的页表. 一个页表与一个物理页面大小相同, 内核中对页面表的分配作了一些优化. 当释放一个页表时, 内核将释放的页表保存在页表缓存池中, 而不直接释放物理内存页面. 只有在缓存池已满的情况下才真正将页表所占用的物理内存页面释放. 如果页表缓存池中有页表, 就直接获取, 如果没有则使用 get_pte_slow() 获取页表, 这时如果物理内存页面用完, 则需要将长时间没有使用的物理内存页面交换到磁盘上去, 获取页表的速度会很慢. 123456789101112131415161718192021222324252627282930313233// include/asm-i386/pgalloc.h [do_page_fault() &gt; handle_mm_fault() &gt; pte_alloc()]// 在页表中查找虚拟地址所在的页表项// 如果页表不存在则创建页表extern inline pte_t * pte_alloc(pmd_t * pmd, unsigned long address)&#123; // 获取虚拟地址所在物理页面指针在页表中的下标 address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1); // 判断 pmd_t 是否为空 if (pmd_none(*pmd)) goto getnew; // 判断中间目录项权限是否正确 if (pmd_bad(*pmd)) goto fix; return (pte_t *)pmd_page(*pmd) + address;// 获取一个新的页表getnew:&#123; // 从页表缓存池中获取一页页表 unsigned long page = (unsigned long) get_pte_fast(); // 判读是否缓存池已空 if (!page) return get_pte_slow(pmd, address); // 获取页表, 返回给定偏移量位置的页表项指针 // 将获取的页表绑定到中间目录项中 set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(page))); return (pte_t *)page + address;&#125;fix: __handle_bad_pmd(pmd); return NULL;&#125; &emsp;&emsp;最后就是映射到物理页面本身了, 对应到栈区扩展的情况, 物理内存页面还没有分配, 所以物理页面不在内存中, 一定会进入 if (!pte_present(entry)), 对应的页表项也一定会为空, 一定会进入 if (pte_none(entry)). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault()]/* * These routines also need to handle stuff like marking pages dirty * and/or accessed for architectures that don't do it in hardware (most * RISC architectures). The early dirtying is also good on the i386. * * 这些程序也需要处理如硬件体系结构(大部分为 RISC 体系结构)无法做到的设置页面脏和/或已访问. * * There is also a hook called "update_mmu_cache()" that architectures * with external mmu caches can use to update those (ie the Sparc or * PowerPC hashed page tables that act as extended TLBs). * * Note the "page_table_lock". It is to protect against kswapd removing * pages from under us. Note that kswapd only ever _removes_ pages, never * adds them. As such, once we have noticed that the page is not present, * we can drop the lock early. * * The adding of pages is protected by the MM semaphore (which we hold), * so we don't need to worry about a page being suddenly been added into * our VM. */static inline int handle_pte_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t * pte)&#123; pte_t entry; /* * We need the page table lock to synchronize with kswapd * and the SMP-safe atomic PTE updates. */ // 加锁 spin_lock(&amp;mm-&gt;page_table_lock); entry = *pte; // 判断 PTE 的 P 标志位和第 8 位是否设置(查看物理页面是否在内存中) if (!pte_present(entry)) &#123; /* * If it truly wasn't present, we know that kswapd * and the PTE updates will not touch it later. So * drop the lock. * * 如果它确实不存在, 我们知道 kswapd 和 PTE 更新不会稍后不会触及它. * 因此解锁. */ spin_unlock(&amp;mm-&gt;page_table_lock); // 判断 PTE 是否为 0, 是则表示映射还未建立, 否表示映射已经建立 if (pte_none(entry)) return do_no_page(mm, vma, address, write_access, pte); // 如果页表项不为空, 说明物理页面在磁盘上 return do_swap_page(mm, vma, address, pte, pte_to_swp_entry(entry), write_access); &#125; if (write_access) &#123; if (!pte_write(entry)) return do_wp_page(mm, vma, address, pte, entry); entry = pte_mkdirty(entry); &#125; entry = pte_mkyoung(entry); establish_pte(vma, address, pte, entry); spin_unlock(&amp;mm-&gt;page_table_lock); return 1;&#125; &emsp;&emsp;vm_area_struct 中存在一个 vm_operations_struct 结构体(数据结构 中介绍), 这个结构实际上是一个函数跳转表, 结构中通常是一些与文件操作有关的函数指针, 这样, 当通过 mmap() 将一块虚存区间与一个已打开的文件(包括设备)建立映射后, 就可以通对这些函数的操作转化成对文件操作, 或者进行一些必要的对文件的附加操作. 另一方面, 物理页面的盘区交换显然也和文件操作有关. 所以为特定的虚存空间预先指定一些操作是很有必要的. &emsp;&emsp;其中 nopage 用于物理内存页面的分配. 为什么物理内存页面的分配与文件操作有关? 因为这对文件共享很有意义. 当多个进程将同一个文件映射到各自的虚存空间中时, 内存中通常只会保存一份物理页面就可以. 只有当一个进程需要写入该文件时, 才有必要另外复制一份独立的副本, 称为 copy on write 或者 COW(后面进程中关于 fork() 的内容详细介绍). &emsp;&emsp;由于这里是栈区扩展, 与文件系统或页面共享没有关系, 所以不会指定 nopage 操作, 会进入 do_anonymous_page() 函数处理. 123456789101112131415161718192021222324252627// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page()]/* * do_no_page() tries to create a new page mapping. It aggressively * tries to share with existing pages, but makes a separate copy if * the "write_access" parameter is true in order to avoid the next * page fault. * * do_no_page() 尝试创建一个新的页面映射. 它积极尝试与已存在的页面共享, 但是如果 write_access 参数为 true, * 为了避免再次出现页面错误, 它会创建单独的副本. * * As this is called only for pages that do not currently exist, we * do not need to flush old virtual caches or the TLB. * * 仅针对当前不存在的页面调用这个函数, 因此我们不需要刷新就得虚拟缓存或 TLB. * * This is called with the MM semaphore held. */static int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t *page_table)&#123; struct page * new_page; pte_t entry; // 如果当前区间没有定义 vm_operation_struct 的函数操作或者没有定义 vm_operation_struct 中缺页时的操作 nopage if (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage) return do_anonymous_page(mm, vma, page_table, write_access, address); &emsp;&emsp;进入 do_anonymous_page() 函数后, 如果引发异常的是读操作就会将页表项指向一个始终为 0 的只读的全局共享物理内存页面; 如果是写操作就会获取一个新的物理页面, 将页表项指向可写的物理内存页面. 1234567891011121314151617181920212223242526272829// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page()]/* * This only needs the MM semaphore */static int do_anonymous_page(struct mm_struct * mm, struct vm_area_struct * vma, pte_t *page_table, int write_access, unsigned long addr)&#123; struct page *page = NULL; // 将页表项指向一个始终为 0 的只读的全局共享物理内存页面 mk_pte: 设置页表项中的权限位 pte_t entry = pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot)); // 如果出现异常的指令是写操作 if (write_access) &#123; // 获取一个物理页面 page = alloc_page(GFP_HIGHUSER); if (!page) return -1; clear_user_highpage(page, addr); // 将页表项指向可写的物理内存页面 page entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot))); mm-&gt;rss++; flush_page_to_ram(page); &#125; // 将页表项的值填入一个页表项中. set_pte(page_table, entry); /* No need to invalidate - it was non-present before */ // i386 的 MMU 在 CPU 中, 不需要这个功能, 这里为空函数 update_mmu_cache(vma, addr, entry); return 1; /* Minor fault */&#125; &emsp;&emsp;只要是只读页面, 开始时都会不管其虚拟地址是什么, 直接映射向同一个始终为 0 物理页面 empty_zero_page. 只有是可写页面时才会分配新的独立物理内存. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page() &gt; ZERO_PAGE()]/* * ZERO_PAGE is a global shared page that is always zero: used * for zero-mapped memory areas etc.. * * ZERO_PAGE 是一个始终为 0 的全局共享页面: 用于零映射内存区域等.. */extern unsigned long empty_zero_page[1024];// 获取一个全局共享的初始化为 0 的物理页面#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page)) &emsp;&emsp;栈区扩展是由于写操作异常引起的, 所以会调用 alloc_page() 为其分配新的物理内存页面, 并将分配的物理页面及权限写入页表项中. 至此映射建立完成, 逐层退出函数. 注意&emsp;&emsp;当 CPU 从一次页面出错异常处理返回到用户空间时, 将会先重新执行因映射失败而中断的那条指令, 然后才会继续向下执行, 这是异常处理的特殊性. 中断以及自陷(trap 指令) 发生时, CPU 都会将下一条指令, 也就是接下去本来要执行的指令的地址入栈作为恢复中断服务的返回地址. 而当异常发生时, CPU 将因无法完成(例如除以 0, 映射失败等) 而夭折的指令本身的地址(而不是下一条指令的地址)压入栈, 当从异常处理返回时继续刚刚没有完成的指令. 这个过程是在 CPU 内部电路中实现的, 不需要软件干预. 从这个意义上来讲, 缺页中断 正确的说法应该是 缺页异常. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存越界访问]]></title>
    <url>%2FLinux_memory_out_of_bounds_access.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;页式存储管理机制通过页目录和页表将每个线性地址映射到物理地址. 但是在这个过程中可能存在一些问题导致映射失败, 这时 CPU 就会产生 页面出错异常(Page Fault Exception), 也成 缺页中断, 进而执行预定的页面异常处理程序, 使应用程序从产生异常的指令处恢复执行或进行善后处理. 产生 页面出错异常(Page Fault Exception) 的原因有: 访问的 pgd_t 或 pte_t 为空. 这可能是还未映射或映射已经撤销导致的. 物理页面被交换出内存. 指令的访问方式与页面要求的权限不符. 如修改只读页面. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291// arch/i386/mm/fault.c/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)&#123; // 当前出现异常进程的 task_struct struct task_struct *tsk; // 当前出现异常进程用户空间 mm_struct struct mm_struct *mm; // 当前出现异常进程的出错区间 struct vm_area_struct * vma; // 当前出现异常进程访问的出错地址 unsigned long address; unsigned long page; unsigned long fixup; int write; siginfo_t info; /* get the address */ /* 获取出错地址 */ __asm__("movl %%cr2,%0":"=r" (address)); // 获取 task_struct tsk = current; /* * We fault-in kernel-space virtual memory on-demand. The * 'reference' page table is init_mm.pgd. * * NOTE! We MUST NOT take any locks for this case. We may * be in an interrupt or a critical region, and should * only copy the information from the master page table, * nothing more. */ if (address &gt;= TASK_SIZE) goto vmalloc_fault; // 获取 mm_struct mm = tsk-&gt;mm; info.si_code = SEGV_MAPERR; /* * If we're in an interrupt or have no user * context, we must not take the fault.. * * 如果我们处于中断或没有用户上下文环境的情况下, 我们绝不能处理这种错误. */ // in_interrupt() 返回非零, 说明映射失败发生在某个中断/异常处理程序中, 与当前出现异常进程无关. // mm 为空, 说明当前出现异常进程的映射还没有建立, 与该进程无关. 说明映射发生在某个 in_interrupt() 程序无法检测的某个中断/异常处理程序中. if (in_interrupt() || !mm) goto no_context; // 信号量, 锁住 mm_struct 及其下属的 vm_area_struct, 防止其他进程打扰. down(&amp;mm-&gt;mmap_sem); // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前异常虚拟地址所在的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. */ if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; if (expand_stack(vma, address)) goto bad_area;/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ goto bad_area; case 0: /* read, not present */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return;/* * Something tried to access memory that isn't in our memory map.. * Fix it, but check if it's kernel or user first.. * * 尝试访问的内存不在内存映射(vm_area_struct)之中.. * 首先检查当前出现异常进程属于用户还是内核, 然后修复.. */bad_area: // 对于 mm_struct 及其下属 vm_area_struct 的使用完成, 信号量解锁 up(&amp;mm-&gt;mmap_sem);bad_area_nosemaphore: /* User mode accesses just cause a SIGSEGV */ /* 用户模块访问只会导致 SIGSEGV */ // 用户模式 if (error_code &amp; 4) &#123; // 设置当前出现异常进程的 task_struct tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; // 向当前出现异常进程发送一个强制 SIGSEGV 信号, 产生 Segment Fault info.si_signo = SIGSEGV; info.si_errno = 0; /* info.si_code has been set above */ info.si_addr = (void *)address; force_sig_info(SIGSEGV, &amp;info, tsk); return; &#125; /* * Pentium F0 0F C7 C8 bug workaround. */ if (boot_cpu_data.f00f_bug) &#123; unsigned long nr; nr = (address - idt) &gt;&gt; 3; if (nr == 6) &#123; do_invalid_op(regs, 0); return; &#125; &#125;no_context: /* Are we prepared to handle this kernel fault? */ if ((fixup = search_exception_table(regs-&gt;eip)) != 0) &#123; regs-&gt;eip = fixup; return; &#125;/* * Oops. The kernel tried to access some bad page. We'll have to * terminate things with extreme prejudice. */ bust_spinlocks(); if (address &lt; PAGE_SIZE) printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference"); else printk(KERN_ALERT "Unable to handle kernel paging request"); printk(" at virtual address %08lx\n",address); printk(" printing eip:\n"); printk("%08lx\n", regs-&gt;eip); asm("movl %%cr3,%0":"=r" (page)); page = ((unsigned long *) __va(page))[address &gt;&gt; 22]; printk(KERN_ALERT "*pde = %08lx\n", page); if (page &amp; 1) &#123; page &amp;= PAGE_MASK; address &amp;= 0x003ff000; page = ((unsigned long *) __va(page))[address &gt;&gt; PAGE_SHIFT]; printk(KERN_ALERT "*pte = %08lx\n", page); &#125; die("Oops", regs, error_code); do_exit(SIGKILL);/* * We ran out of memory, or some other thing happened to us that made * us unable to handle the page fault gracefully. */out_of_memory: up(&amp;mm-&gt;mmap_sem); printk("VM: killing process %s\n", tsk-&gt;comm); if (error_code &amp; 4) do_exit(SIGKILL); goto no_context;do_sigbus: up(&amp;mm-&gt;mmap_sem); /* * Send a sigbus, regardless of whether we were in kernel * or user mode. */ tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; info.si_code = SIGBUS; info.si_errno = 0; info.si_code = BUS_ADRERR; info.si_addr = (void *)address; force_sig_info(SIGBUS, &amp;info, tsk); /* Kernel mode? Handle exceptions or die */ if (!(error_code &amp; 4)) goto no_context; return;vmalloc_fault: &#123; /* * Synchronize this task's top level page-table * with the 'reference' page table. */ int offset = __pgd_offset(address); pgd_t *pgd, *pgd_k; pmd_t *pmd, *pmd_k; pgd = tsk-&gt;active_mm-&gt;pgd + offset; pgd_k = init_mm.pgd + offset; if (!pgd_present(*pgd)) &#123; if (!pgd_present(*pgd_k)) goto bad_area_nosemaphore; set_pgd(pgd, *pgd_k); return; &#125; pmd = pmd_offset(pgd, address); pmd_k = pmd_offset(pgd_k, address); if (pmd_present(*pmd) || !pmd_present(*pmd_k)) goto bad_area_nosemaphore; set_pmd(pmd, *pmd_k); return; &#125;&#125; &emsp;&emsp;代码开始时使用汇编获取 address 是因为 i386 CPU 产生 页面出错异常(Page Fault Exception) 时, 会将访问产生这个错误的虚拟地址放入控制寄存器 CR2 中. 由于 C 语言没有直接读取 CR2 的语句, 所以需要使用汇编进行获取. &emsp;&emsp;对于获取到的 vma 的分析: 进程的内存布局代码段, 数据段, bss段, 堆等自底向上分布, 栈区自顶向下发展, 所以结束地址最高的区间为栈区, 如果访问异常的虚拟地址比最高区间的结束地址还高(find_vma 返回 NULL, if (!vma)), 说明其处于高 1G 的系统空间中. 如果访问异常的虚拟地址大于等于当前区间的其实地址(if (vma-&gt;vm_start &lt;= address)), 说明异常发生在当前区间. 如果访问异常的虚拟地址不在系统空间, 也不再任何一个区间, 说明其处于一个内存映射的空洞中: VM_GROWSDOWN 表示一个区间处于栈区, 如果内存映射的空洞紧邻其上的是一个栈区区间说明空洞是栈区一下的空洞, 这个空洞是供动态分配使用(通过系统调用 brk())但是还没有分配出去的空间. 如果紧邻其上的区间没有设置 VM_GROWSDOWN, 说明空洞是因为一个没有建立映射区间或映射区间已经被销毁的空间. &emsp;&emsp;每次从中断/异常处理程序中返回之前, 都要检查当前进程是否有信号(或称软中断)需要处理, 在 vma 处于最后一种情况时需要处理 SIGSEGV 信号. 内核会根据这些待处理信号的性质以及进程本身的选择进行处理. 有些信号是强制执行, 有些是按照进程设置处理. SIGSEGV 信号需要强制执行, 会是该进程产生 Segment Fault, 然后使进程退出. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存数据结构]]></title>
    <url>%2FLinux_memory_data_structure.html</url>
    <content type="text"><![CDATA[页面映射结构&emsp;&emsp;页目录 PGD, 中间目录 PMD, 页表 PT 分别是由表项 pgd_t, pmd_t 以及 pte_t 构成的数组. 123456789101112131415161718192021222324252627282930// include/asm-i386/page.h/* * These are used to make use of C type-checking.. * * 这些用于 C 类型检查.. */#if CONFIG_X86_PAE // 三层映射 PAE 模式// PT 表项typedef struct &#123; unsigned long pte_low, pte_high; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low | ((unsigned long long)(x).pte_high &lt;&lt; 32))#else // 两层映射// PT 表项typedef struct &#123; unsigned long pte_low; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low)#endif#define PTE_MASK PAGE_MASK// 页面状态信息和访问权限结构体typedef struct &#123; unsigned long pgprot; &#125; pgprot_t; &emsp;&emsp;32 位地址时, pgd_t, pmd_t 和 pte_t 实际上就是长整型. 36 位地址时, 则是 long long 整型. 不直接定义成整型是因为这样可以让 gcc 在编译时加以更严格的类型检查. &emsp;&emsp;所有的物理页面都是 4K 边界对齐, 因此这些表项作为页面的指针一定是 4K 的倍数, 所以指针实际只需要高 20 位, 这高 20 位也可以看做物理页面的下标序号. 所以这些表项的低 12 位就被用于记录页面的状态信息和访问权限. 内核中并没有在表项中定义相关的位段, 而是单独定义用来说明页面保护的结构 pgprot_t. 对 pgprot_t 中位段说明如下: 1234567891011121314// include/asm-i386/pgtable.h#define _PAGE_PRESENT 0x001#define _PAGE_RW 0x002#define _PAGE_USER 0x004#define _PAGE_PWT 0x008#define _PAGE_PCD 0x010#define _PAGE_ACCESSED 0x020#define _PAGE_DIRTY 0x040#define _PAGE_PSE 0x080 /* 4 MB (or 2MB) page, Pentium+, if present.. */#define _PAGE_GLOBAL 0x100 /* Global TLB entry PPro+ */// 对应 pte_t 中第 8 位, Intel 手册指定这一位保留不用, 所以对 MMU 不起作用#define _PAGE_PROTNONE 0x080 /* If not present */ &emsp;&emsp;pgprot_t 设置 pte 低 12 位, 所以总是小于 0x1000, pte 中的指针部分总是大于等于 0x1000, 将二者合在一起就得到实际用于 PT 中的表项. 1234// include/asm-i386/pgtable-2level.h// 为 pte_t 设置 pgprot_t 权限#define __mk_pte(page_nr,pgprot) __pte(((page_nr) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot)) &emsp;&emsp;当 PTE 为 0 时, 表示这个表项所代表的虚拟内存页面没有建立映射. 在映射过程中 MMU 会首先检查 P 标志位, 即 _PAGE_PRESENT, 表示映射的页面是否在内存中. 只有当 P 标志位为 1 时, MMU 才会完成映射的全过程; 如果 PTE 不为 0, P 标志位为 0 时, 表示映射已经建立, 但是所映射的物理页面不在内存中, 会产生一次缺页异常. 物理内存管理结构page 结构&emsp;&emsp;在内核中有个全局的 mem_map 指针, 指向一个 page 结构体的数组, 每个 page 代表一个物理页面, 整个数组代表系统中的所有物理页面. PTE 不仅仅低 12 位为 0 时对于硬件是物理页面的地址, 同时它的高 20 位对于软件也代表这个数组的下标. 1234// include/asm-i386/pgtable-2level.h// 根据 PTE 获取 PTE 指向的物理页面的 page 指针#define pte_page(x) (mem_map+((unsigned long)(((x).pte_low &gt;&gt; PAGE_SHIFT)))) 1234567891011121314151617181920212223242526272829303132// include/linux/mm.h/* * Try to keep the most commonly accessed fields in single cache lines * here (16 bytes or greater). This ordering should be particularly * beneficial on 32-bit processors. * * 尝试在单个缓存线中保留最常访问的字段(16 字节或更大). 这一点对 32 位处理器应该特别有利. * * The first line is data used in page cache lookup, the second line * is used for linear searches (eg. clock algorithm scans). * * 第一行是用于页面缓存的查找的数据, 第二行是用于线性搜索(如时钟算法扫描). */// 物理页面结构体, 代表一个物理页面typedef struct page &#123; struct list_head list; struct address_space *mapping; // 当页面内容来自一个文件时, index 表示该页面在文件中的序号 // 当页面的内容被交换到磁盘上, index 表示页面的去向 unsigned long index; struct page *next_hash; atomic_t count; unsigned long flags; /* atomic flags, some possibly updated asynchronously */ /* 原子标志, 有可能异步更新 */ struct list_head lru; unsigned long age; wait_queue_head_t wait; struct page **pprev_hash; struct buffer_head * buffers; void *virtual; /* non-NULL if kmapped */ struct zone_struct *zone;&#125; mem_map_t; &emsp;&emsp;page 结构中各个成分的次序是有讲究的, 目的是尽量使得联系紧密的若干成分在执行是被装填入高速缓存的同一缓冲线(16个字节)中. 系统在初始化时会创建一个由 page(或 mem_map_t) 组成的 mem_map 数组, 每个 page 代表系统中的一个物理页面, 物理页面初始地址的高 20 位就是对应 page 的下标. zone_struct 结构&emsp;&emsp;mem_map 中的所有物理页面被划分成 ZONE_DMA 和 ZONE_NORMAL 两个管理区(也有可能存在第三个 ZONE_HIGHMEM). ZONE_DMA 中管理的是专供 DMA 使用的内存页. 为什么供 DMA 使用的页面要单独加以管理? DMA 使用的页面需要进行磁盘 I/O, 单独管理防止内存页面全部被分配出去无法进行页面与盘区的交换. 在 i386 中 MMU 存在于 CPU 中, DMA 不经过 MMU 的地址映射, 外设直接访问物理内存, 但是部分外设访问物理内存地址较小. DMA 所需的内存当超过 4K 时, 需要连续的物理内存页面, 无法使用 MMU 提供的连续的虚拟内存页面. &emsp;&emsp;每个管理区由 none_struct 结构创建, 一旦创建成功, 每个物理页面就永久属于一个管理区. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// include/linux/mmzone.h/* * Free memory management - zoned buddy allocator. * * 空闲内存管理 - zoned buddy allocator. */// free_area_struct 链接的最大内存块为 2 ^ MAX_ORDER#define MAX_ORDER 10typedef struct free_area_struct &#123; // 双向链表 struct list_head free_list; unsigned int *map;&#125; free_area_t;struct pglist_data;// 管理区结构体typedef struct zone_struct &#123; /* * Commonly accessed fields: * * 常用字段 */ spinlock_t lock; // 当前管理区在 mem_map 中的起始位置(页面序号) unsigned long offset; unsigned long free_pages; unsigned long inactive_clean_pages; unsigned long inactive_dirty_pages; unsigned long pages_min, pages_low, pages_high; /* * free areas of different sizes * * 不同大小的空闲空间 */ struct list_head inactive_clean_list; // 数组中每个成员都是由双向链表连接起来的内存块的链表指针, 每个成员中内存块都是由 2 ^ n 个物理页面组成(1 &lt;= n &lt;= MAX_ORDER, MAX_ORDER = 10). free_area_t free_area[MAX_ORDER]; /* * rarely used fields: * * 很少使用的字段 */ char *name; unsigned long size; /* * Discontig memory support fields. */ // 指向当前 node 节点的管理结构 pglist_data(下一小节介绍) struct pglist_data *zone_pgdat; unsigned long zone_start_paddr; unsigned long zone_start_mapnr; struct page *zone_mem_map;&#125; zone_t;// 管理区类型#define ZONE_DMA 0#define ZONE_NORMAL 1#define ZONE_HIGHMEM 2// 管理区最大数量#define MAX_NR_ZONES 3 pglist_data 结构&emsp;&emsp;计算机内存系统存在两种结构. 均质存储结构(Uniform Memory Architecture) 指计算机中所有物理内存地位均等, 访问任意物理内存消耗时间相同, 简称 UMA. 非均质存储结构(Non-Uniform Memory Architecture) 指计算机中物理内存地址虽然是连续的, 但是却分为不同的模块, 访问速度不同, 消耗的时间也不同, 简称 NUMA. &emsp;&emsp;在真实的计算机系统中, 绝对的 UMA 是不存在的. 真正的系统会存在不同的内存模块, 如多级高速缓存, RAM, ROM, 显存等. Linux 内核从 2.4.0 版本开始支持 NUMA. 在 NUMA 结构的系统中, 分配连续多个物理内存页面要求分配在质地相同的区间(称为 node, 即 节点). 这里的 node 对应到 Linux 系统中就是 pglist_data 结构. 这时 mem_map 数组将不再管理整个物理内存, 而是管理当前 node 中的物理页面. 而 zone_struct 则表示当前 node 中的管理区. 在 zone_struct 和 mem_map 之上则是 pglist_data 结构, 管理整个存储节点. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mmzone.h/* * One allocation request operates on a zonelist. A zonelist * is a list of zones, the first one is the 'goal' of the * allocation, the other zones are fallback zones, in decreasing * priority. * * 一个分配请求在一个 zonelist(管理区列表) 上运行. 一个 zonelist 是 zone 的列表, * 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. * * Right now a zonelist takes up less than a cacheline. We never * modify it apart from boot-up, and only a few indices are used, * so despite the zonelist table being relatively big, the cache * footprint of this construct is very small. * * 现在一个 zonelist 占用的空间比一个缓存线小. * 除非在启动时, 否则我们从不修改它, 并且只有少数索引被使用, 因此尽管 zonelist 表相对较大(0x100(256) 项), * 但是构造它的缓存空间是非常小的. */typedef struct zonelist_struct &#123; // zone_struct 管理区, 类型相同(猜测), 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. zone_t * zones [MAX_NR_ZONES+1]; // NULL delimited int gfp_mask;&#125; zonelist_t;// zonelist 数组最大长度#define NR_GFPINDEX 0x100struct bootmem_data;typedef struct pglist_data &#123; // 当前 node 的 zone_struct 管理区, 最大为 3 个 zone_t node_zones[MAX_NR_ZONES]; // zonelist 表, 规定最多 0x100(256) 中内存分配策略 zonelist_t node_zonelists[NR_GFPINDEX]; // 指向当前 node 的 mem_map 数组 struct page *node_mem_map; unsigned long *valid_addr_bitmap; struct bootmem_data *bdata; unsigned long node_start_paddr; unsigned long node_start_mapnr; unsigned long node_size; int node_id; // 单向链表, 指向下一个 pglist_data 节点 struct pglist_data *node_next;&#125; pg_data_t; 虚拟内存管理结构vm_area_struct 结构&emsp;&emsp;在虚拟内存中, 以进程为基础分为两个部分: 系统空间 和 用户空间. 系统空间 为所有进程共享; 用户空间 为每个进程私有. 其中 用户空间 中的各个部分未必是连续的, 通常形成许多分散的虚拟内存区间. Linux 内核中 vm_area_struct 就表示这些虚拟内存区间, 使用单链表将所有区间连接, 同时为了提高搜索效率, 在区间数量增大到 32 时(&gt;=), 会创建 AVL 树. 在Linux内核中 vm_area_struct 的变量名常常是 vma. vm_area_struct 的划分不仅仅取决于地址的连续性, 还要求同一 vm_area_struct 中的虚拟内存具有相同访问权限(vm_page_prot)和其他一些属性(vm_flags). &emsp;&emsp;同时 vm_area_struct 还会与磁盘文件发生交互: 盘去交换(swap): 指在物理内存页面不够分配时, 一些长时间不用的内存交换到磁盘上, 腾出物理页面以供应急. 这就是一般意义上的 &quot;按需调度&quot;页式虚存管理(demand paging). 系统调用 mmap(): 可以将一个打开的文件映射到用户空间中, 使进程像访问内存中的字符数组一样访问文件中的数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mm.h/* * This struct defines a memory VMM memory area. There is one of these * per VM-area/task. A VM area is any part of the process virtual memory * space that has a special rule for the page-fault handlers (ie a shared * library, the executable area etc). */struct vm_area_struct &#123; // 当前 vm_area_struct 所在进程用户空间的管理结构 mm_struct(下一小节介绍) struct mm_struct * vm_mm; /* VM area parameters */ // vm_area_struct 起始地址, 包含在 vm_area_struct 中 unsigned long vm_start; // vm_area_struct 结束地址, 不包含在 vm_area_struct 中 unsigned long vm_end; /* linked list of VM areas per task, sorted by address */ // 单链表, 每个进程的 vm_area_struct 按照地址高低依次链接 struct vm_area_struct *vm_next; // vm_area_struct 访问权限 pgprot_t vm_page_prot; // vm_area_struct 属性 unsigned long vm_flags; /* AVL tree of VM areas per task, sorted by address */ // AVL 树, 每个进程的 vm_area_struct 按照地址高低组成 AVL 树, 便于查找 short vm_avl_height; struct vm_area_struct * vm_avl_left; struct vm_area_struct * vm_avl_right; /* For areas with an address space and backing store, * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists, * for shm areas, the list of attaches, otherwise unused. */ // 记录, 管理 vm_area_struct 与磁盘文件交互 struct vm_area_struct *vm_next_share; struct vm_area_struct **vm_pprev_share; // 定义了 vm_area_struct 操作执行函数指针, 包括打开, 关闭, 缺页时建立映射 struct vm_operations_struct * vm_ops; unsigned long vm_pgoff; /* offset in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */ struct file * vm_file; unsigned long vm_raend; void * vm_private_data; /* was vm_pte (shared mem) */&#125;; 123456789101112131415// include/linux/mm.h/* * These are the virtual MM functions - opening of an area, closing and * unmapping it (needed to keep files on disk up-to-date etc), pointer * to the functions called when a no-page or a wp-page exception occurs. */struct vm_operations_struct &#123; // vma 打开操作 void (*open)(struct vm_area_struct * area); // vma 关闭操作 void (*close)(struct vm_area_struct * area); // vma 中产生缺页异常时建立映射操作 struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int write_access);&#125;; mm_struct 结构&emsp;&emsp;在 vm_area_struct 结构中存在指向 mm_struct 结构的指针, mm_struct 是整个进程用户空间的管理结构, 在内核中的变量名常常为mm, 比 vm_area_struct 更高一个层次, 对 vm_area_struct 进行管理. 每一个进程控制块即 task_struct 结构中都有一个指向当前进程 mm_struct 结构的指针. 虽然每个进程都只有一个 mm_struct 结构, 但是一个 mm_struct 结构可以被多个进程共用, 如 vfork() 的父子进程共享一个 mm_struct 结构. 123456789101112131415161718192021222324252627282930313233// include/linux/sched.hstruct mm_struct &#123; struct vm_area_struct * mmap; /* list of VMAs */ /* vma 链表 */ struct vm_area_struct * mmap_avl; /* tree of VMAs */ /* vma AVL 树 */ struct vm_area_struct * mmap_cache; /* last find_vma result */ /* find_vma 返回的结果 ,即上一次访问的 vma */ // pgd 指针 pgd_t * pgd; // atomic_t 原子操作整数 atomic_t mm_users; /* How many users with user space? */ atomic_t mm_count; /* How many references to "struct mm_struct" (users count as 1) */ int map_count; /* number of VMAs */ /* 当前 mm_struct 中 vma 的数量 */ // P, V 操作信号量. 使对 mm_struct 及下属 vm_area_struct 的访问互斥 struct semaphore mmap_sem; // 类似 mmap_sem spinlock_t page_table_lock; // 双向链表 struct list_head mmlist; /* List of all active mm's */ /* 所有存活 mm_struct 组成的链表 */ // 代码段, 数据段起始地址和终止地址 unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; unsigned long rss, total_vm, locked_vm; unsigned long def_flags; unsigned long cpu_vm_mask; unsigned long swap_cnt; /* number of pages to swap on next pass */ unsigned long swap_address; /* Architecture-specific MM context */ mm_context_t context;&#125;; &emsp;&emsp;CPU 实际进行的映射并不涉及 mm_struct 结构, 而是像 地址映射 中讲的那样通过 PGD 和 PT 进行, 但是 mm_struct 结构描述了这种映射. &emsp;&emsp;通过 mm_struct 结构查找给定虚拟地址所在的 vma: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// mm/mmap.c/* Look up the first VMA which satisfies addr &lt; vm_end, NULL if none. *//* 查找满足 addr &lt; vm_end 的 vma, 没有则返回 NULL */// 给出一个虚拟地址, 查找对应用户空间 mm 中第一个虚拟地址大于其结束地址的 vma// 返回 NULL 表示该虚拟地址所在区间还未创建struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr)&#123; struct vm_area_struct *vma = NULL; if (mm) &#123; /* Check the cache first. */ /* 实现检查缓存 */ /* (Cache hit rate is typically around 35%.) */ /* 缓存命中率大约为 35% */ vma = mm-&gt;mmap_cache; // 如果不在缓存中 if (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123; // 如果没有建立 AVL 树 if (!mm-&gt;mmap_avl) &#123; /* Go through the linear list. */ /* 通过线性链表查找 */ vma = mm-&gt;mmap; while (vma &amp;&amp; vma-&gt;vm_end &lt;= addr) vma = vma-&gt;vm_next; &#125; else &#123; /* Then go through the AVL tree quickly. */ /* 建立了 AVL 树, 通过 AVL 树快速查找 */ struct vm_area_struct * tree = mm-&gt;mmap_avl; vma = NULL; for (;;) &#123; if (tree == vm_avl_empty) break; if (tree-&gt;vm_end &gt; addr) &#123; vma = tree; if (tree-&gt;vm_start &lt;= addr) break; tree = tree-&gt;vm_avl_left; &#125; else tree = tree-&gt;vm_avl_right; &#125; &#125; if (vma) mm-&gt;mmap_cache = vma; // 将当前查到的 vma 保存到缓存中. &#125; &#125; return vma;&#125; &emsp;&emsp;在创建一个新的 vm_area_struct 将其插入 mm_struct 时, 会调用 insert_vm_struct() 函数, 在这里加了两把锁, 第一把加在新区间 vm_area_struct 上, 第二把加在代表整个虚拟空间的 mm_struct 结构中, 使得操作过程中不让其他进程能够中途也能对这两个数据结构进行修改. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// mm/mmap.c/* Insert vm structure into process list sorted by address * and into the inode's i_mmap ring. If vm_file is non-NULL * then the i_shared_lock must be held here. */void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; struct vm_area_struct **pprev; struct file * file; // 如果没有创建 AVL 树 if (!mm-&gt;mmap_avl) &#123; // 在单链表中查找 pprev = &amp;mm-&gt;mmap; while (*pprev &amp;&amp; (*pprev)-&gt;vm_start &lt;= vmp-&gt;vm_start) pprev = &amp;(*pprev)-&gt;vm_next; &#125; else &#123; // 已经创建 AVL 树, 插入 AVL 树 struct vm_area_struct *prev, *next; avl_insert_neighbours(vmp, &amp;mm-&gt;mmap_avl, &amp;prev, &amp;next); pprev = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap); if (*pprev != next) printk("insert_vm_struct: tree inconsistent with list\n"); &#125; // 将新的 vm_area_struct 加入单链表 vmp-&gt;vm_next = *pprev; *pprev = vmp; // mm_struct 中 vm_area_struct 总数++ mm-&gt;map_count++; // 当 mm_struct 中 vm_area_struct 数量达到 AVL_MIN_MAP_COUNT(32) 且没有创建 AVL 树时, 创建 vm_area_struct 的 AVL 树 if (mm-&gt;map_count &gt;= AVL_MIN_MAP_COUNT &amp;&amp; !mm-&gt;mmap_avl) build_mmap_avl(mm); // 文件映射相关操作 file = vmp-&gt;vm_file; if (file) &#123; struct inode * inode = file-&gt;f_dentry-&gt;d_inode; struct address_space *mapping = inode-&gt;i_mapping; struct vm_area_struct **head; if (vmp-&gt;vm_flags &amp; VM_DENYWRITE) atomic_dec(&amp;inode-&gt;i_writecount); head = &amp;mapping-&gt;i_mmap; if (vmp-&gt;vm_flags &amp; VM_SHARED) head = &amp;mapping-&gt;i_mmap_shared; /* insert vmp into inode's share list */ if((vmp-&gt;vm_next_share = *head) != NULL) (*head)-&gt;vm_pprev_share = &amp;vmp-&gt;vm_next_share; *head = vmp; vmp-&gt;vm_pprev_share = head; &#125;&#125;// 将一个新创建的 vm_area_struct 结构插入当前用户空间的 mm_struct 中void insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; // 加在 vm_area_struct 上的第一把锁, 防止插入过程中其他进程修改当前的 vm_area_struct lock_vma_mappings(vmp); // 加在 mm_struct 上的第二把锁, 防止插入过程中其他进程修改当前的 mm_struct spin_lock(&amp;current-&gt;mm-&gt;page_table_lock); __insert_vm_struct(mm, vmp); spin_unlock(&amp;current-&gt;mm-&gt;page_table_lock); unlock_vma_mappings(vmp);&#125; 总结 &emsp;&emsp;mm_struct 及其下属 vm_area_struct 只是说明了对虚拟内存的需求, 一个虚拟内存有相应的区间存在并不保证其所在的页面已经映射到了一个物理(物理内存或磁盘)页面, 更不保证该页面就在内存中. 总结&emsp;&emsp;mm_struct 和 vm_area_struct 说明了对页面的需求; page, zone_struct 和 pglist_data 说明了对页面的供应; PGD, PMD 和 PT 则是二者之间的桥梁. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存地址映射]]></title>
    <url>%2FLinux_memory_address_mapping.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux 采用页式内存管理. 优点: 页面固定大小, 便于管理. 灵活度高, 在将内存交换到磁盘上时, 按内存页进行交换. 页式内存管理有内部碎片, 无外部碎片. &emsp;&emsp;即使 i386 CPU 在硬件上限制必须先段式再页式的映射方式, Linux 也是避开了段式映射, 在 Linux 内存映射时(除用来模拟80286的 VM86模式), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. 当然 i386 存在段式映射是有历史原因的, 对于其他 CPU 来说就不存在这一层了. 段式映射&emsp;&emsp;在获取到一个虚拟地址后, 首先确定其属于进程的哪一段内存, 然后获取相应内存段的段寄存器中的值. Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段. 1234567891011121314// include/asm-i386/processor.h// 创建进程时设置对应进程的段寄存器和栈顶,栈底寄存器// Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段.#define start_thread(regs, new_eip, new_esp) do &#123; \ __asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0)); \ set_fs(USER_DS); \ regs-&gt;xds = __USER_DS; \ regs-&gt;xes = __USER_DS; \ regs-&gt;xss = __USER_DS; \ regs-&gt;xcs = __USER_CS; \ regs-&gt;eip = new_eip; \ regs-&gt;esp = new_esp; \&#125; while (0) 12345678910111213141516// include/asm-i386/segment.h#ifndef _ASM_SEGMENT_H#define _ASM_SEGMENT_H// 内核代码段寄存器初始值#define __KERNEL_CS 0x10// 内核数据段寄存器初始值#define __KERNEL_DS 0x18// 用户进程代码段寄存器初始值#define __USER_CS 0x23// 用户进程数据段寄存器初始值#define __USER_DS 0x2B#endif &emsp;&emsp;这里需要介绍一下段寄存器, RPL 为所要求的特权级别, 共分为 4 级, 00 为最高权限, 11 为最低权限, Linux 在实现时只使用了这两个级别. TI 为 0 时表示使用 GDT, 为 1 时表示使用 LDT. Index 表示对应段描述符表的下标. &emsp;&emsp;通过之前介绍, 解析 Linux 段寄存器初始值: &emsp;&emsp;TI 值均为 0, 说明都是 GDT, 没有使用 LDT, 在 Linux 中 LDT 只在 VM86模式 下使用. RPL 内核使用 00 级, 普通进程使用 11 级. index 为固定值. &emsp;&emsp;在 Linux 实现时会将 GDT 初始化为固定的值, GDT 第一项(下标为 0)会初始化为 0x0000000000000000, 这是为了防止加电后段寄存器未经初始化就进入保护模式并使用 GDT. 第 2 ~ 5 项对应之前四中段寄存器. 12345678910111213141516171819202122// arch/i386/kernel/head.S/* * This contains typically 140 quadwords, depending on NR_CPUS. * * 这通常包含140个四字(64位), 取决于NR_CPUS. * * NOTE! Make sure the gdt descriptor in head.S matches this if you * change anything. * * 注意! 如果你改变任何东西, 请确保 head.S 中的 gdt 描述符与此匹配. */// 初始化 GDTENTRY(gdt_table) .quad 0x0000000000000000 /* NULL descriptor */ .quad 0x0000000000000000 /* not used */ .quad 0x00cf9a000000ffff /* 0x10 kernel 4GB code at 0x00000000, __KERNEL_CS 指向的空间 */ .quad 0x00cf92000000ffff /* 0x18 kernel 4GB data at 0x00000000, __KERNEL_DS 指向的空间 */ .quad 0x00cffa000000ffff /* 0x23 user 4GB code at 0x00000000, __USER_CS 指向的空间 */ .quad 0x00cff2000000ffff /* 0x2b user 4GB data at 0x00000000, __USER_DS 指向的空间 */ .quad 0x0000000000000000 /* not used */ .quad 0x0000000000000000 /* not used */ 将 2 ~ 5 项按照二进制展开: 再按照段描述符表项内容进行分析: 相同: B0~B15, B16~B31 都是 0. 段基址全为 0. L0~L15, L16~L19 都是 1. 段长度全为 0xfffff. G 位都是 1. 段长度单位均为 4KB. D 位都是 1. 对四个段的访问指令都是 32 位指令. P 位都是 1. 四个段都在内存中. 结论: 每个段都是从 0 地址开始的整个 4G 虚拟空间, 虚拟地址到线性地址的映射保持原值不变. 不同: __KERNEL_CS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __KERNEL_DS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. __USER_CS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __USER_DS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. 页式映射&emsp;&emsp;每个进程都有其自身的页目录 PGD, 指向这个目录的指针保存在每个进程的 mm_struct 数据结构(数据结构中介绍)中. 每当一个进程运行时, 内核都要为其设置控制寄存器 CR3, 而 MMU 的硬件总是从 CR3 中取得指向当前页目录的指针. CPU 在执行过程中使用的是虚拟地址, 而 MMU 硬件在进行映射时使用的是物理地址, 这其中的计算则是通过 基本框架 中介绍的 __ps 进行计算的. 这里存在一个问题: 使用不同的页目录, 不会使程序不能连续执行吗? 答案是不会. 因为所有进程的 PGD 对系统空间的 1G 空间映射完全相同. &emsp;&emsp;在获取到 PGD 地址后获取线性地址的最高 10 位作为下标, 在这个 PGD 表项中保存着 PT 的地址. 然后将线性地址接下来的 10 位作为 PT 的下标, 获取到对应的物理页面地址. 线性地址的最低 12 位为物理页面中的偏移量, 就是线性地址在物理内存中的地址. &emsp;&emsp;在页面映射的过程中, i386 CPU 需要访问三次内存. 第一次访问 PGD, 第二次访问 PT, 第三次才是真正的目标. 所以高效的虚拟内存有赖于两方面: 高速缓存(cache)的实现. 除第一次访问需要这三步, 之后就可以在高速缓存中找到. 这个过程由硬件实现, 速度很快. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存基本框架]]></title>
    <url>%2FLinux_memory_basic_framework.html</url>
    <content type="text"><![CDATA[i386 内存映射&emsp;&emsp;i386 CPU中采用的页式内存管理, 基本思路是：通过页目录和页表两层实现线性地址到物理地址的映射. 优点: 大多数情况下可以节省页表所占的内存空间。当页表为空时只需要将对应页目录项置为空，就可以节省对相应页表的空间. 缺点: 适用最大内存为 4G 的内存. Linux 内存映射&emsp;&emsp;由于 Linux 需要考虑不同CPU上的实现, 所有需要设计出一种通用的内存映射模型模型. Linux 内核的映射机制设计成三层, 在 i386 的页目录和页表的基础上在中间增设了一层”中间目录”. 在源码中, 页目录称为 PGD, 中间目录称为 PMD, 页表称为 PT. 三者均为数组. 相应的逻辑上也将线性地址由高到低分为四个段位, 分别作用于页目录 PGD 的下标, 中间目录 PMD 的下标, 页表 PT 的下标以及物理页面中的位移. &emsp;&emsp;对于 i386 中的段式内存映射在 Linux 内存映射时(除用来模拟80286的 VM86模式[^1]), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. i386 在 Pentium Pro 开始引入了物理地址扩充功能 PAE, 可以将地址宽度从32位上升为36位. 所以在 Linux 的内存映射模型对应到 i386 CPU时, 如果设置了 PAE 则使用三层映射, 否则跳过中间的 PMD 层次, 使用两层映射. 123456789101112131415161718192021222324// include/asm-i386/pgtable.h/* * The Linux x86 paging architecture is 'compile-time dual-mode', it * implements both the traditional 2-level x86 page tables and the * newer 3-level PAE-mode page tables. * * Linux x86 分页架构是'编译时双模式', 它实现了传统两层 x86 页表和新的三层 PAE 模式页表两种映射方式. */#ifndef __ASSEMBLY__#if CONFIG_X86_PAE // 编译时设置# include &lt;asm/pgtable-3level.h&gt; // PAE模式三层映射#else# include &lt;asm/pgtable-2level.h&gt; // 两层映射#endif#endif#define __beep() asm("movb $0x3,%al; outb %al,$0x61")#define PMD_SIZE (1UL &lt;&lt; PMD_SHIFT)#define PMD_MASK (~(PMD_SIZE-1))// 每个页目录项所指向空间的大小#define PGDIR_SIZE (1UL &lt;&lt; PGDIR_SHIFT)#define PGDIR_MASK (~(PGDIR_SIZE-1)) 12345678910111213141516171819202122// include/asm-i386/pgtable-2level.h/* * traditional i386 two-level paging structure: * 传统 i386 两层分页结构 */// PGD 数组的下标在线性地址中的起始位置, 即线性地址的 23 ~ 32 位(从 0 开始)#define PGDIR_SHIFT 22// 每个 PGD 中的指针数, 即 PGD 中页目录项的数量, i386 中指针所用空间为 4 个字节, 则 PGD 所占空间为 1024 * 4 = 4KB#define PTRS_PER_PGD 1024/* * the i386 is two-level, so we don't really have any * PMD directory physically. * * 因为 i386 是两层分页结构, 所以我们不会有真正物理上的 PMD 目录. */// PMD 数组的下标在线性地址中的起始位置, 与 PGDIR_SHIFT 相同, 即 PMD 在线性地址中不存在, 长度为 0#define PMD_SHIFT 22// 每个 PMD 中的指针数, 只有 1 个, 直接指向 PT#define PTRS_PER_PMD 1 &emsp;&emsp;32位地址意味着4G字节的虚存空间, Linux 内核将这4G字节的空间分成两个部分. 将最高的1G字节(从虚拟地址 0xC0000000 至 0xFFFFFFFF), 用于内核本身, 称为系统空间. 而将较低的3G字节(从虚拟地址 0x00000000 至 0xBFFFFFFF), 用作各个进程的用户空间, 理论上每个进程拥有独立的3G字节的用户空间. 系统空间是所有进程逻辑上共用的1G字节空间, 每一个进程通过系统调用从用户空间进入内核, 在系统空间中运行. 即每一个进程都拥有4G的虚拟空间, 较低的3G虚拟空间独立使用, 最高的1G虚拟空间与所用进程及内核共享. 这里独立的虚拟空间只是在逻辑上独立, 但是在物理上所有的进程共用3G的物理内存. &emsp;&emsp;系统空间在虚拟内存中占据最高的1G空间, 但是在物理内存中却是从最低地址(0)开始, 处于最低1G空间. 123456789101112131415161718192021222324// include/asm-i386/page.h/* * This handles the memory map.. We could make this a config * option, but too many people screw it up, and too few need * it. * * 这里处理内核的内存映射. 我们可以将其设置为配置选项, 但是有许多人搞砸它, 并且很少需要它. * * A __PAGE_OFFSET of 0xC0000000 means that the kernel has * a virtual address space of one gigabyte, which limits the * amount of physical memory you can use to about 950MB. * * 值为 0xC0000000 的 __PAGE_OFFSET 意味着内核有 1GB 的虚拟空间, 这限制了可以内核使用的物理空间大约 950MB. * * If you want more physical memory than this then see the CONFIG_HIGHMEM4G * and CONFIG_HIGHMEM64G options in the kernel configuration. * * 如果你想要超过这些的物理内存, 请参阅内核配置中的 CONFIG_HIGHMEM4G * 和 CONFIG_HIGHMEM64G 选项 */// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define __PAGE_OFFSET (0xC0000000) 12345678// include/asm-i386/page.h// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)// 计算系统空间在虚拟内存中对应物理空间中的地址#define __pa(x) ((unsigned long)(x)-PAGE_OFFSET)// 计算系统空间在物理内存中对应虚拟空间中的地址#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET)) 123456789// include/asm-i386/processor.h/* * User space process size: 3GB (default). * * 用户空间进程大小: 3GB(默认) */// 用户空间进程大小.#define TASK_SIZE (PAGE_OFFSET) 本文整理自《Linux内核源代码情景分析》 [^1]: VM86模式 是为采用保护模式的系统提供 实模式(real-mode) 软件的兼容性, 用来在保护模式下模拟运行实模式的软件.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[etcd gateway]]></title>
    <url>%2Fetcd_gateway.html</url>
    <content type="text"><![CDATA[翻译自: etcd gateway etcd gateway 是什么?&emsp;&emsp;etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持. 什么时候使用 etcd gateway?&emsp;&emsp;每个访问 etcd 的应用必须首先拥有 etcd 集群的地址. 如果是同一台服务器上的多个应用访问同一个 etcd 集群, 每个应用仍然需要知道这个 etcd 集群公布的地址. 如果这个 etcd 集群重新配置为拥有不同端点的集群, 则每个应用程序可能还需要更新其端点列表. 这种大规模的重新配置既枯燥又容易出错. &emsp;&emsp;etcd gateway 通过作为一个稳定的本地端点提供服务解决了这个问题. 一个典型的 etcd gateway 配置是让每一个机器运行一个监听本地端口的 gateway, 同时每一个 etcd 应用连接到这个本地 gateway. 这样在 etcd 集群重新配置时只有 gateway 需要更新它的端点配置, 而不是更新每一个应用. &emsp;&emsp;总之, 为了自动传播 etcd 集群端点更改, etcd gateway 应该运行在为访问同一个 etcd 集群的多个应用程序提供服务的每台机器上. 什么时候不应该使用 etcd gateway? 提高性能gateway 不是为了提高 etcd 集群性能而设置. 它不提供缓存, watch 的合并或批处理. etcd 团队正在开发一个旨在提高集群可扩展性的缓存代理. 在集群管理系统上运行高级集群管理系统(如 Kubernetes) 本身支持服务发现, 应用程序可以使用有系统管理的 DNS 名称或虚拟 IP 地址访问 etcd 集群. 例如: kube-proxy 等同于 etcd 网关. 启动 etcd gateway&emsp;&emsp;考虑一个具有以下静态端点的 etcd 集群: Name Address Hostname infra0 10.0.1.10 infra0.example.com infra1 10.0.1.11 infra1.example.com infra2 10.0.1.12 infra2.example.com &emsp;&emsp;使用包含这些静态端点的命令启动 etcd gateway:12$ etcd gateway start --endpoints=infra0.example.com,infra1.example.com,infra2.example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] &emsp;&emsp;或者, 如果使用 DNS 进行服务发现, 请考虑 DNS SRV 条目:1234$ dig +noall +answer SRV _etcd-client._tcp.example.com_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra0.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra1.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra2.example.com. 1234$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.cominfra0.example.com. 300 IN A 10.0.1.10infra1.example.com. 300 IN A 10.0.1.11infra2.example.com. 300 IN A 10.0.1.12 &emsp;&emsp;使用以下命令从 DNS SRV 条目获取端点启动 etcd gateway:12$ etcd gateway --discovery-srv=example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 配置选项etcd 集群--endpoints 逗号分隔的转发客户端连接的目标 etcd 集群列表 默认配置: 127.0.0.1:2379 无效示例: https://127.0.0.1:2379(gateway 不终止 TLS) --discovery-srv 通过 SRV 记录引导集群端点的 DNS 域名 默认配置: (不设置) 网络--listen-addr 接口和端口绑定接收客户端请求 默认: 127.0.0.1:23790 --retry-delay 重试连接到失败的端点之前的延迟时间 默认配置: 1m0s 无效示例: “123”(使用指定格式的时间单位) 安全--insecure-discovery 接收 SRV 记录是不安全或易受到中间人攻击的 默认配置: false --trusted-ca-file 用于 etcd 集群的客户端 TLS CA 文件路径. 用于认证端点. 默认配置: (不设置)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 源码解析: SDS(3)]]></title>
    <url>%2Fredis_source_code_analysis_SDS_3.html</url>
    <content type="text"><![CDATA[注: 基于 redis 4.0. SDS 结构&emsp;&emsp;SDS 结构如下: 12345678910111213141516171819202122232425262728293031323334353637struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;; &emsp;&emsp;其中: len 表示 sds 字符串的长度 alloc 表示 SDS 结构体剩余空间 flags 表示 SDS 结构体类型 buf 表示 sds 字符串&emsp;&emsp;4.0 版本将 3.0 版本时期统一的结构根据 SDS 结构体可以存储字符串的长度划分为不同的 5 种类型, 节省了内存占用的空间, 但是加大字符串操作的复杂度, 在字符串长度变动时需要改变 SDS 结构体类型. SDS 优势 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串时带来的内存重分配次数 二进制安全 兼容部分 C 字符串函数 SDS 内存分配策略 如果直接创建新结点, 会调用 sdsnewlen 函数根据指定字符串的长度创建一个新结点, 新结点没有空闲空间. 如果已有结点需要扩展空间时, 会调用 sdsMakeRoomFor 函数进行扩展.a. 已有结点 sds 字符串空间 &lt; SDS_MAX_PREALLOC, 则对 sds 字符串空间扩展一倍.b. 已有结点 sds 字符串空间 &gt;= SDS_MAX_PREALLOC(1024 * 1024), 则对 sds 字符串空间扩展 SDS_MAX_PREALLOC. SDS 会提供出一组接口使 SDS 的调用者需要释放或分配 SDS 相关的一些东西时可以使用. 同时将分配释放的宏封装起来可以在更换 SDS 分配器时不需要更改调用者中的分配器. SDS 应用 保存数据库中的字符串值. 用作缓冲区(buffer) AOF 模块中的 AOF 缓冲区. 客户端状态中的输入缓冲区. SDS 源码的思考 感觉没有必要使用 SDS_HDR_VAR, 会影响代码的可读性. sdsnewlen 中为什么把 len 和 alloc 设置相同的字符串的长度?len 表示字符串长度, alloc 表示字符串分配的空间, 这时分配空间是按照头结点长度 hdrlen + 字符串长度 initlen + null 终结符 1 进行计算, 分配给字符串的空间即为字符串长度, 所以这时的 len 等于 alloc. sdsnewlen 中为什么 initlen 为 0 时, 类型 5 不擅长?(后续关注对 SDS 的调用) sdsupdatelen 是否已经弃用?(后续关注对 SDS 的调用) sdsRemoveFreeSpace 的注释中 级联 是什么意思?(后续关注对 SDS 的调用) ssdsnew, sdsupdatelen, sdscat, sdscpy 不是二进制安全, sdscatrepr -&gt; sdscatprintf -&gt; sdscatvprintf -&gt; sdscat, sdsjoin -&gt; sdscat, 二级制不安全. 注意 sesdup 调用的 sdslen, 二进制安全的. zfree 的时间复杂度是 O(N)? sdsfree 时间复杂度是 O(N)?(后续关注对 SDS 的调用) sdscatvprintf 对于 buf 的处理为什么是将 -2 的位置置为 ‘\0’?因为在 vsnprintf(buf, buflen, fmt, cpy); 函数中, 无论真正的格式化输出字符串的长度是否超过 buflen, vsnprintf 函数都会将 buf[buflen - 1] 置为 ‘\0’, 所以如果用 -1 位置判断就会出错, 只能用最后一个可以判断的字符即 -2 位置判断. sdsfromlonglong 真的比 sdscatprintf 快吗?sdsfromlonglong 调用 sdsll2str 进行转换, sdscatprintf -&gt; sdscatvprintf -&gt; vsnprintf 函数进行转换, 使用了可变参数. 猜测 vsnprintf 底层转换与 sdsll2str 相似. 在我自己的机器上实测了一下, sdscatprintf 会比 sdsfromlonglong 慢 1us. sdscatrepr 中 ‘\\‘, ‘“‘, 为什么不和其他字符一样使用 sdscatlen?适用 SDS 中自带的测试集进行实测, 是可以实现的. sdssplitargs 如果处理类似 “ test\”aaa\” “ 会将参数识别为 test\”aaa\” 不影响吗?(后续关注对 SDS 的调用) 本文部分内容参考《Redis 设计与实现》一书.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 源码解析: SDS(2)]]></title>
    <url>%2Fredis_source_code_analysis_SDS_2.html</url>
    <content type="text"><![CDATA[注: 基于 redis 4.0. &emsp;&emsp;本文将介绍 SDS 的实现. sds.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785/* SDSLib 2.0, 一个 C 实现的 strings 库 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;#include "sds.h"#include "sdsalloc.h"// 获取不同类型 sds 结构体大小// T = O(1)static inline int sdsHdrSize(char type)&#123; switch(type &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return sizeof(struct sdshdr5); case SDS_TYPE_8: return sizeof(struct sdshdr8); case SDS_TYPE_16: return sizeof(struct sdshdr16); case SDS_TYPE_32: return sizeof(struct sdshdr32); case SDS_TYPE_64: return sizeof(struct sdshdr64); &#125; return 0;&#125;// 根据 string 长度确定存储的 sds 类型// T = O(1)static inline char sdsReqType(size_t string_size)&#123; if(string_size &lt; 1 &lt;&lt; 5) // 最大 31 &#123; return SDS_TYPE_5; &#125; if(string_size &lt; 1 &lt;&lt; 8) // 最大 255 &#123; return SDS_TYPE_8; &#125; if(string_size &lt; 1 &lt;&lt; 16) // 最大 65535 &#123; return SDS_TYPE_16; &#125;#if(LONG_MAX == LLONG_MAX) if(string_size &lt; 1ll &lt;&lt; 32) //最大 2 ^ 32 - 1 &#123; return SDS_TYPE_32; &#125;#endif return SDS_TYPE_64; //最大 2 ^ 64 - 1&#125;// 二进制安全: 只会严格的按照二进制的数据存取. 不会妄图已某种特殊格式解析数据./* 使用 'init' 指针和 'initlen' 指定的内容创建一个新的 sds string. * 如果 'init' 是 NULL, 那么 string 将被初始化为 0 字节. * * 字符串始终为空终止(\0)(所有的 sds 字符串都是, 都总是) * 因此即使你创建一个这样的 sds 字符串: * * mystring = sdsnewlen("abc", 3); * * 你可以使用 printf() 打印字符串, 因为字符串的末尾有一个隐含的 \0. * 同时因为字符串长度保存在 sds 头结点中, 字符串是二进制安全的, \0也可以被包含在 sds 字符串中. * 也就是说 当 mystring = sdsnewlen("abc", 4); 时, \0 也是 sds 字符串中的一部分, 是二进制安全. */// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化// T = O(N)sds sdsnewlen(const void *init, size_t initlen)&#123; void *sh; sds s; // 通过长度获取存储字符串的 SDS 类型 char type = sdsReqType(initlen); /* 为了添加字符串, 空字符串经常被创建. * 使用类型 8, 因为类型 5 在这里不适用. */ if(type == SDS_TYPE_5 &amp;&amp; initlen == 0) &#123; type = SDS_TYPE_8; &#125; // 通过 SDS 类型获取 SDS 头结点大小 int hdrlen = sdsHdrSize(type); unsigned char *fp; /* 标记指针 */ sh = s_malloc(hdrlen + initlen + 1); if(!init) &#123; memset(sh, 0, hdrlen + initlen + 1); &#125; if(sh == NULL) &#123; return NULL; &#125; s = (char *)sh + hdrlen; fp = ((unsigned char *)s) - 1; // 初始化 SDS 头结点 switch(type) &#123; case SDS_TYPE_5: &#123; *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS); break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; &#125; // 如果指定初始化内容, 将它们复制到 sdshdr 的 buf 中 // T = O(N) if(initlen &amp;&amp; init) &#123; memcpy(s, init, initlen); &#125; // 字符串以 \0 结尾 s[initlen] = '\0'; // 返回 buf 部分, 而不是整个 sdshdr return s;&#125;/* 创建一个空(长度为 0) sds 字符串. * 在这种情况下字符串总是含有一个 null(\0) 终结符. */// 创建并返回一个只保存了空字符串 "" 的 sds// T = O(1)sds sdsempty(void)&#123; return sdsnewlen("", 0);&#125;/* 根据一个空终止(\0)的 C 字符串开始创建一个新的 sds 字符串. */// 也只适合 C 字符串// 根据给定字符串 init 创建一个包含同样字符串的 sds// T = O(N)sds sdsnew(const char *init)&#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;/* 复制一个 sds 字符串 */// 复制给定 sds 的副本// T = O(N)sds sdsdup(const sds s)&#123; return sdsnewlen(s, sdslen(s));&#125;/* 释放 sds. 如果 s 为空, 则不需要干什么 */// T = O(N)void sdsfree(sds s)&#123; if(s == NULL) &#123; return ; &#125; s_free((char *)s - sdsHdrSize(s[-1]));&#125;/* 设置 sds 字符串长度为通过 strlen() 获取的长度, * 因此要考虑到内容只能到达第一个 null(\0) 字符. * * 当 sds 字符串被黑客以某种手动方式入侵时, 这个函数是很有用的, * 如下例所示: * * s = sdsnew("foobar"); * s[2] = '\0'; * sdsupdatelen(s); * printf("%d\n", sdslen(s)); * * 输出将会是 2, 如果我们注释调用 sdsupdatelen() 的部分, * 输出将会是 6, 因为字符串被修改, 但是逻辑长度依然是 6. */// 更新 sds 的长度// T = O(1)void sdsupdatelen(sds s)&#123; int reallen = strlen(s); sdssetlen(s, reallen);&#125;/* 修改一个字符串, 使它立刻变成空(长度为 0). * 但是所有现有的缓冲区不会被丢弃, 而是设置为可用空间, * 以便下一次增加操作不需要预先分配可用的字节数. */// 清空 sds 字符串的内容// T = O(1)void sdsclear(sds s)&#123; sdssetlen(s, 0); s[0] = '\0';&#125;/* 在 sds 字符串的尾部扩增可用空间, 以便确保该函数的调用者在调用该函数后可以 sds 字符串末尾写入 addlen 个字节. * 再在末尾加上一个 null 终结符. * * 注意: 注意这个函数不会改变 sdslen() 返回的 sds 字符串的 *length*, * 只能改变我们拥有的可用缓冲区空间. */// 当 sds 字符串空间充足时, 直接返回, 空间不足时, 重新分配空间, 设置 sds 头结点, 字符串内容// T = O(N)sds sdsMakeRoomFor(sds s, size_t addlen)&#123; void *sh; void *newsh; // 获取当前空闲空间大小 size_t avail = sdsavail(s); size_t len; size_t newlen; char type; // 获取当前 sds 的类型 char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; /* 如果空间足够, 立刻返回 */ if(avail &gt;= addlen) &#123; return s; &#125; len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); newlen = (len + addlen); // 如果需要新分配给 sds 字符串的空间的长度小于 sds 最大预分配给 sds 字符串的空间长度 if(newlen &lt; SDS_MAX_PREALLOC) &#123; newlen *= 2; &#125; else &#123; // 如果需要新分配给 sds 字符串的空间的长度大于最大预分配给 sds 字符串的空间长度时, 每次增长最大预分配给 sds 字符串的空间长度 newlen += SDS_MAX_PREALLOC; &#125; // 根据需要新分配给 sds 字符串的空间的长度计算新的 sds 需要的类型 type = sdsReqType(newlen); /* 不要使用类型 5: 当用户扩增字符串时, 由于类型 5 不能记住空闲空间, * 因此调用 sdsMakeRoomFor() 时必须进行扩增操作 */ if(type == SDS_TYPE_5) &#123; type = SDS_TYPE_8; &#125; hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; // 如果新类型与原来的类型相同, 重新分配新长度的 sds 并将原来 sds 字符串(包括头结点和 null 终结符)拷贝到新空间. newsh = s_realloc(sh, hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; /* 由于头结点大小改变, 需要将字符串向前移动, 不能直接使用 realloc */ // 如果新类型与原来的类型不同, 重新分配新类型新长度的 sds newsh = s_malloc(hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; // 将原来的 sds 字符串拷贝到新 sds 中 memcpy((char *)newsh + hdrlen, s, len + 1); // 释放原来的 sds s_free(sh); s = (char *)newsh + hdrlen; // 设置新 sds 类型, 长度 s[-1] = type; sdssetlen(s, len); &#125; // 更新分配空间大小 sdssetalloc(s, newlen); return s;&#125;/* 为了使 sds 字符串结尾没有可用空间, 对其重新分配空间. * 剩下的 sds 字符串没有改变, 但是下一个级联操作将需要重新分配空间. * * 在被调用后, 通过这个函数的 sds 字符串不能变的更长, 所有的指针必须被调用返回的新指针替换 */// 将 sds 字符串的空间缩短到字符串自身的长度.// T = O(N)sds sdsRemoveFreeSpace(sds s)&#123; void *sh; void *newsh; char type; char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; size_t len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); type = sdsReqType(len); hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; newsh = s_realloc(sh, hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; newsh = s_malloc(hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; memcpy((char *)newsh + hdrlen, s, len + 1); s_free(sh); s = (char *)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); &#125; sdssetalloc(s, len); return s;&#125;/* 返回指定 sds 字符串分配总空间的大小 * 包括: * 1) 指针前的 sds 头结点. * 2) 字符串. * 3) 结尾若干可用缓冲区. * 4) 隐含的 null 终结符. */// 获取分配给 sds 的总空间// T = O(1)size_t sdsAllocSize(sds s)&#123; size_t alloc = sdsalloc(s); return sdsHdrSize(s[-1]) + alloc + 1;&#125;/* 返回 sds 真实的分配总空间(通常, sds 字符串作为字符串缓冲区开始的参考) */// 获取 sds 总空间的指针// T = O(1)void *sdsAllocPtr(sds s)&#123; return (void *)(s = sdsHdrSize(s[-1]));&#125;/* 根据 'incr' 增加 sds 字符串长度, 并减小字符串左侧可用空间. * 同时在新的字符串结尾设置 null 终结符. * * 使用这个函数是为了在用户调用 sdsMakeRoomFor() 函数后, 在当前字符串的结尾写入一些东西, * 最后需要设置字符串新长度是修改字符串的长度. * * 注意: 可以使用负增量来从右侧缩减字符串. * * 用法示例: * * 使用以下模式调用 sdsIncrLen() 和 sdsMakeRoomFor(), 可以将字符串直接从内核挂载连接到 * sds 字符串末尾, 不需要复制到中间缓冲区. * * oldlen = sdslen(s); * s = sdsMakeRoomFor(s, BUFFER_SIZE); * nread = read(fd, s + oldlen, BUFFER_SIZE); * ... 检查 nread &lt;= 0 并处理它 ... * sdsIncrLen(s, nread); */// 修改 sds 字符串长度// T = O(1)void sdsIncrLen(sds s, int incr)&#123; unsigned char flags = s[-1]; size_t len; // 修改 sds 字符串长度 switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char oldlen = SDS_TYPE_5_LEN(flags); assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr))); *fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS); len = oldlen + incr; break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; default: len = 0; /* 只是为了避免编译警告 */ &#125; s[len] = '\0';&#125;/* 将 sds 字符串的长度增长到指定长度. 增长的长度初始化为 0. * * 如果指定的长度比当前 sds 字符串的短, 则不执行任何操作. */// 增长字符串, 并将增加的部分置为 0// T = O(N)sds sdsgrowzero(sds s, size_t len)&#123; size_t curlen = sdslen(s); if(len &lt;= curlen) &#123; return s; &#125; // 扩增 sds 字符串分配的空间 s = sdsMakeRoomFor(s, len - curlen); if(s == NULL) &#123; return NULL; &#125; /* 确保添加的区域不包含垃圾 */ // 将添加区域初始化为 0 memset(s + curlen, 0, (len - curlen + 1)); sdssetlen(s, len); return s;&#125;/* 在 sds 字符串 's' 后添加二进制安全的 len 个字节的 't' 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加长度为 len 的字符串// T = O(N)sds sdscatlen(sds s, const void *t, size_t len)&#123; size_t curlen = sdslen(s); // 空间足够直接返回, 空间不足获取空间 s = sdsMakeRoomFor(s, len); if(s == NULL) &#123; return NULL; &#125; memcpy(s + curlen, t, len); sdssetlen(s, curlen + len); s[curlen + len] = '\0'; return s;&#125;/* 在 sds 字符串后添加指定以 null 终止的 C 字符串. * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定以 null 终止的 C 字符串.// T = O(N)sds sdscat(sds s, const char *t)&#123; return sdscatlen(s, t, strlen(t));&#125;/* 在现有 sds 字符串后添加指定 sds 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定 sds 字符串.// T = O(N)sds sdscatsds(sds s, const sds t)&#123; return sdscatlen(s, t, sdslen(t));&#125;/* 破坏性的修改 sds 字符串来保存指定的长度为 'len' 字节的二进制安全的字符串 't'. */// 拷贝二进制安全字符串 't' 到 sds 字符串中.// T = O(N)sds sdscpylen(sds s, const char *t, size_t len)&#123; // 查看字符串空间是否足够 if(sdsalloc(s) &lt; len) &#123; s = sdsMakeRoomFor(s, len - sdslen(s)); if(s == NULL) &#123; return NULL; &#125; &#125; memcpy(s, t, len); s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 类似 sdscpylen() 但是 't' 必须是一个以 null 终结的字符串, 以便通过 strlen() 获取字符串长度. */// 对 C 字符串进行拷贝// T = O(N)sds sdscpy(sds s, const char *t)&#123; return sdscpylen(s, t, strlen(t));&#125;/* 帮助 sdscatlonglong() 进行实际的数字 -&gt; 字符串的转换. * 's' 必须指向一个最少 SDS_LLSTR_SIZE 字节的字符串空间. * * 这个函数返回存储在 's' 中的以 null 终结的字符串表示的长度 */// long long 类型转换为 string 类型// T = O(N)#define SDS_LLSTR_SIZE 21int sdsll2str(char *s, long long value)&#123; char *p; char aux; unsigned long long v; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ // 将 long long 反转存储在字符串中 v = (value &lt; 0) ? -value : value; p = s; // T = O(N) do &#123; // 只能适用于 C 语言字符集 *p++ = '0' + (v % 10); v /= 10; &#125;while(v); if(value &lt; 0) &#123; *p++ = '-'; &#125; /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ // 将反转的字符串反转就是 long long 的顺序字符串表示 // T = O(N) p --; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 与 sdsll2str() 相同, 但是这个函数是针对 unsigned long long 类型. */// unsigned long long 类型转换为 string 类型// T = O(N)int sdsull2str(char *s, unsigned long long v)&#123; char *p; char aux; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ p = s; do &#123; *p++ = '0' + (v % 10); v /= 10; &#125;while(v); /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 根据一个 long long 值创建一个 sds 字符串. 这要比以下方式快很多: * * sdscatprintf(sdsempty(), "%lld\n", value); */// long long 类型转换为 sds 类型// T = O(N)sds sdsfromlonglong(long long value)&#123; char buf[SDS_LLSTR_SIZE]; int len = sdsll2str(buf, value); return sdsnewlen(buf, len);&#125;/* 类似 sdscatprintf() 但是获取的是 va_list 而不是可变参数 */// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// T = O(N)sds sdscatvprintf(sds s, const char *fmt, va_list ap)&#123; va_list cpy; char staticbuf[1024]; char *buf = staticbuf; char *t; size_t buflen = strlen(fmt) * 2; /* 我们尝试开始使用静态缓冲区来提升速度. * 如果不可能, 我们回到使用堆分配. */ if(buflen &gt; sizeof(staticbuf)) &#123; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; &#125; else &#123; buflen = sizeof(staticbuf); &#125; /* 每次当我们使用当前缓冲区大小无法适应字符串时, 尝试使用缓冲区的两倍大小. */ while(1) &#123; buf[buflen - 2] = '\0'; va_copy(cpy, ap); vsnprintf(buf, buflen, fmt, cpy); va_end(cpy); if(buf[buflen - 2] != '\0') &#123; // 缓冲区大小无法适应字符串. if(buf != staticbuf) &#123; // 在堆上分配的空间, 释放 s_free(buf); &#125; // 重新分配两倍大小的空间 buflen *= 2; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; continue; &#125; // 直到适应字符串 break; &#125; /* 最后将获得的字符串添加到 sds 字符串并返回它. */ // 将字符串添加到 sds 字符串后 t = sdscat(s, buf); if(buf != staticbuf) &#123; s_free(buf); &#125; return t;&#125;/* 将使用类似 printf 指定格式获得的字符串添加到 sds 字符串. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("Sum is: "); * s = sdscatprintf(s, "%d+%d = %d", a, b, a + b); * * 通常, 你需要使用类似 printf 格式从头创建一个字符串. * 当你需要时, 只需要使用 sdsempty() 作为字符串: * * s = sdscatprintf(sdsempty(), "... your format ...", args); */// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串// T = O(N)sds sdscatprintf(sds s, const char *fmt, ...)&#123; va_list ap; char *t; va_start(ap, fmt); t = sdscatvprintf(s, fmt, ap); va_end(ap); return t;&#125;/* 这个函数类似 sdscatprintf, 但是要快很多, 它没有依靠 libc 中通常很慢的 sprintf() 系列函数. * 此外, 将 sds 字符串作为被连接新数据直接处理提供了性能改进. * * 然而, 这个函数只处理类似 printf 的格式说明符的不兼容子集. * * %s - C 字符串 * %S - SDS 字符串 * %i - 有符号整形 * %I - 64 位有符号整形(long long, int64_t) * %u - 无符号整形 * %U - 64 位无符号整形(unsigned long long, uint64_t) * %% - % 字符 */// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串// T = O(N)sds sdscatfmt(sds s, char const *fmt, ...)&#123; size_t initlen = sdslen(s); const char *f = fmt; int i; va_list ap; // 开始遍历参数 va_start(ap, fmt); f = fmt; /* 遍历格式化输出字符串中格式说明符下一个要处理的字节. */ i = initlen; /* 写入目标字符串下一个字节的位置. */ // 遍历格式化输出字符串 while(*f) &#123; char next, *str; size_t l; long long num; unsigned long long unum; /* 确保至少有一个字节的空间 */ // 确保当该字符不是说明符时有可以存储的 1 字节空间 if(sdsavail(s) == 0) &#123; s = sdsMakeRoomFor(s, 1); &#125; // 处理有可能为说明符的情况, 即 *f 为 %. switch(*f) &#123; case '%': next = *(f + 1); f++; switch(next) &#123; case 's': case 'S': str = va_arg(ap, char *); l = (next == 's') ? strlen(str) : sdslen(str); // 空间不足时扩容 if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; // 将字符串添加到 sds 字符串后 memcpy(s + i, str, l); sdsinclen(s, l); i += l; break; case 'i': case 'I': if(next == 'i') &#123; num = va_arg(ap, int); &#125; else &#123; num = va_arg(ap, long long); &#125; // 将 long long 转换为字符串 char buf[SDS_LLSTR_SIZE]; l = sdsll2str(buf, num); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; case 'u': case 'U': if(next == 'u') &#123; unum = va_arg(ap, unsigned int); &#125; else &#123; unum = va_arg(ap, unsigned long long); &#125; char buf[SDS_LLSTR_SIZE]; l = sdsull2str(buf, unum); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; default: /* 处理 %%, 通常为 %&lt;unknown&gt;. */ s[i++] = next; sdsinclen(s, 1); break; &#125; break; // 处理不是 % 开头的可能为说明符的情况 default: s[i++] = *f; sdsinclen(s, 1); break; &#125; f++; &#125; va_end(ap); /* 添加 null 终结符 */ s[i] = '\0'; return s;&#125;/* 从字符串左边和右边分别删除 sds 字符串的一部分, 删除的字符串为在 'cset' 中找到的字符组成的连续字符, * 'cset' 字符串是一个 null 终结的 C 字符串. * * 在调用这个函数后, 被修改 sds 字符串不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("AA...AA.a.aa.aHellWorld :::"); * s = sdstrim(s, "Aa. :"); * printf("%s\n", s); * * 只输出 "Hello World" */// 删除 sds 字符串首尾在 'cset' 中存在的字符串// T = O(M*N)，M 为 SDS 长度, N 为 cset 长度sds sdstrim(sds s, const char *cset)&#123; char *start; char *end; char *sp; char *ep; size_t len; sp = start = s; ep = end = s + sdslen(s) - 1; // 从头向尾遍历 // T = O(M * N) while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) &#123; sp++; &#125; // 从尾向头遍历 while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) &#123; ep--; &#125; len = (sp &gt; ep) ? 0 : ((ep - sp) + 1); // 移动剩余部分 if(s != sp) &#123; memmove(s, sp, len); &#125; s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串. * * start 和 end 可以是负数, 其中 -1 表示字符串的最后一个字符, -2 表示倒数第二个字符, 等等. * * 间隔是包含的, 因此开始和结束字符是生成字符串的一部分. * * 字符串就地被修改. * * 例如: * * s = sdsnew("Hello World"); * sdsrange(s, 1, -1); // =&gt; "ello World" */// 将 sds 字符串缩短为 'start' 到 'end' 之间, 闭区间// T = O(N)void sdsrange(sds s, int start, int end)&#123; size_t newlen; size_t len = sdslen(s); if(len == 0) &#123; return ; &#125; // 如果指定 'start' 是负数 if(start &lt; 0) &#123; start = len + start; if(start &lt; 0) &#123; // 赋值负数超出字符串范围的 start 为 0 start = 0; &#125; &#125; if(end &lt; 0) &#123; end = len + end; if(end &lt; 0) &#123; end = 0; &#125; &#125; // 计算 start 和 end 指定子串的长度, 包含 start 和 end newlen = (start &gt; end) ? 0 : (end - start) + 1; if(newlen != 0) &#123; if(start &gt;= (signed)len) &#123; newlen = 0; &#125; else if(end &gt;= (signed)len) &#123; end = len - 1; newlen = (start &gt; end) ? 0 : (end - start) + 1; &#125; &#125; else &#123; // 这里 newlen = 0, 一定进入下一个 if start = 0; &#125; // 清楚 start 前的字符 if(start &amp;&amp; newlen) &#123; memmove(s, s + start, newlen); &#125; // newlen 为 0 时, 清空字符串. // 即为 s[newlen] = '\0'; s[newlen] = 0; sdssetlen(s, newlen);&#125;/* 对 sds 字符串 's' 的每一个字符调用 tolower() */// 将 sds 字符串 's' 中的字母转换为小写字母// T = O(N)void sdstolower(sds s)&#123; int len = sdslen(s); int j; // 转换每一个字符 for(j = 0; j &lt; len; j++) &#123; s[j] = tolower(s[j]); &#125;&#125;/* 对 sds 字符串 's' 的每一个字符调用 sdstoupper() */// 将 sds 字符串 's' 中的字母转换为大写字母// T = O(N)void sdstoupper(sds s)&#123; int len = sdslen(s); int j; for(j = 0; j &lt; len; j++) &#123; s[j] = toupper(s[j]); &#125;&#125;/* 使用 memcmp() 比较两个 sds 字符串 s1 和 s2. * * 返回值: * * 如果 s1 &gt; s2, 返回正数. * 如果 s1 &lt; s2, 返回负数. * 如果s1和s2是完全相同的二进制字符, 则为0. * * 如果两个字符串共享完全相同的前缀, 但是其中的一个长度更长, 则较长的字符串被认为大于较小的字符串. */// 比较两个字符串// T = O(N)int sdscmp(const sds s1, const sds s2)&#123; size_t l1; size_t l2; size_t minlen; int cmp; l1 = sdslen(s1); l2 = sdslen(s2); // 获取最小长度 minlen = (l1 &lt; l2) ? l1 : l2; // 比较最小长度空间中的字符 cmp = memcmp(s1, s2, minlen); if(cmp == 0) &#123; // 最小长度空间中字符相同, 返回长度的差值, 为 0 则两个字符串相同 return l1 - l2; &#125; // 返回最小长度空间中不同字符的差 return cmp;&#125;/* 使用分隔符 'sep' 分割 's'. 返回 sds 字符串数组. * *count 将会被指针设置为 sds 的数量. * * 内存溢出, 空字符串, 空分隔符将会返回 NULL. * * 注意: 'sep' 可以是一个由多个字符组成的分隔符. 例如: * sdssplit("foo_-_bar", "_-_"); * 将返回 "foo" 和 "bar" 两个元素. * * 这个函数的版本是二级制安全的, 但是需要参数长度. * sdssplit() 是只针对 NULL 终结的字符串的相同函数. */// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾// T = O(N ^ 2)sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count)&#123; int elements = 0; int slots = 5; int start = 0; int j; sds *tokens; if(seplen &lt; 1 || len &lt; 0) &#123; return NULL; &#125; tokens = s_malloc(sizeof(sds) * slots); if(tokens == NULL) &#123; return NULL; &#125; if(len == 0) &#123; *count = 0; return tokens; &#125; // 遍历字符串 // T = O(N ^ 2) for(j = 0; j &lt; (len - (seplen - 1)), j++) &#123; /* 确保下一个元素和最后一个元素有空间 */ if(slots &lt; elements + 2) &#123; sds *newtokens; slots *= 2; newtokens = s_realloc(tokens, sizeof(sds) * slots); if(newtokens == NULL) &#123; goto cleanup; &#125; tokens = newtokens; &#125; /* 搜索分隔符 */ // T = O(N) if((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) &#123; // 找到分隔符 tokens[elements] = sdsnewlen(s + start, j - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; start = j + seplen; // 麻蛋, -1 是因为 for 循环自己加了 1 j = j + seplen - 1; /* 跳过分隔符 */ &#125; &#125; /* 添加最后一个元素. 我们确定在标记数组中存在空间. */ tokens[elements] = sdsnewlen(s + start, len - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; *count = elements; return tokens; // 错误处理 cleanup: &#123; int i; // 清理空间 for(i = 0; i &lt; elements; i++) &#123; sdsfree(tokens[i]); &#125; s_free(tokens); *count = 0; return NULL; &#125;&#125;/* 释放 sdssplitlen() 返回的结果, 或者当 'tokens' 为 NULL 时什么都不做. */// 释放分割的结果// T = O(N)void sdsfreesplitres(sds *tokens, int count)&#123; if(!tokens) &#123; return ; &#125; while(count--) &#123; sdsfree(tokens[count]); &#125; s_free(tokens);&#125;/* 为 sds 字符串 's' 添加将所有无法打印的字符(使用 isprint() 测试) * 变成 "\n\r\a..." 或 "\x&lt;hex-number&gt;" 转移的形式组成的转义字符串的表示. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. */// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.// T = O(N)sds sdscatrepr(sds s, const char *p, size_t len)&#123; s = sdscatlen(s, "\"", 1); while(len--) &#123; switch(*p) &#123; case '\\': case '"': s = sdscatprintf(s, "\\%c", *p); break; // case '\\': s = sdscatlen(s, "\\\\", 2); break; // case '"': s = sdscatlen(s, "\\\"", 2); break; case '\n': s = sdscatlen(s, "\\n", 2); break; case '\r': s = sdscatlen(s, "\\r", 2); break; case '\t': s = sdscatlen(s, "\\t", 2); break; case '\a': s = sdscatlen(s, "\\a", 2); break; case '\b': s = sdscatlen(s, "\\b", 2); break; default: if(isprint(*p)) &#123; s = sdscatprintf(s, "%c", *p); &#125; else &#123; s = sdscatprintf(s, "\\x%02x", (unsigned char) *p); &#125; break; &#125; p++; &#125; return sdscatlen(s, "\"", 1);&#125;/* sdssplitargs() 的辅助函数, 如果 'c' 是有效的十六进制, 则返回非零. */// 测试字符是否为十六进制字符// T = O(1)int is_hex_digit(char c)&#123; return (c &gt;= '0' &amp;&amp; c &lt;='9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F');&#125;/* sdssplitargs() 的辅助函数, 将十六进制数转换为从 0 到 15 的整数. */// 将十六进制转换为从 0 到 15 的整数.// T = O(1)int hex_digit_to_int(char c)&#123; switch(c) &#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; default: return 0; &#125;&#125;/* 把一行文本切割成多个参数, 每个参数可以有以下的类编程语言 REPL 格式: * * foo bar "newline are suported\n" and "\xff\x00otherstuff" * * 参数的数量存储在 *argc 中, 这个函数会返回一个 sds 数组. * * 调用者应该调用 sdsfreesplitres() 函数释放生成的 sds 数组. * * 注意: sdscatrepr() 可以将一个字符串转换为一个带引号的字符串, * 相同格式的字符串可以被 sdssplitargs() 函数解析. * * 即使当输入出现空字符串, 函数仍然会将成功处理的字符串返回. * 或当输入不对应的引号或后引号后面没有跟空格例如: "foo"bar 或 "foo' 时返回 NULL. */// * 这个函数主要用于 config.c 中对配置文件进行分析, 将字符串按照 REPL 格式切分成一个 sds 参数数组.// * // * 例如:// * sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");// * 会得出:// * arr[0] = "timeout"// * arr[1] = "10086"// * arr[2] = "port"// * arr[3] = "123321"// * T = O(N)sds *sdssplitargs(const char *line, int *argc)&#123; const char *p = line; char *current = NULL; char **vector = NULL; *argc = 0; while(1) &#123; // 遇到空格跳过 // T = O(N) while(*p &amp;&amp; isspace(*p)) &#123; p++; &#125; if(*p) &#123; /* 获取一个标记 */ int inq = 0; /* 如果遇到引号设置为 1 */ int insq = 0; /* 如果遇到单引号设置为 1 */ // 当前参数结束了设置为 1 int done = 0; // 获取一个 sds 存储参数 if(current == NULL) &#123; current = sdsempty(); &#125; // T = O(N) while(!done) &#123; if(inq) &#123; // 前面遍历过前引号 if(*p == '\\' &amp;&amp; *(p + 1) == 'x' &amp;&amp; is_hex_digit(*(p + 2)) &amp;&amp; is_hex_digit(*(p + 3))) &#123; // 遇到十六进制表示, 转换为字符 unsigned char byte; byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3)); current = sdscatlen(current, (char *)&amp;byte, 1); p += 3; &#125; else if(*p == '\\' &amp;&amp; *(p + 1)) &#123; // 遇到转义字符, 转换为对应的字符 char c; p++; switch(*p) &#123; case 'n': c = '\n'; break; case 'r': c = '\r'; break; case 't': c = '\t'; break; case 'b': c = '\b'; break; case 'a': c = '\a'; break; default: c = *p; break; &#125; current = sdscatlen(current, &amp;c, 1); &#125; else if(*p == '"') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; // 不是执行错误处理代码 goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ // 没有后引号就结束 goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else if(insq) &#123; // 前面遍历过前单引号 if(*p == '\\' &amp;&amp; *(p + 1) == '\'') &#123; // 遇到转义的单引号 p++; current = sdscatlen(current, "'", 1); &#125; else if(*p == '\'') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后单引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else &#123; // 不在引号内的字符 switch(*p) &#123; // 分隔参数的符号 case ' ': case '\n': case '\r': case '\t': case '\0': done = 1; break; // 前引号 case '"': inq = 1; break; // 后引号 case '\'': insq = 1; break; // 普通字符 default: current = sdscatlen(current, p, 1); break; &#125; &#125; // 指针向后移动 if(*p) &#123; p++; &#125; &#125; /* 在 vector 中添加标记 */ // 将参数添加到参数数组 vector 中 // T = O(N) vector = s_realloc(vector, ((*argc) + 1) * sizeof(char *)); vector[*argc] = current; (*argc)++; current = NULL; &#125; else &#123; /* 即使是空字符串仍然返回一些内容, 不会返回 NULL */ // 字符串遍历结束 if(vector == NULL) &#123; vector = s_malloc(sizeof(void *)); &#125; return vector; &#125; &#125; err: &#123; // 出错时, 清理内存空间, 返回 NULL while((*argc)--) &#123; sdsfree(vector[*argc]); &#125; s_free(vector); if(current) &#123; sdsfree(current); &#125; *argc = 0; return NULL; &#125;&#125;/* 将 sds 字符串中所有 'from' 字符串中指定的字符集出现的字符替换为 'to' 数组中相应位置的字符. * * 例如: * sdsmapchars(mystring, "ho", "01", 2); * 将具有将字符串 "hello" 转换为 "0ell1" 的效果. * * 这个函数返回 sds 字符串指针, 它总是与输入指针大小相同, 因此不需要调整大小. */// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符// T = O(M * N) M 为 setlen 的长度, N 为 s 的长度sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen)&#123; size_t j; size_t i; size_t l = sdslen(s); for(j = 0; j &lt; l; j++) &#123; for(i = 0; i &lt; setlen; i++) &#123; if(s[j] == from[i]) &#123; s[j] = to[i]; break; &#125; &#125; &#125; return s;&#125;/* 使用指定分隔符(C 字符串)将一个 C 字符串数组组合成一个 sds 字符串. * 以 sds 字符串形式返回结果 */// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全// T = O(N)sds sdsjoin(char **argv, int argc, char *sep)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscat(join, argv[j]); if(j != argc - 1) &#123; join = sdscat(join, sep); &#125; &#125; return join;&#125;/* 类似 sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串. */// T = O(N)sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscatsds(join, argv[j]); if(j != argc - 1) &#123; join = sdscatlen(join, sep, seplen); &#125; &#125; return join;&#125;/* 低等级函数作为 API 暴露给用户使用 *//* 封装被 SDS 使用的分配器. * 注意: 为了避免函数调用过程的付出开销, SDS 实际上只使用 sdsalloc.h 中定义的宏. * 这里, 我们定义这些封装只有在当链接 SDS 的程序想要接触 SDS 构件的时候使用, 即使它们使用的是不同的分配器. */// 在 SDS 的调用者需要释放或申请 SDS 相关的一些东西时可以使用这三个程序.// 将分配释放的宏封装起来应该是为了在更换 SDS 分配器时不需要更改调用者中的分配器.void *sds_malloc(size_t size)&#123; return s_malloc(size);&#125;void *sds_realloc(void *ptr, size_t size)&#123; return s_realloc(ptr, size);&#125;void sds_free(void *ptr)&#123; s_free(ptr);&#125;// 测试代码#if defined(SDS_TEST_MAIN)#include &lt;stdio.h&gt;#include "testhelp.h"#include "limits.h"#define UNUSED(x) (void)(x)int sdsTest(void) &#123; &#123; sds x = sdsnew("foo"), y; test_cond("Create a string and obtain the length", sdslen(x) == 3 &amp;&amp; memcmp(x,"foo\0",4) == 0) sdsfree(x); x = sdsnewlen("foo",2); test_cond("Create a string with specified length", sdslen(x) == 2 &amp;&amp; memcmp(x,"fo\0",3) == 0) x = sdscat(x,"bar"); test_cond("Strings concatenation", sdslen(x) == 5 &amp;&amp; memcmp(x,"fobar\0",6) == 0); x = sdscpy(x,"a"); test_cond("sdscpy() against an originally longer string", sdslen(x) == 1 &amp;&amp; memcmp(x,"a\0",2) == 0) x = sdscpy(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"); test_cond("sdscpy() against an originally shorter string", sdslen(x) == 33 &amp;&amp; memcmp(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0",33) == 0) sdsfree(x); x = sdscatprintf(sdsempty(),"%d",123); test_cond("sdscatprintf() seems working in the base case", sdslen(x) == 3 &amp;&amp; memcmp(x,"123\0",4) == 0) sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX); test_cond("sdscatfmt() seems working in the base case", sdslen(x) == 60 &amp;&amp; memcmp(x,"--Hello Hi! World -9223372036854775808," "9223372036854775807--",60) == 0) printf("[%s]\n",x); sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX); test_cond("sdscatfmt() seems working with unsigned numbers", sdslen(x) == 35 &amp;&amp; memcmp(x,"--4294967295,18446744073709551615--",35) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," x"); test_cond("sdstrim() works when all chars match", sdslen(x) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," "); test_cond("sdstrim() works when a single char remains", sdslen(x) == 1 &amp;&amp; x[0] == 'x') sdsfree(x); x = sdsnew("xxciaoyyy"); sdstrim(x,"xy"); test_cond("sdstrim() correctly trims characters", sdslen(x) == 4 &amp;&amp; memcmp(x,"ciao\0",5) == 0) y = sdsdup(x); sdsrange(y,1,1); test_cond("sdsrange(...,1,1)", sdslen(y) == 1 &amp;&amp; memcmp(y,"i\0",2) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,-1); test_cond("sdsrange(...,1,-1)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,-2,-1); test_cond("sdsrange(...,-2,-1)", sdslen(y) == 2 &amp;&amp; memcmp(y,"ao\0",3) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,2,1); test_cond("sdsrange(...,2,1)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,100); test_cond("sdsrange(...,1,100)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,100,100); test_cond("sdsrange(...,100,100)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); sdsfree(x); x = sdsnew("foo"); y = sdsnew("foa"); test_cond("sdscmp(foo,foa)", sdscmp(x,y) &gt; 0) sdsfree(y); sdsfree(x); x = sdsnew("bar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) == 0) sdsfree(y); sdsfree(x); x = sdsnew("aar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) &lt; 0) sdsfree(y); sdsfree(x); x = sdsnewlen("\a\n\0foo\r",7); y = sdscatrepr(sdsempty(),x,sdslen(x)); test_cond("sdscatrepr(...data...)", memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0) &#123; unsigned int oldfree; char *p; int step = 10, j, i; sdsfree(x); sdsfree(y); x = sdsnew("0"); test_cond("sdsnew() free/len buffers", sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0); /* Run the test a few times in order to hit the first two * SDS header types. */ for (i = 0; i &lt; 10; i++) &#123; int oldlen = sdslen(x); x = sdsMakeRoomFor(x,step); int type = x[-1]&amp;SDS_TYPE_MASK; test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen); if (type != SDS_TYPE_5) &#123; test_cond("sdsMakeRoomFor() free", sdsavail(x) &gt;= step); oldfree = sdsavail(x); &#125; p = x+oldlen; for (j = 0; j &lt; step; j++) &#123; p[j] = 'A'+j; &#125; sdsIncrLen(x,step); &#125; test_cond("sdsMakeRoomFor() content", memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0); test_cond("sdsMakeRoomFor() final length",sdslen(x)==101); sdsfree(x); &#125; &#125; test_report() return 0;&#125;#endif#ifdef SDS_TEST_MAINint main(void) &#123; return sdsTest();&#125;#endif]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 源码解析: SDS(1)]]></title>
    <url>%2Fredis_source_code_analysis_SDS_1.html</url>
    <content type="text"><![CDATA[注: 基于 redis 4.0. &emsp;&emsp;本文将介绍 SDS 的头文件. SDS 的头文件包括两个文件: sds.h 和 sdsalloc.h. sds.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/* SDSLib 2.0, 一个 C 实现的 strings 库 */#ifndef __SDS_H#define __SDS_H// 最大预分配给 sds 字符串的空间长度(分配给 sds 字符串的空间最大增长长度)#define SDS_MAX_PREALLOC (1024 * 1024)#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdint.h&gt;// 类别名, 用于指向 sdshdr 的 buf 属性typedef char *sds;// lsb 最低有效位/* 注意: sdshdr5 是永远不会被使用的, 它只是被我们用来直接获取 flags 标记字节. * 这里是记录 SDS strings类型 5 的布局. */struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3// 麻蛋, C 实现的多态... 吓尿了... // 但是感觉在代码中突然冒出一个 sh 会影响程序的可读性.#define SDS_HDR_VAR(T, s) struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)))#define SDS_HDR(T, s) ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))#define SDS_TYPE_5_LEN(f) ((f) &gt;&gt; SDS_TYPE_BITS)// 获取 sds 实际保存的字符串的长度// T = O(1)static inline size_t sdslen(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;len; &#125; return 0;&#125;// 获取 sds 分配给 sds 字符串的空间的长度与保存的字符串长度之差, 即空闲空间// T = O(1)static inline size_t sdsavail(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125;// 设置 sds 实际保存的字符串长度// T = O(1)static inline void sdssetlen(sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len = newlen; break; &#125;&#125;// 设置 sds 实际保存字符串增加的长度// T = O(1)static inline void sdsinclen(sds s, size_t inc)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char newlen = SDS_TYPE_5_LEN(flags) + inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); //=============================感觉没有必要呀 &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len += inc; break; &#125;&#125;/* sdsalloc() = sdsavail() + sdslen() */// 获取 sds 分配给 sds 字符串的空间的长度// T = O(1)static inline size_t sdsalloc(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;alloc; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;alloc; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;alloc; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;alloc; &#125; return 0;&#125;// 设置分配给 sds 字符串的空间长度// T = O(1)static inline void sdssetalloc(const sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: /* 不需要做什么事, 这个类型没有分配给 sds 字符串的空间信息 */ break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;alloc = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;alloc = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;alloc = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;alloc = newlen; break; &#125;&#125;sds sdsnewlen(const void *init, size_t initlen); // 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化sds sdsnew(const char *init); // 根据给定字符串 init 创建一个包含同样字符串的 sdssds sdsempty(void); // 创建并返回一个只保存了空字符串 "" 的 sdssds sdsdup(const sds s); // 复制给定 sds 的副本void sdsfree(sds s); // 释放 sds. 如果 s 为空, 则不需要干什么sds sdsgrowzero(sds s, size_t len); // 增长字符串, 并将增加的部分置为 0sds sdscatlen(sds s, const void *t, size_t len); // 在 sds 字符串后添加长度为 len 的字符串sds sdscat(sds s, const char *t); // 在 sds 字符串后添加指定以 null 终止的 C 字符串.sds sdscatsds(sds s, const sds t); // 在 sds 字符串后添加指定 sds 字符串.sds sdscpylen(sds s, const char *t, size_t len); // 拷贝二进制安全字符串 't' 到 sds 字符串中.sds sdscpy(sds s, const char *t); // 对 C 字符串进行拷贝sds sdscatvprintf(sds s, const char *fmt, va_list ap); // 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串#ifdef __GNUC__sds sdscatprintf(sds s, const char *fmt, ...) __attribute__((format(printf, 2, 3)));#elsesds sdscatprintf(sds s, const char *fmt, ...);#endifsds sdscatfmt(sds s, char const *fmt, ...); // 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串sds sdstrim(sds s, const char *cset); // 删除 sds 字符串首尾在 'cset' 中存在的字符串void sdsrange(sds s, int start, int end); //将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.void sdsupdatelen(sds s); // 更新 sds 的长度void sdsclear(sds s); // 清空 sds 字符串的内容int sdscmp(const sds s1, const sds s2); // 比较两个字符串sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count); // 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾void sdsfreesplitres(sds *tokens, int count); // 释放分割的结果void sdstolower(sds s); // 将 sds 字符串 's' 中的字母转换为小写字母void sdstoupper(sds s); // 将 sds 字符串 's' 中的字母转换为大写字母sds sdsfromlonglong(long long value); // long long 类型转换为 sds 类型sds sdscatrepr(sds s, const char *p, size_t len); // 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.sds *sdssplitargs(const char *line, int *argc); // 将字符串按照 REPL 格式切分成一个 sds 参数数组sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen); // 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符sds sdsjoin(char **argv, int argc, char *sep); // 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen); // 类似sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串/* 低等级函数作为 API 暴露给用户使用 */sds sdsMakeRoomFor(sds s, size_t addlen);void sdsIncrLen(sds s, int incr);sds sdsRemoveFreeSpace(sds s);size_t sdsAllocSize(sds s);void *sdsAllocPtr(sds s);/* 将 SDS 使用的分配器输出给调用 SDS 的程序使用. * 有时链接 SDS 的程序可能会设置不同的迭代器, 但是可能想要分配或释放 SDS 分别释放或分配的一些东西. */// 封装 SDS 分配器给调用者使用void *sds_malloc(size_t size);void *sds_realloc(void *ptr, size_t size);void sds_free(void *ptr);#ifdef REDIS_TESTint sdsTest(int argc, char *argv[]);#endif#endif sdsalloc.h12345678910111213/* SDSLib 2.0, 一个 C 实现的 strings 库 *//* SDS 选择分配器. * * 使用这个文件是为了在编译时可以改变 SDS 的分配器. * 只需要根据你需要使用的分配器定义宏. * 也需要根据需要 include(导入) 你用来替换的分配器的库 * (使用默认分配器不需要). */#include "zmalloc.h"#define s_malloc zmalloc#define s_realloc zrealloc#define s_free zfree]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 源码解析]]></title>
    <url>%2Fredis_source_code_analysis.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.&emsp;&emsp;以前一直没有阅读过真正大项目的源码, 真正开始阅读才发现Redis的源码对我来说真的是好庞大, 一个文件上千行代码, 利用工作之余阅读, 尽量做到认真阅读每行代码, 大于要花大半个月的时间, 算算时间可能阅读完Redis源码需要花费的时间要超过一年. 回顾以往经历, 对自己能否坚持下来很是担心. 正好这两天我也在看一个大神的博客, 想自己搞个博客, 写点东西. 所以搞个博客记录一下自己的学习. 一方面可以归纳总结自己所学到的东西, 有不对的地方也可以被其他人指正; 另一方面有人阅读我的文章也是对我的一种激励, 避免一个人独自学习因为无聊而放弃.最开始在网上找到了一份关于Redis 2.8 的中文注释源码, 就开始阅读这份源码. 在阅读过程中查资料时发现了 Redis设计与实现 , 感觉这个本书写的挺不错, 而且也附带有一份关于Redis 3.0 的中文注释源码, 同时由于发现了一处Redis源码中的小问题在向Redis提交代码是发现最新的Redis已经到了4.0版本. 于是决定参考2.8和3.0的源码阅读Redis 4.0版本的源码. 由于对redis还没有一个整体的认识, 所以在阅读过程中可能存在一些错误的认识, 欢迎大家指正. Redis 学习资源 Redis 官网 Redis 中文官方网站 Github 上 Redis 源码 线上 Redis 示范环境 Redis 使用教程 如何阅读 Redis 源码? Redis 设计与实现 Redis 3.0中文注释源码 Redis 2.8源码解析 Reids 2.8中文注释源码]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC内联汇编]]></title>
    <url>%2Fgcc_inline_assembly.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;GCC内联汇编(inline assembly): 在 C 语言环境中使用汇编代码, 使得 C 和汇编混合在一起使用, 可以直接在 C 语言中插入汇编指令. 这是 GCC 对 C 语言的扩展. 为什么要在 C 语言中插入汇编代码? C 语言不足以完成所有 CPU 的指令, 特别是一些特权指令, 没有对应的C语言代码(如加载GDT) 用汇编在 C 语言中手动优化 代码格式12345asm ( assembler template : output operands (optional) : input operands (optional) : list of clobbered registers (optional) ); 关键字&emsp;&emsp;volatile: 可选的, 如果用了它, 则是向 GCC 声明不允许对该内联汇编优化, 否则当使用了优化选项(-O) 进行编译时, GCC 将会根据自己的判断决定是否将这个内联汇编表达式中的指令优化掉. 参数含义 %0: 代表第一个使用的寄存器 r: 代表任意寄存器 a: %eax b: %ebx c: %ecx d: %edx S: %esi D: %edi 参考资料 Inline assembly for x86 in Linux 汇编语言—GCC内联汇编]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 带有默认值的函数]]></title>
    <url>%2Fcplusplus_default_values_for_function_arguments.html</url>
    <content type="text"><![CDATA[实验环境: Windows10 + Microsoft Visual Studio 2013 &emsp;&emsp;对于带有默认值的函数来说, 看似很简单, 却有一些容易忽略的地方, 当然在平时我们几百年可能都遇不上一次, 但是对于笔试、面试来说却有比较大的机率被撞上, 所以接下来就来谈一谈. 省略参数不影响实参入栈次数&emsp;&emsp;对于这一点, 我相信许多人都会忽略, 因为要查看实参入栈次数就要通过汇编代价去查看, 而没有多少人会闲的没事去看汇编代码…… 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int sum(int a, int b = 10)&#123; return a + b;&#125;int main()&#123; int a = 20; int b = 10; sum(a, b); sum(a); return 0;&#125; &emsp;&emsp;上面是一段调用有默认值函数的代码, 第一次调用 sum 函数时(第 13 行), 实参齐全, 未使用默认值; 第二次调用 sum 函数时(第 16 行), 缺少一个实参, 使用默认值. 下面让我们来看看两次调用时他们的汇编代码:1234567sum(a, b);//第一次调用, 实参齐全, 未使用默认值// mov eax,dword ptr [b] // push eax b入栈// mov ecx,dword ptr [a] // push ecx a入栈// call sum (011B10D7h) // add esp,8 123456sum(a);//第二次调用, 缺少一个实参, 使用默认值// push 0Ah 默认值10入栈// mov eax,dword ptr [a] // push eax a入栈// call sum (011B10D7h) // add esp,8 &emsp;&emsp;在汇编代码中, 我们能够很清楚的看到两次调用虽然实参数量不同, 但是汇编代码中实参入栈(push)次数是相同的, 只不过有实参时入栈的是实参, 没有实参时是使用默认值进行入栈. 所以当省略参数不影响实参入栈次数. 形参默认值在声明和定义时都可以设定&emsp;&emsp;还是使用上面的代码, 在设定默认值时,可以直接在定义处给值. 如:1234int sum(int a, int b = 10)&#123; return a + b;&#125; 也可以在声明处给值, 如:1int sum(int a, int b = 10); 但是必须在第一次使用默认值之前设定默认值. 否则会出错, 如:123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int sum(int a, int b);int main()&#123; int a = 20; int b = 10; sum(a, b); sum(a); //Error return 0;&#125;int sum(int a, int b = 10)&#123; return a + b;&#125; 在第 13 行会报错: “sum“: 函数不接受 1 个参数. 形参默认值具有唯一性&emsp;&emsp;对于一个声明而言, 其不占内存, 不用编译, 不具有唯一性, 如:12int sum(int a, int b);int sum(int a, int b); 也是正确的, 但是如果加上默认值时, 则具有唯一性, 如:12int sum(int a, int b = 10);int sum(int a, int b = 10); 就会报错: “sum“: 重定义默认参数: 参数 2. 当然默认值的唯一性不仅仅指在声明中, 声明、定义中默认值应该都是唯一的。 默认值只能从右往左设定默认值&emsp;&emsp;使用默认值时, 如果我们是从左往右设定默认值的, 如:int sum(int a = 10, int b);那么在使用默认值时, 则需要sum(, 20);但是 C++ 语法不支持逗号前没有参数, 所以要使用默认值就要从右往左设定默认值. &emsp;&emsp;这一规则也可以继续延伸, 我们还可以这样设定默认值:12int sum(int a, int b = 20);int sum(int a = 10, int b); 从上往下执行代码, 就是先为 b 设置默认值, 再为 a 设置默认值, 符合默认值就要从右往左设定默认值.&emsp;&emsp;在 Windows10 + Microsoft Visual Studio 2013 的环境中, 对于这一形式的代码会报 “IntelliSense: 默认实参不在形参列表的结尾” 的错误, 但是不会影响运行 如果是12int sum(int a = 10, int b);int sum(int a, int b = 20); 则会因为设定默认值不是从右往左而报错.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C&amp;C++</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 内联函数 inline]]></title>
    <url>%2Fcplusplus_inline.html</url>
    <content type="text"><![CDATA[inline 函数编译规则&emsp;&emsp;inline 函数在编译时, 使用的编译方式是将所有调用 inline 函数的地方使用函数代码进行替换, 而没有使用函数调用, 所以说 inline 函数是一个更安全的宏, 说更安全是因为inline 函数在编译阶段进行处理, 编译阶段会有类型检查, 而宏是在预编译阶段进行处理, 容易出错.&emsp;&emsp;在调试时查看汇编代码可以发现系统底层在处理 inline 函数采用的方式与普通函数是相同的, 并不是进行代码替换, 而是参数入栈进入inline 函数. 这是因为 inline 函数只会在 Release 版本中进行代码替换, 而在 Debug 版本中, 是以普通函数的处理方式进行处理. inline 函数限制什么函数不可以成为 inline 函数?&emsp;&emsp;在使用 inline 函数时应注意递归函数和过程复杂的函数不能成为 inline 函数因为递归函数递归的次数由传入参数决定, 如果进行代码替换则不知道要嵌套替换多少次; 过程复杂的函数在代码替换时, 也会存在困难.&emsp;&emsp;总体来说, inline 函数只是程序员对于编译器的建议, 而真正的决定权在编译器手中. inline 函数跨文件调用&emsp;&emsp;对于 inline 函数, 在跨文件调用时会发现, 其无法调用, 当一个函数无法跨文件调用时会有两种情况: 函数名未生成符号 函数名生成 local 符号 inline 函数到底是哪一种, 我们可以试一试. 实验一:123456789int sum1(int a, int b)&#123; return a + b;&#125;int sum2(int a, int b)&#123; return a + b;&#125; &emsp;&emsp;在 Linux 下编译, 使用 objdump 命令查看生成的符号, 如图:可以看出这段代码一共生成两个 global 符号, 分别为 _Z4sum1ii 和 _Z4sum2ii, 通过 c++filt 转化可知他们分别为函数 sum1 和 sum2 的符号. 实验二:123456789inline int sum1(int a, int b)&#123; return a + b;&#125;int sum2(int a, int b)&#123; return a + b;&#125; &emsp;&emsp;在 Linux 下编译, 生成符号为:可以看到符号 _Z4sum1ii 已经消失, 说明函数 sum1 在成为 inline 函数后未生成符号. &emsp;&emsp;所以inline 函数不生成符号, 不能外部引用.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C&amp;C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现伙伴系统]]></title>
    <url>%2Ffriend_system.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;伙伴系统(buddy system) 是操作系统中用到的一种动态内存存储管理的方法. 它和边界标识法相类似, 在用户提出申请时, 分配给用户一块大小“恰当”的内存区给用户; 反之, 在用户释放内存区时即可收回. 对于伙伴系统而言, 所有分配的内存块大小都是分为几种“规格”的, 即每个分配出去的内存块大小都为2的k次幂, 如当内存池大小为 $2^m$ 次幂时, 内存块的大小种类有 $2^0$, $2^1$, … , $2^k$, … , $2^m$, 当用户申请内存大小n为 $2^{k-1} &lt; n &lt;= 2^k$ 时, 将为用户分配内存大小为 $2^k$ 的内存块. 结构设计整体设计&emsp;&emsp;对于伙伴系统而言, 有大小固定且相同的内存块, 将大小相同的内存块链接在一起时, 为了达到写平衡, 使用双向链表实现, 这样可以在回收回的内存块时, 将其插入双向链表的链尾, 在申请内存块时, 从链头删除内存块; 而将链接不同大小内存块的双向链表链接起来时, 因为内存块大小种类固定所以使用顺序表实现, 故使用顺序表加双向链表的形式实现伙伴系统. 双向链表设计思路及定义&emsp;&emsp;细化而言, 对于内存块, 因为是在双向链表中, 所以每个内存块中需要一个 header, 其中包含的信息有前驱 llink, 后继 rlink; 同时还需要一个标记内存块是否被占用的信息 tag, tag = 0 则内存块空闲, tag = 1 则内存块占用; 需要一个标记内存块大小的信息 kval, 内存块大小为 $2^k$. &emsp;&emsp;所以我们在实现内存池时, 以一个 header 的大小 16 个字节为单位进行内存管理, 每个单位称之为 WORD. 1234567typedef struct WORD&#123; struct WORD *llink; int tag; int k; struct WORD *rlink;&#125;WORD, *Space; 顺序表设计思路及定义&emsp;&emsp;对于顺序表, 则需要一个记录内存块大小的信息 nodesize; 一个记录链接与 nodesize 大小相同的内存块的双向链表的结点信息 first. 12345typedef struct HNode&#123; int size; WORD *next;&#125;HNode, *PHNode; 实现动态内存管理内存初始化 &emsp;&emsp;通过初始化实现如上图第一部分所示的内存池. 同时在这里需要建立一个内存池头结点, 全局变量 HEAD 记录内存池首地址, 作用下文会有详细说明. 123456789101112131415161718192021222324void InitMemory(PHNode *ppav) /*初始化:创建一个需要进行内存管理的内存池*/&#123; WORD word[SIZE]; HNode head[K]; HEAD = word;//保存内存池首地址 word[0].llink = word;//初始化内存池 word[0].tag = 0; word[0].k = K - 1; word[0].rlink = word; *ppav = head;//将顺序表链接到头指针 int i; int size = 1; for(i = 0; i &lt; K; i++, size *= 2)//初始化顺序表 &#123; head[i].size = size; head[i].next = NULL; &#125; head[K - 1].next = word;//将内存池链接到顺序表&#125; 动态内存申请123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687WORD *Mymalloc(PHNode ppav, int size) /*动态内存申请*/&#123; assert(ppav != NULL); if (ppav == NULL) &#123; return NULL; &#125; int i; //int j = -1; for (i = 0; i &lt; K; i++) &#123; //if (ppav[i].size &gt;= size &amp;&amp; j == -1) //&#123; // j = i; //&#125; if (ppav[i].next != NULL &amp;&amp; ppav[i].size &gt;= size)//判断是否有足够剩余空间 &#123; break; &#125; &#125; if (i == K)//剩余空间不足 &#123; return NULL; &#125; Space q; Space head = ppav[i].next; Space p = head; //有剩余空间 if (head-&gt;llink == head)//该双向链表中只有一个节点 &#123; //head = NULL; Error: 无法改变ppav[i].next的值, 只改变head的值, 函数运行完成后销毁, 无用 ppav[i].next = NULL; &#125; else//该双向链表不只有一个节点 &#123; ppav[i].next = head-&gt;rlink; head-&gt;llink-&gt;rlink = head-&gt;rlink; head-&gt;rlink-&gt;llink = head-&gt;llink; &#125; /*方法一: 从左向右由小到大切割内存块 q = p + ppav[j].size; p-&gt;llink = p; p-&gt;k = j; p-&gt;tag = 1; p-&gt;rlink = p; while (j &lt; i) &#123; q-&gt;llink = q; q-&gt;tag = 0; q-&gt;k = j; q-&gt;rlink = q; ppav[j].next = q; j++; q = q + ppav[j].size; &#125; */ /*方法二: 从右向左有大到小切割内存块*/ for(i--; ppav[i].size &gt;= size; i--)//大块内存块切割小块内存块 &#123; q = p + ppav[i].size; q-&gt;llink = q; q-&gt;tag = 0; q-&gt;k = i; q-&gt;rlink = q; ppav[i].next = q; &#125; p-&gt;llink = p; p-&gt;tag = 1; p-&gt;k = i + 1; p-&gt;rlink = p; return p;&#125; &emsp;&emsp;动态内存申请时要注意: 当双向链表值在顺序表中的头指针为 NULL 的情况 双向链表只有一个节点的情况 动态内存申请的难点在于处理大块内存块切割小块内存块的情况, 这时有两种方法: 从左向右由小到大切割内存块 从右向左由大到小切割内存块. 动态内存回收123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void Myfree(PHNode ppav, WORD *p) /*动态内存回收*/&#123; p-&gt;tag = 0; int i; int k = p-&gt;k; int size = powx(2, k); Space q; int flag; while(k &lt; K) &#123; if ((p - HEAD) % (size * 2) == 0)//判断左块, 右块 &#123; flag = 0;//左块 q = p + size; &#125; else &#123; flag = 1;//右块 q = p - size; &#125; if (q-&gt;tag == 0 &amp;&amp; flag == 1 &amp;&amp; q-&gt;k == p-&gt;k)//p为右块且有p的左块存在 &#123; if(q-&gt;rlink == q) &#123; ppav[k].next = NULL; &#125; else &#123; ppav[k].next = q-&gt;rlink;//易错: 若p的左块为ppav[k].next所指的空间块, 不写则在输出时会陷入死循环 q-&gt;llink-&gt;rlink = q-&gt;rlink; q-&gt;rlink-&gt;llink = q-&gt;llink; &#125; q-&gt;k++; p = q; k++; &#125; else if (q-&gt;tag == 0 &amp;&amp; flag == 0 &amp;&amp; q-&gt;k == p-&gt;k)//p位左块且有p的右块存在 &#123; if(q-&gt;rlink == q) &#123; ppav[k].next = NULL; &#125; else &#123; ppav[k].next = q-&gt;rlink;//易错: 若p的左块为ppav[k].next所指的空间块, 不写则在输出时会陷入死循环 q-&gt;llink-&gt;rlink = q-&gt;rlink; q-&gt;rlink-&gt;llink = q-&gt;llink; &#125; p-&gt;k++; k++; &#125; else//p没有伙伴块 &#123; break; &#125; size *= 2; &#125; if(ppav[p-&gt;k].next == NULL) &#123; p-&gt;llink = p; p-&gt;rlink = p; ppav[p-&gt;k].next = p; &#125; else &#123; q = ppav[k].next; q-&gt;llink-&gt;rlink = p;//将p插入内存池 p-&gt;llink = q-&gt;llink; q-&gt;llink = p; p-&gt;rlink = q; &#125;&#125; &emsp;&emsp;在动态内存回收中需要注意: 在判断回收的内存块的伙伴是否空闲时应使用 q-&gt;tag == 0 &amp;&amp; flag == 0 &amp;&amp; q-&gt;k == p-&gt;k 进行判断, 缺一不可 代码第33, 50行不可缺少 当双向链表值在顺序表中的头指针为 NULL 的情况 双向链表只有一个节点的情况 &emsp;&emsp;动态内存回收的难点在于内存回收时对于伙伴块的合并, 应使用循环, 当回收的内存块有伙伴时, 与伙伴合并成为新的内存块, 新的内存块再次查看是否有伙伴, 直至新的内存块没有伙伴, 将其插入和其大小的匹配的双向链表中, 正如整体设计中所说, 这时双向链表的价值就体现出来, 为了写平衡, 双向链表可轻易将新内存块插入双向链表的链表尾. &emsp;&emsp;在这其中伙伴是一个很重要的概念, 何为“伙伴”? 将一个大块内存切割成为两个大小相同的小块内存, 两个小块内存互为伙伴. &emsp;&emsp;在寻找回收的内存块的伙伴时, 首先需要知道回收的内存块是左块还是右块, $p MOD 2^{k + 1} = 0$ 则为左块, 否则为右块.这里的 p 指回收的内存块相对于内存池首地址的相对地址, 这时在内存初始化中的 HEAD 变量的作用就体现出来.]]></content>
      <categories>
        <category>项目程序</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RHEL7.0或CentOS7.0与WIN8.1双系统时WIN8.1无法启动]]></title>
    <url>%2Fdual_system_cannot_start.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天舍友在 WIN8.1 的基础上安装 Ubuntu14.04 双系统, 于是我心血来潮在 WIN8.1 的基础上想安装一个 RHEL7.0 的双系统, 一切都很顺利, 但是重启后竟然没有 WIN8.1 的开机启动项… &emsp;&emsp;经过一番查找了解到这是由于新的 grub2 引起的问题, 在此分享一下. &emsp;&emsp;在这里需要先安装一个软件包. &emsp;&emsp;具体操作如下： 12345678#unzip ntfs-3g_ntfsprogs-2011.4.12.zip //这是解压.zip文件，非.zip文件此步略过#tar zxvf ntfs-3g_ntfsprogs-2011.4.12.tgz //解压.tgz文件#./configure//若提示 configure:error:no acceptable C compiler found in $PATH//则运行 yum -y install gcc//若提示权限不够可用 chmod 命令为 configure 文件添加可执行权限#make#make install &emsp;&emsp;安装成功后, 对整个硬盘进行全盘扫描, 自动添加未添加的启动引导: 1grub2-mkconfig -o /boot/grub2/grub.cfg]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brute Force 查找算法]]></title>
    <url>%2FBrute_Force.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在对于字符串或者可以说是对于串的查找上, 有两种比较常用的匹配算法. 第一种为 BF 算法, 第二种为 KMP 算法. 由于 KMP 算法较为复杂, 今天就先来说说 BF 算法, 下次花一整次讲讲KMP. &emsp;&emsp;第一次听说 BF 算法, 是被人称作男朋友算法… BF 算法, 即 Brute Force 算法, 是一种暴力查找算法, 至于其他想了解的可以自行百度. 算法思想&emsp;&emsp;从上文中所说的暴力算法我们就可以了解到 BF 算法是将所有目标字符串中的子串与需查找的字符串进行比较, 成功则返回该子串在目标字符串中的位置, 失败则继续比较直至成功或所有子串全部比较, 如果都失败, 则返回一个不可能出现的值. &emsp;&emsp;在实现时有一个难点: 如何获得全部子串. 其实事实是并不用获取全部子串, 只需要遍历整个目标字符串, 分别让以目标字符串中的每个字符为开始位置的子串与需查找字符串对比, 一旦对比失败, 立即放弃所有以此字符开头的字符串, 重新在目标字符串中以下一字符为开始的所有子串中查找需查找字符串. 如果对比需查找字符串成功, 直接返回该字符位置在目标字符串中的位置. 在这里对比失败后需要定位目标字符串中下一字符的位置, 这里使用双层循环跳出第二次循环的方法, 也可以只用一层循环, 使用当前目标字符串位置减去需查找字符串位置再加 1. &emsp;&emsp;如图所示, 目标字符串为 caatcat, 需查找字符串为 cat. 先对比以目标字符串第一个字符 c 为开始位置的子串, 对比失败, 再对比以目标字符串第二个字符 a 为开始位置的子串, 以此类推, 直到对比以目标字符串第五个字符 c 为开始位置的子串, 对比成功, 返回 c 在目标字符串中的位置 5. 代码实现&emsp;&emsp;注意: 算法描述中的字符串的初始位置为 1, 算法实现时字符串的初始位置为 0. 1234567891011121314151617181920212223242526272829303132333435363738int BF(const char *str, const char *sub, int pos)//str: 目标字符串 sub: 需查找字符串 pos: 开始查找位置&#123; assert(str != NULL &amp;&amp; sub != NULL);//判断参数是否正确 if (str == NULL || sub == NULL) &#123; return -1; &#125; if (pos &lt; 0) &#123; return -1; &#125; int i = pos; int j = 0; while (str[i] != '\0' &amp;&amp; sub[j] != '\0')//遍历整个目标字符串 &#123; if (str[i] == sub[j])//进行对比, 对比成功 &#123; i++; j++; &#125; else//对比失败 &#123; i = i - j + 1;//将对比的子串开始位置变为下一个字符 j = 0;//回到需查找字符串开始位置 &#125; &#125; if (sub[j] != '\0')//查找失败 &#123; return -1; &#125; else//查找成功 &#123; return i - j; &#125;&#125; &emsp;&emsp;我在这里定位目标字符串中下一字符的位置是使用当前目标字符串位置减去需查找字符串位置再加 1.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 忘记 root 密码]]></title>
    <url>%2FLinux_forget_root_password.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;安装 Linux 的虚拟机很久了, 之前不太会用, 也比较忙, 一段时间没有学习它, 因此一直没打开虚拟机, 结果我很悲催的把 root 密码给忘了, 伤心欲绝, 但是不知道怎么弄, 一直听说 Linux 的安全性很霸气, 以为不能修改了, 于是乎重新安了一遍… &emsp;&emsp;结果前几天在学校学 Linux, 学会了在启动界面不需要原密码就修改 root 密码的方法, 上来显摆显摆. &emsp;&emsp;第一步: 在开机进入系统倒计时时按下任意键进入 gurb 引导界面. &emsp;&emsp;第二步: 选定 RedHat 这一长串, 按 e(edit). &emsp;&emsp;第三步: 上下键选定 kernel 这一长串. &emsp;&emsp;第四步: 这时进入了编辑模式, 输入 single(以空格开头). &emsp;&emsp;第五步: 按 Enter 保存并退出编辑模式回到第三步, 这时按下 b 进入单用户模式 &emsp;&emsp;第六步: 使用 passwd -d root 命令, 删除原 root 用户密码. &emsp;&emsp;第七步: 使用 passwd 命令, 重新设置 root 用户密码. &emsp;&emsp;第八步: 使用 shutdown -r now, reboot 或 init6 三条命令中任意一个重新引导系统. &emsp;&emsp;root 用户密码可以随意更改, Linux 操作系统是否安全? 了解了一下, 因为物理机面前, 是没有安全保证, 而这种模式应该不能进行远程操作, 要解决这个问题, 可以给 grub 和主板设密码. 注: 第三步可以输入 1, 只是出现的界面不同, 操作方式与命令都相同.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 软件安装]]></title>
    <url>%2FLinux_software_installation.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux 有很多发行版本, 许多发行版本都有着自己的软件安装方法, 我现在在学习 RedHat 系统, 对于 RedHat 有两种软件安装的方法. rpm(Redhat package manage)&emsp;&emsp;rpm 称为红帽软件包管理器, 可以安装软件, 也可以卸载. 虽然打上了 RedHat 的标志, 但是很多 Linux 发行版本都在使用, 所以说一下是很有必要地, 在其安装与卸载常用的参数有: -i, -U, -F, -e, -vh, -qhl, -qhi. rpm -i: 在未安装旧版本的情况下安装该软件包 rpm -U: 在未安装旧版本时安装软件, 在有旧版本时更新软件包 rpm -F: 更新旧有软件包 rpm -e: 卸载软件包 rpm -vh: 显示安装进度 rpm -qhl: 列出 rpm 软件包内的文件信息 rpm -qhi: 列出 rpm 软件包的描述信息 &emsp;&emsp;但是使用 rpm 方法安装时存在出现依赖性错误(Failed dependencies) 的可能, 也就是说在安装这个软件包是需要安装有当前软件包所依赖的软件包, 这样的好处就是便于开发者开发软件, 可以以其他软件为基础进行开发, 不用重头开始开发. 但是对于用户来说并不是一件好事, 当然如果你不介意一个软件包一个软件包的 rpm, 那也就没什么大不了了. yum(Yellow dog Updater Modified)&emsp;&emsp;相比于 rpm 需要对依赖包一个一个安装, yum 则是一种更加便捷的安装方式, 它能够自动处理依赖关系, 安装依赖包. &emsp;&emsp;yum 基于 rpm, 能从本地直接安装 rpm 包, 也能从指定服务器下载并安装 rpm 包, 其关键之处在于可靠地 repository, 它可以是 http 或 ftp 站点, 也可以是本地软件池, 重要的是必须包含 rpm 的 header, header 中包括了 rpm 的各种信息, 其中最主要的是包括依赖性的文件, 正是收集了 header 中的内容, 才可以自动处理依赖性关系, 并且一次安装所有依赖的软件包, 无须繁琐地一次次下载, 安装. &emsp;&emsp;yum 好处多多, 大家一看就知道, 但是要真正应用还有一道难关, 就是必须先配置 yum, 这里需要 vim 的基础. &emsp;&emsp;yum 的软件库的配置文件的地址是: /etc/yum.repos.d 配置文件: 123456[basename] # 软件库名称name= # 后接软件库全名baseurl= # 软件库地址enabled= # 0代表禁用，1代表启用 当然是启用gpgcheck= # 检查gpg签名，0代表不检查，1代表检查 不检查用时少,检查安全，安装时可自己权衡gpgkey= # 如果上一项为1，则需配置，否则不用写 &emsp;&emsp;配置完成就大功告成了, 当然, 命令的使用方法也是不可或缺.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统的基本结构]]></title>
    <url>%2FLinux_system_basic_structure.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;开始学习 Linux 不了解 Linux 的基本结构是不行的, 在这篇文章中将会介绍一下 Linux 的基本结构. &emsp;&emsp;首先开始不用细说, 无论什么操作系统它的最底层结构一定是硬件: CPU, PCT, IDF 等等, 即使不了解操作系统的人也能说上一大堆. &emsp;&emsp;下来底层空间就是 kernel 了, 作为内核牛逼是不用说的, 简单介绍一下, 在 linux 中 kernel 版本号有奇偶之分. 奇数是是实验版本, 其中拥有 kernel 最新的一些东西, 但是稳定性不确定; 偶数是稳定版本, 在偶数中也区分 2.4 和 2.6, 都是稳定版, 因为还有许多公司都在用 2.4 的所以一直在维护. kernel 直接通过机器语言与 CPU 沟通. 当然这一层不止 kernel 一个, 还有像 BIOS, modules 等. &emsp;&emsp;第三层就是一些 API(应用程序接口)还有一些 Lib 库等. &emsp;&emsp;最后就是大家最熟悉的 APP 了, 其中 shell 就是一种应用程序. &emsp;&emsp;还有一个要单独说说, 就是图形界面. 大家有可能会发现在 windows 中有时打开一个窗口会比 Linux 快. 这是因为在 windows 中图形界面是写在操作系统中, 而在 Linux 中图形界面是一个应用程序, 在windows 中当然会快.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 获取帮助]]></title>
    <url>%2FLinux_getting_help.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux 下的指令有太多太多, 我们不可能将所有的指令的用法都背下来记牢, 因此我们需要一些求助工具和说明文件, 这里以 RedHat 为例进行演示. whatis&emsp;&emsp;查询的指令实现简短的说明. &lt;command&gt; --help&emsp;&emsp;显示所查询指令的使用摘要以及参数列表, 蓝笔所画为使用摘要, 红笔所画为参数列表. 大部分指令可以使用 --help 参数, 但并不是所有, 有少部分指令不能使用. man&emsp;&emsp;man 可以提供一些指令的说明文件, 在 redhat 里的每个指令都有相应的说明文件, 叫做 man page, man page 有像书一样的章节架构, 所有搜集来的 man page 叫做 Linux 操作手册. &emsp;&emsp;man 中一共有九个章节: User commands: 一般使用者使用的说明 System calls: 系统调用 Library calls: 库函数 Gpecial files: 特殊文件 File formats: 查询指令的档案格式说明 Games: 游戏 miscellaneous: 宏, 环境字符集等 Adminstrative commonds: 只有 root 账户才能使用的指令说明 kernel routines: 涉及kernel的一些东西 &emsp;&emsp;其中 1, 5, 8 这三个比较重要, 离开 man page 输入 q. 使用 man -k &lt;command&gt; 可以查询包含 command 关键字的内容. info&emsp;&emsp;提供更详细的指令说明, 使用章节一样的结构, 其中有一些节点, 可以连接其他章节. 进入 info 页面后按下 s 可以进入交互式查询, 离开按 q. /usr/share/doc/&emsp;&emsp;可以查询一些额外的说明文件. Red Hat documentation&emsp;&emsp;在网络上的说明文件: Red Hat documentation Reading usage summaries&emsp;&emsp;在 --help 和 man 中都有使用摘要, 对比前后两张图就会发现它们中的使用摘要都是相同的. Usage Summary 使用语法: 如果参数外面被 [ ] 括起来, 代表可有可无(optional) 如果参数外面被 &lt;&gt; 括起来, 代表参数是可变的 如果参数为 x|y|z, 代表只能使用 x, y, z 三者中的一个 如果参数为 -abc, 代表可以使用 a, y, z 三者中的任何值, 可以是一个, 两个, 三个]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伯努利-欧拉装错信封问题]]></title>
    <url>%2FDerangement.html</url>
    <content type="text"><![CDATA[题目: &emsp;&emsp;马小虎在人人网上结交一批女网友, 在情人节那天, 马小虎玩起了浪漫, 同时给 n 个女网友每人写了一封各有特色的信, 要命的是, 激动的他竟然把所有的信都装错了信封!&emsp;&emsp;编写一个程序, 计算将所有的信都装错信封, 共有多少种不同情况? 例如, 3 封信全装错信封的种数为 2, 即 231 和 312. 输入包含若干组数据. 每组数据是一个整数 N(1 &lt;= N &lt;= 30), 表示马小虎写信的封数. N = 0 时输入结束. 输出对于每组数据, 在单独的一行输出一个整数(所有的信都装错信封的种数) &emsp;&emsp;例如: 输入: 3 输出: 2 &emsp;&emsp;伯努利-欧拉装错信封问题数学表达式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt; #define N 100//套用递归计算double digui(double);int jiecheng(int); int main()&#123; int n[N], i; printf("请输入信件数量( &gt; 0, 输入0结束)：\n"); scanf("%d", &amp;n[0]); for(i = 0; n[i] != 0; i ++) &#123; n[i] = jiecheng(n[i]) * (1 + digui((double)n[i])); scanf("%d", &amp;n[i + 1]); &#125; printf("完全装错信件的种数：\n"); for(i = 0; n[i] != 0; i ++) &#123; printf("%d\n", n[i]); &#125; return 0;&#125; double digui(double n)&#123; double x; if(n &gt; 0) &#123; x = digui(n - 1); //y = jiecheng(n); //z = pow(-1, n); n = x + pow(-1, n) / jiecheng(n); &#125; return n;&#125; int jiecheng(int n)&#123; if(n &gt; 1) &#123; n = n * jiecheng(n - 1); &#125; return n;&#125; &emsp;&emsp;输出结果:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scanf() 语句错误读取]]></title>
    <url>%2Fscanf_read_error.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一星期的文章中, 每一次遇到功能选择时, 总是会以输入选项所代表的数字表示. 而在让一个大神帮忙看看时, 发现一个问题: 当输入不是数字时 scanf() 语句将保持不读取状态, 当程序运行到这里时 scanf() 将会维持上一次读取数, 不读取新内容, 检查了好久都不知道问题, 当时大神发话, 这绝对是scanf()读取出问题了, 应当有一个函数可以清空缓存还是什么的, 用于解决这个问题, 结果回来一查, 立即对大神佩服的五体投地. &emsp;&emsp;以这个程序为例: 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt; int main()&#123; int array[10]; int temp; int i,j; printf("input ten numbers(between -32768 and +32767):\n"); for(i=0;i&lt;10;i++) &#123; scanf("%d",&amp;temp); if(temp&lt;-32768 || temp&gt;32767) &#123; i--; printf("number must between -32768 and +32767\ntry again:\n"); continue; &#125; else &#123; array[i]=temp; &#125; &#125; printf("your numbers:\n"); for(j=0;j&lt;10;j++) &#123; printf(" %d ",array[j]); &#125; printf("\ngod bye\n"); return 0;&#125; &emsp;&emsp;如果在开始输入时输入一个字母将进入死循环: 输入: q 输出: &emsp;&emsp;如果在输入中输入一个字母 scanf() 将会自动读取上一次输入的值, 不能再次输入: 输入: 1 2 3 4 q 5 6 7 8 9 输出: 1 2 3 4 4 4 4 4 4 4 或 输入: 1 2 3 4 q 输出: 1 2 3 4 4 4 4 4 4 4 &emsp;&emsp;要解决这个问题需要在循环中添加一个清空缓存的语句: 1fflush(stdin); &emsp;&emsp;但这样 scanf() 每次只能读取一个数, 因此需要用 enter 来间隔: 输入: 1 2 3 4 q 5 6 7 8 9 输出: 1 2 3 4 5 6 7 8 9 (因为再输入 q 时, scanf() 未读取 q, 但 i 仍加 1, 因此只输入 9 个数就完成程序)]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C&amp;C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教学管理系统]]></title>
    <url>%2Fteaching_management_system.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是这几天写的一个教学管理系统, 功能不是很齐全, 而且还有一些小问题, 包括没加文件是否存在的判断, 交互性不好, 容错性不好等, 在第 152 行我想尝试一下如同电脑中输入密码时有圆点或星号覆盖输入密码的情形, 但是失败了, 请各位大神帮忙看看. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638/*题目：某学院教学信息管理系统功能：1、每一条记录包括一位教师的职工号、姓名、职称、性别、3门主讲课程（课程名称、开课学期、课程性质（学位与非学位课）和教学效果），教学效果综合评分。2、输入功能：可以一次完成若干条记录的输入。3、显示功能：完成全部教师记录的显示。4、查找功能：完成按姓名或课程查找教师的相关记录，并显示。5、排序功能：按职工号或教学效果综合评分进行排序。6、插入功能：按教学效果综合评分高低插入一条教师记录。7、将教师记录存在文件中。8、应提供一个界面来调用各个功能,调用界面和各个功能的操作界面应尽可能清晰美观!*/ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#include &lt;string.h&gt; #define N 300 int ma(int a);int shuru(void);int xianshi(void);int chaxun(void);int paixu(void);int charu(void); struct mima&#123; char name[10]; char key[20];&#125;mi[N]; struct Ke&#123; char name[20]; int time; char xingzhi[10]; int xiaoguo;&#125;;//建立关于老师信息的结构体struct teacher&#123; int num; char name[20]; char zhicheng[10]; char xingbie[10]; struct Ke q[3]; int pingfen; char jilu[50];&#125;in[N]; int main()&#123; int x = -1, a, b = 0; system("color f0"); system("mode con cols=200 lines=30"); while ((b != 1) &amp;&amp; (b != 2) &amp;&amp; (b != 2) &amp;&amp; (b != 3)) &#123; printf("\n\n\n\n\n"); printf(" 学院教学信息管理系统\n\n"); printf(" 登陆-----------------------1\n"); printf(" 申请新账号-----------------2\n"); printf(" 退出-----------------------0\n"); printf(" 请输入操作类型:"); scanf("%d", &amp;a); if((a == 1) || (a == 2)) &#123; system("cls"); b = ma(a); &#125; else if(a == 0) &#123; return 0; &#125; else &#123; printf("\n\n 输入错误,请重新选择.\n\n\n"); &#125; system("cls"); &#125; while (x != 0) &#123; printf("=========================================================================================\n\n"); printf("教学信息输入------------------------------------------------------------1\n"); printf("教学信息显示------------------------------------------------------------2\n"); printf("教学信息查询------------------------------------------------------------3\n"); printf("教师信息排序------------------------------------------------------------4\n"); printf("教学信息插入------------------------------------------------------------5\n"); printf("结束--------------------------------------------------------------------0\n\n"); printf("==========================================================================================\n\n\n\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); if(x != 0) &#123; system("cls"); &#125; switch (x) &#123; case 0: return 0; break; case 1: &#123; if(b == 3) &#123; shuru(); &#125; else &#123; printf("权限未达到，请重新输入.\n"); getchar(); getchar(); &#125; &#125; break; case 2: xianshi(); break; case 3: chaxun(); break; case 4: paixu(); break; case 5: charu(); break; default: printf("输入错误,请重新选择.\n\n\n"); &#125; system("cls"); &#125; return 0;&#125; int ma(int a)&#123; int d, c = 1, i; char k[20], n[10], nk[20]; FILE *fp, *fq; char ch; if(a == 1) &#123; printf(" 用户名："); scanf("%s", n); printf(" 密码："); /*for(i = 0; k[i] != '\n'; i ++) &#123; ch = getc(stdin); strcpy( k+i , &amp;ch ); putc(('*'), stdout); &#125;*/ scanf("%s", k); fq = fopen("D:\\work\\CODE\\key.txt", "r"); fp = fopen("D:\\work\\CODE\\d.txt", "r"); fscanf(fp, "%d", &amp;d); fclose(fp); for(i = 0; i &lt; d; i ++) &#123; fscanf(fq, "%s%s", mi[i].name, mi[i].key); &#125; for(i = 0; i &lt; d; i ++) &#123; if(strcmp(mi[i].name, n) == 0) &#123; if(strcmp(mi[i].key, k) == 0) &#123; if(strcmp(mi[i].name, "root") == 0) &#123; a = 3; return a; &#125; else &#123; return a; &#125; &#125; &#125; &#125; a = 4; return a; &#125; else &#123; while(c != 0) &#123; printf("\n 用户名："); scanf("%s", n); printf(" 密码："); scanf("%s", k); printf(" 重新输入密码："); scanf("%s", nk); if(strcmp(k, nk)) &#123; system("cls"); printf("输入错误，请重新输入.\n"); &#125; else &#123; fq = fopen("D:\\work\\CODE\\key.txt", "a+"); fp = fopen("D:\\work\\CODE\\d.txt", "r"); fscanf(fp, "%d", &amp;d); fclose(fp); fprintf(fq, "%s %s %c", n, k, '\n'); d = d + 1; fp = fopen("D:\\work\\CODE\\d.txt", "w"); fprintf(fp, "%d", d); fclose(fp); fclose(fq); return a; &#125; &#125; &#125; return 0;&#125; int shuru(void)&#123; int i, j, x = -1, a, s; FILE *fq, *fp; while(x != 0) &#123; printf("输入全新内容-----------------------1\n"); printf("添加-------------------------------2\n"); printf("返回上一级-------------------------0\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); if(x == 1) &#123; fq = fopen("D:\\work\\CODE\\information.txt", "w+"); fp = fopen("D:\\work\\CODE\\s.txt", "w+"); &#125; else if(x == 2) &#123; fq = fopen("D:\\work\\CODE\\information.txt", "a+"); fp = fopen("D:\\work\\CODE\\s.txt", "r"); fscanf(fp, "%d", &amp;s); fclose(fp); &#125; else &#123; return 0; &#125; printf("输入信息组数为:"); scanf("%d", &amp;a); printf("请输入教学信息(依次为：职工号、姓名、职称、性别、3门主讲课程（课程名称、开课学期、课程性质（学位与非学位课）和教学效果分别写出），教学效果综合评分):\n"); for(i = 0; i &lt; a; i++) &#123; scanf("%d%s%s%s", &amp;in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie); for(j = 0; j &lt; 3; j ++) &#123; scanf("%s%d%s%d", in[i].q[j].name, &amp;in[i].q[j].time, in[i].q[j].xingzhi, &amp;in[i].q[j].xiaoguo); &#125; scanf("%d", &amp;in[i].pingfen); &#125; getchar(); for(i = 0; i &lt; a; i++) &#123; fprintf(fq, "%d %s %s %s ", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie); for(j = 0; j &lt; 3; j ++) &#123; fprintf(fq, "%s %d %s %d ", in[i].q[j].name, in[i].q[j].time, in[i].q[j].xingzhi, in[i].q[j].xiaoguo); &#125; fprintf(fq, "%d %s %c", in[i].pingfen, "未输入", '\n'); &#125; fclose(fq); if(x == 1) &#123; fprintf(fp, "%d", a); fclose(fp); &#125; else if(x == 2) &#123; fp = fopen("D:\\work\\CODE\\s.txt", "w+"); s = a + s; fprintf(fp, "%d", s); fclose(fp); &#125; printf("\n\n\n"); &#125; return 0;&#125; int xianshi(void)&#123; int x = -1, s, i; FILE *fq, *fp; while(x != 0) &#123; printf("显示全部内容------------------------------------------------------------1\n"); printf("返回上一级--------------------------------------------------------------0\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); if(x == 1) &#123; fq = fopen("D:\\work\\CODE\\information.txt", "r"); fp = fopen("D:\\work\\CODE\\s.txt", "r"); fscanf(fp, "%d", &amp;s); if(x == 0) &#123; return 0; &#125; for(i = 0; i &lt; s; i++) &#123; fscanf(fq, "%d%s%s%s%s%d%s%d%s%d%s%d%s%d%s%d%d%s", &amp;in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, &amp;in[i].q[0].time, in[i].q[0].xingzhi, &amp;in[i].q[0].xiaoguo, in[i].q[1].name, &amp;in[i].q[1].time, in[i].q[1].xingzhi, &amp;in[i].q[1].xiaoguo, in[i].q[2].name, &amp;in[i].q[2].time, in[i].q[2].xingzhi, &amp;in[i].q[2].xiaoguo, &amp;in[i].pingfen, in[i].jilu); /*for(j = 0; j &lt; 3; j ++) &#123; fscanf(fq, "%s%d%s%d", in[i].q[j].name, &amp;in[i].q[j].time, in[i].q[j].xingzhi, &amp;in[i].q[j].xiaoguo); &#125; fscanf(fq, "%d", &amp;in[i].pingfen);*/ &#125; printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); /*for(j = 0; j &lt; 3; j ++) &#123; fscanf(fq, "%s%d%s%d", in[i].q[j].name, &amp;in[i].q[j].time, in[i].q[j].xingzhi, &amp;in[i].q[j].xiaoguo); &#125; fscanf(fq, "%d", &amp;in[i].pingfen);*/ &#125; getchar(); getchar(); printf("\n\n\n"); &#125; else if(x == 0) &#123; return 0; &#125; else &#123; printf("输入错误,请重新选择.\n\n\n"); &#125; &#125; fclose(fq); fclose(fp); return 0;&#125; int chaxun(void)&#123; int x = -1, i, j, s; char c[20]; FILE *fq, *fp; while(x != 0) &#123; printf("按姓名查询--------------------------------------------------------------1\n"); printf("按课程查询--------------------------------------------------------------2\n"); printf("返回上一级--------------------------------------------------------------0\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); fq = fopen("D:\\work\\CODE\\information.txt", "r"); fp = fopen("D:\\work\\CODE\\s.txt", "r"); fscanf(fp, "%d", &amp;s); if(x == 0) &#123; return 0; &#125; for(i = 0; i &lt; s; i++) &#123; fscanf(fq, "%d%s%s%s%s%d%s%d%s%d%s%d%s%d%s%d%d%s", &amp;in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, &amp;in[i].q[0].time, in[i].q[0].xingzhi, &amp;in[i].q[0].xiaoguo, in[i].q[1].name, &amp;in[i].q[1].time, in[i].q[1].xingzhi, &amp;in[i].q[1].xiaoguo, in[i].q[2].name, &amp;in[i].q[2].time, in[i].q[2].xingzhi, &amp;in[i].q[2].xiaoguo, &amp;in[i].pingfen, in[i].jilu); &#125; if(x == 1) &#123; printf("请输入查询教师姓名:"); scanf("%s", c); printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; if(strcmp(in[i].name, c)) &#123; ; &#125; else &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); &#125; &#125; getchar(); getchar(); printf("\n\n\n"); &#125; else if(x == 2) &#123; printf("请输入查询课程名称:"); scanf("%s", c); printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; for(j = 0; j &lt; 3; j++) &#123; if(strcmp(in[i].q[j].name, c)) &#123; ; &#125; else &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); &#125; &#125; &#125; getchar(); getchar(); printf("\n\n\n"); &#125; else &#123; printf("输入错误,请重新选择.\n\n\n"); &#125; &#125; getchar(); getchar(); fclose(fq); fclose(fp); return 0;&#125; int paixu(void)&#123; int x = -1, i, j, s; struct teacher t; FILE *fq, *fp; while(x != 0) &#123; printf("按职工号排序------------------------------------------------------------1\n"); printf("按教学效果综合评分排序--------------------------------------------------2\n"); printf("返回上一级--------------------------------------------------------------0\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); fq = fopen("D:\\work\\CODE\\information.txt", "r"); fp = fopen("D:\\work\\CODE\\s.txt", "r"); fscanf(fp, "%d", &amp;s); if(x == 0) &#123; return 0; &#125; for(i = 0; i &lt; s; i++) &#123; fscanf(fq, "%d%s%s%s%s%d%s%d%s%d%s%d%s%d%s%d%d%s", &amp;in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, &amp;in[i].q[0].time, in[i].q[0].xingzhi, &amp;in[i].q[0].xiaoguo, in[i].q[1].name, &amp;in[i].q[1].time, in[i].q[1].xingzhi, &amp;in[i].q[1].xiaoguo, in[i].q[2].name, &amp;in[i].q[2].time, in[i].q[2].xingzhi, &amp;in[i].q[2].xiaoguo, &amp;in[i].pingfen, in[i].jilu); &#125; if(x == 1) &#123; for(i = 0; i &lt; s-1; i++) &#123; for(j = i+1; j &lt; s; j++) &#123; if(in[i].num &gt; in[j].num) &#123; t = in[i]; in[i] = in[j]; in[j] = t; &#125; &#125; &#125; &#125; else if(x == 2) &#123; for(i = 0; i &lt; s-1; i++) &#123; for(j = i+1; j &lt; s; j++) &#123; if(in[i].pingfen &gt; in[j].pingfen) &#123; t = in[i]; in[i] = in[j]; in[j] = t; &#125; &#125; &#125; &#125; else &#123; printf("输入错误,请重新选择.\n\n\n"); &#125; if((x == 1) || (x == 2)) &#123; printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); &#125; getchar(); getchar(); printf("\n\n\n"); &#125; &#125; fclose(fq); fclose(fp); return 0;&#125; int charu(void)&#123; int i, j, x = -1, s; FILE *fq, *fp; while(x != 0) &#123; printf("按教学效果综合评分插入教师记录-----------------------------------------------1\n"); printf("直接查看教师记录-------------------------------------------------------------2\n"); printf("返回上一级-------------------------------------------------------------------0\n"); printf("请输入操作类型:"); scanf("%d", &amp;x); fp = fopen("D:\\work\\CODE\\s.txt", "r"); fscanf(fp, "%d", &amp;s); if(x == 0) &#123; return 0; &#125; fq = fopen("D:\\work\\CODE\\information.txt", "r"); for(i = 0; i &lt; s; i++) &#123; fscanf(fq, "%d%s%s%s%s%d%s%d%s%d%s%d%s%d%s%d%d%s", &amp;in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, &amp;in[i].q[0].time, in[i].q[0].xingzhi, &amp;in[i].q[0].xiaoguo, in[i].q[1].name, &amp;in[i].q[1].time, in[i].q[1].xingzhi, &amp;in[i].q[1].xiaoguo, in[i].q[2].name, &amp;in[i].q[2].time, in[i].q[2].xingzhi, &amp;in[i].q[2].xiaoguo, &amp;in[i].pingfen, in[i].jilu); &#125; fclose(fq); if(x == 1) &#123; printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); printf("请输入教师记录:"); scanf("%s", in[i].jilu); &#125; fq = fopen("D:\\work\\CODE\\information.txt", "w"); for(i = 0; i &lt; s; i++) &#123; fprintf(fq, "%d %s %s %s ", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie); for(j = 0; j &lt; 3; j ++) &#123; fprintf(fq, "%s %d %s %d ", in[i].q[j].name, in[i].q[j].time, in[i].q[j].xingzhi, in[i].q[j].xiaoguo); &#125; fprintf(fq, "%d %s %c", in[i].pingfen, in[i].jilu, '\n'); &#125; fclose(fq); &#125; else if(x == 2) &#123; printf(" 3门主讲课程\n"); printf("职工号 姓名 职称 性别 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 课程名称 开课学期 课程性质 教学效果 教学效果 教师记录\n"); printf(" (学位与非学位课) (评分) (学位与非学位课) (评分) (学位与非学位课) (评分) 综合评分 \n"); for(i = 0; i &lt; s; i++) &#123; printf("%-8d%-8s%-6s%-8s%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-12s%-13d%-14s%-9d%-8d%-20s\n", in[i].num, in[i].name, in[i].zhicheng, in[i].xingbie, in[i].q[0].name, in[i].q[0].time, in[i].q[0].xingzhi, in[i].q[0].xiaoguo, in[i].q[1].name, in[i].q[1].time, in[i].q[1].xingzhi, in[i].q[1].xiaoguo, in[i].q[2].name, in[i].q[2].time, in[i].q[2].xingzhi, in[i].q[2].xiaoguo, in[i].pingfen, in[i].jilu); &#125; &#125; else &#123; printf("输入错误,请重新选择.\n\n\n"); &#125; getchar(); getchar(); printf("\n\n\n"); &#125; fclose(fq); fclose(fp); return 0;&#125;]]></content>
      <categories>
        <category>项目程序</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Fquick_sort.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;昨天在科协学长讲课, 讲的就是快速排序, 据他说这是以后我们面试时的一道必考题, 算法很效率很高. 结果大一的我们当然是听得晕乎的半天才勉强搞懂, 今天按照学长的指导, 在一个小时后终于拿下. &emsp;&emsp;以下是学长写的一个伪码: 1234567891011121314151617Quicksort(A, p, r) if p &lt; r q = paitition(A, p, r) Quicksort(A, p, q - 1) Quicksort(A, q - 1, r) paitition(A, p, r) x = A[r] i = p - 1 for j = p to r - 1 if A[j] &lt;= x i = i +1 exchange A[i] with A[j] exchange A[i + 1] with A[j] return i + 1 &emsp;&emsp;其中 Quicksort 函数中使用递归方式, 将数列在 paitition 函数不断以 A[r] 为标准进行比较, 分成比 A[r] 大的和比 A[r] 小的两个数列, 将 A[r] 插在两个数列之间, 然后再一遍遍重复直到将每一个数字分成一个数列, if p &lt; r 不能满足, 递归结束, 排序完成. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*快速排序：升序*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5//定义外部变量//int a[N];//声明子函数void Quicksort ( int, int, int );int paitition(int, int, int);//快速排序int main()&#123; //定义常量 int a[N],i, x; //输入数组 printf("请输入%d个数：", N); for(i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;a[i]); &#125; //调用子函数 Quicksort ( a, 0, 4); //数组输出 for(x = 0; x &lt; N; x++) &#123; printf("%5d", a[x]); &#125; return 0;&#125; //定义子函数 使用递归思想void Quicksort(int a[], int p, int r)&#123; int q; if(p &lt; r) &#123; q = paitition( a, p, r); Quicksort (a, p, q - 1); Quicksort (a, q + 1, r); &#125;&#125; //定义子函数 进行一次排序int paitition(a, p, r)&#123; int i, j, t; i = p - 1; //开始排序 for(j = p; j &lt; r; j++) &#123; if(a[j] &lt;= a[r]) &#123; i++; t = a[j]; a[j] = a[i]; a[i] = t; &#125; &#125; t = a[i + 1]; a[i + 1] = a[r]; a[r] = t; return i + 1;&#125; &emsp;&emsp;以上是我第一次的代码, 但是问题很多, 于是将数组改为外部变量如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*快速排序：升序*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5//定义外部变量int a[N];//声明子函数void Quicksort ( int, int, int );int paitition(int, int, int);//快速排序int main()&#123; //定义常量 int i, x; //输入数组 printf("请输入%d个数：", N); for(i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;a[i]); &#125; //调用子函数 Quicksort ( N, 0, 4); //数组输出 for(x = 0; x &lt; N; x++) &#123; printf("%5d", a[x]); &#125; return 0;&#125; //定义子函数 使用递归思想void Quicksort(int N, int p, int r)&#123; int q; if(p &lt; r) &#123; q = paitition(N, p, r); Quicksort (N, p, q - 1); Quicksort (N, q + 1, r); &#125;&#125; //定义子函数 进行一次排序int paitition(A, p, r)&#123; int i, j, t; i = p - 1; //开始排序 for(j = p; j &lt; r; j++) &#123; if(a[j] &lt;= a[r]) &#123; i++; t = a[j]; a[j] = a[i]; a[i] = t; &#125; &#125; t = a[i + 1]; a[i + 1] = a[r]; a[r] = t; return i + 1;&#125; &emsp;&emsp;程序运行顺利, 但是第一次的代码的错误原因还不知道, 技术较差…, 老师指点后改正: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*快速排序：升序*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5 //定义外部变量//int a[N]; void Quicksort ( int a[], int, int );int paitition(int a[], int, int); //快速排序int main()&#123; //定义常量 int a[N],i, x; //输入数组 printf("请输入%d个数：", N); for(i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;a[i]); &#125; //调用子函数 Quicksort ( a, 0, 4); //数组输出 for(x = 0; x &lt; N; x++) &#123; printf("%5d", a[x]); &#125; return 0;&#125; //定义子函数 使用递归思想void Quicksort(int a[], int p, int r)&#123; int q; if(p &lt; r) &#123; q = paitition( a, p, r); Quicksort (a, p, q - 1); Quicksort (a, q + 1, r); &#125;&#125; //定义子函数 进行一次排序int paitition(int a[],int p,int r)&#123; int i, j, t; i = p - 1; //开始排序 for(j = p; j &lt; r; j++) &#123; if(a[j] &lt;= a[r]) &#123; i++; t = a[j]; a[j] = a[i]; a[i] = t; &#125; &#125; t = a[i + 1]; a[i + 1] = a[r]; a[r] = t; return i + 1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尽可能多打印要求文本行]]></title>
    <url>%2Fprint_more_text_line.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXLINE 1000 int getline(char line[], int maxline);int cop(char to[], char from[], int i); /*尽可能多打印要求文本行*/int main()&#123; int len; int p, x = 0; char line[MAXLINE]; char longest[MAXLINE] = &#123;0&#125;; //输入输出文本行长度 printf("请选择输出文本行长度："); scanf("%d", &amp;p); getchar(); //选择要求文本行 while((len = getline(line, MAXLINE)) &gt; 0) &#123; if(len == p) &#123; x = cop(longest, line, x); x++; &#125; &#125; //输出所有要求文本行 if(p &gt; 0) &#123; printf("%s", longest); &#125; return 0;&#125; //记录文本行并记录长度int getline(char s[], int lim)&#123; int c, i = 0; c = getchar(); for(i = 0; i &lt;= lim - 1 &amp;&amp; c != EOF &amp;&amp; c != '\n'; ++i) &#123; s[i] = c; c = getchar(); &#125; if(c == '\n') &#123; s[i] = c; //++i; &#125; //s[i] = '\0'; //printf("%s\n",s); return i;&#125; //对多行文本行进行拷贝int cop(char to[], char from[], int i)&#123; int j = 0; //printf("***%d***\n",i); while((to[i] = from[j]) != '\n') &#123; j++; i++; &#125; to[i] = '\n'; //printf("from:%s\n",from); //printf("to:%s\n",to); return i;&#125; &emsp;&emsp;这个程序是C语言一本教程书的一个作业题, 我对原来的例题进行了改编, 使它符合要求(尽可能多打印要求文本行), 原题是打印最长文本行, 程序如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXLINE 1000 int getline(char line[], int maxline);void copy(char to[], char from[]); /*打印最长文本行*/int main()&#123; int len; int max = 0; char line[MAXLINE]; char longest[MAXLINE]; while((len = getline(line, MAXLINE)) &gt; 0) &#123; if(len &gt; max) &#123; max = len; copy(longest, line); &#125; &#125; if(max &gt; 0) &#123; printf("%s", longest); &#125; return 0;&#125; int getline(char s[], int lim)&#123; int c, i; for(i = 0; i &lt;= lim - 1 &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != '\n'; ++i) &#123; s[i] = c; &#125; if(c == '\n') &#123; s[i] = c; ++i; &#125; s[i] = '\0'; return i;&#125; void copy(char to[], char from[])&#123; int i = 0; while((to[i] = from[i]) != '\0') &#123; ++i; &#125;&#125; &emsp;&emsp;我的思路是将原题中对最长行进行筛选改为对符合要求的文本行进行筛选, 修改copy函数使其拷贝所有符合要求的文本行, 最后输出所有文本行, 但是遇到很多问题, 其中最棘手的是在单步调试输入符合要求的文本行第一行, 可以拷贝到longest数组中, 但是第二遍却不能了, 自己调了很久没成功, 在老师的提示下才明白, 在字符串输出 &quot;%s&quot; 中, 如果遇到 \0, 会自动结束, 我没有删去例题中 getline 函数给 s 数组赋 \0 的语句, 导致 longest 数组在输出输入符合要求的文本行第一行时，输出了\0 提前结束. &emsp;&emsp;与大家分享.]]></content>
      <categories>
        <category>项目程序</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
