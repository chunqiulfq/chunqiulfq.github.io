<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[POSIX Threads Programming]]></title>
    <url>%2F2018-09-02-POSIX_Threads_Programming.html</url>
    <content type="text"><![CDATA[翻译自: POSIX Threads Programming 摘要在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于UNIX 系统, IEEE POSIX 1003.1c 标准已经规定了一个标准化的 C 语言线程编程接口. 遵循此标准的实现称为 POSIX线程 或 Pthreads. 本教程首先介绍使用Pthreads的概念, 动机和设计意图. 然后介绍 Pthreads API 中三大种类每一种示例程序: 线程管理, 互斥变量和条件变量. 示例代码始终被用来演示一个新的 Pthreads 程序员所需要的如何使用大多数 Pthread. 本教程最后讨论了 LLNL 细节以及如何将 MPI 与 Pthreads 混合使用. 还包括一个实验练习, 其中包含大量示例代码(C语言). 水平/先决条件: 本教程非常适合那些不熟悉Pthreads并行编程的人. 需要对 C 中的并行编程有基本的了解. 对于那些一般不熟悉并行编程的人来说, EC3500: Introduction to Parallel Computing 中的内容有所帮助. Pthreads Overview(Pthreads 概述)什么是线程? 从技术上讲, 线程被定义为一个可以被操作系统调度运行的独立指令流. 但是这是什么意思? 对于软件开发者来说, 独立于其主程序运行的 procedure(过程) 的概念可能可以最好的描述一个线程. 更进一步来说, 假设一个一个主程序(a.out)有多个过程, 这些过程可以被操作系统调度的同时和/或独立运行. 这被称作一个 multi-threaded 程序. 这是如何完成的? 在理解线程之前, 首先需要理解 UNIX 进程. 进程由操作系统创建, 需要相当数量的开销负担. 进程包含有关程序资源和程序执行状态的信息如下: 进程ID, 进程组ID, 用户ID, 用户组ID 环境变量 工作目录 寄存器 栈 堆 文件描述符 信号 动态库 进程间通信工具(如消息队列, 管道, 信号量或共享内存) 线程使用进程的资源并存在于进程中, 但是线程能够由操作系统调度并作为独立实体运行, 主要是因为线程只复制了使它们可以作为可执行代码存在的基本必需资源. 这种独立的控制流程能够完成是因为线程维持了它独有的: 堆栈指针 寄存器 调度属性(例如策略或优先级) 一组待处理和阻止的信号 总而言之, UNIX 环境中的一个线程: 存在于一个进程中, 并使用该进程的资源. 只要线程的父进程存在且操作系统支持, 它就有自己独立的控制流程. 仅复制其可独立调度所需的基本资源. 可以与其他线程共享进程资源, 这些线程同样是独立地, 并且依赖于进程存在. 如果父进程死亡则死亡(or something similar). 是 lightweight(轻量级) 的, 因为大部分开销已经通过创建进程完成了. 因为同一进程中的线程共享资源: 所有其他线程将看到一个线程对共享系统资源(例如关闭文件)所做的更改. 具有相同值的两个指针指向相同的数据. 可以读取和写入相同的存储器位置, 因此需要程序员进行显式同步. 什么是 Pthreads? 在历史上, 硬件供应商已经实现了他们自己专有的线程版本. 这些实现彼此差异很大使得程序员很难开发具有可移植性的线程应用程序. 为了充分利用线程提供的功能, 需要标准化的编程接口: 对于 UNIX 系统, 该接口已由 IEEE POSIX 1003.1c 标准(1995)指定. 遵循此标准的实现称为 POSIX 线程或 Pthreads. 除了专有 API 之外，大多数硬件供应商现在都提供 Pthreads. POSIX 标准(包括 Pthreads 规范)仍在不断发展和修订. 一些有用的链接: standards.ieee.org/findstds/standard/1003.1-2008.html www.unix.org/version3/ieee_std.html www.unix.org/version3/ieee_std.html Pthread 被定义为一组 C 语言类型和函数调用, 使用 pthread.h 头文件和一个线程库实现(尽管在某些实现中该库可能是另一个库的一部分, 例如 libc). 为什么选择 Pthreads?轻量级 与创建和管理进程的成本相比, 可以创建一个具有更少操作系统开销的线程. 管理线程比管理进程需要更少的系统资源. 例如, 下表比较了 fork() 子函数和 pthread_create() 子函数的计时结果. 使用 time 程序计时反映了50000个进程/线程创建, 单位是秒, 没有使用编译优化. 注意: 不要期望 sys time + user time 等于 real time, 因为这是具有多个 CPUs/cores 的 SMP 系统同时处理该问题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*==============================================================================C Code for fork() creation test==============================================================================*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NFORKS 50000void do_nothing() &#123;int i;i= 0;&#125;int main(int argc, char *argv[]) &#123;int pid, j, status;for (j=0; j&lt;NFORKS; j++) &#123; /*** error handling ***/ if ((pid = fork()) &lt; 0 ) &#123; printf ("fork failed with error code= %d\n", pid); exit(0); &#125; /*** this is the child of the fork ***/ else if (pid ==0) &#123; do_nothing(); exit(0); &#125; /*** this is the parent of the fork ***/ else &#123; waitpid(pid, status, 0); &#125; &#125;&#125; /*==============================================================================C Code for pthread_create() test==============================================================================*/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NTHREADS 50000void *do_nothing(void *null) &#123;int i;i=0;pthread_exit(NULL);&#125; int main(int argc, char *argv[]) &#123;int rc, i, j, detachstate;pthread_t tid;pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);for (j=0; j&lt;NTHREADS; j++) &#123; rc = pthread_create(&amp;tid, &amp;attr, do_nothing, NULL); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; /* Wait for the thread */ rc = pthread_join(tid, NULL); if (rc) &#123; printf("ERROR; return code from pthread_join() is %d\n", rc); exit(-1); &#125; &#125;pthread_attr_destroy(&amp;attr);pthread_exit(NULL);&#125; source 高效的通信/数据交换 考虑在高性能计算环境中使用 Pthreads 的主要动机是为了实现最佳性能, 特别是当应用程序使用 MPI 进行节点间通信时, 通过使用 Pthreads 可以改善性能. MPI 对于Pthreads, 可以不需要中间内存复制, 因为线程在单个进程中共享同一地址空间; 可以通过指针方便的实现高效的数据传递. 在最坏的情况下, Pthreads 通信速度更多的变成了缓存到 CPU 或内存到 CPU 的带宽问题, 但是这样的速度仍然远高于 MPI 共享内存通信的速度. 例如: 这里有一些过去和当前的对比数据如下所示: 其他常见原因 与非线程应用程序相比, 线程应用程序在以下几个方面提供了潜在的性能提升和实用优势: 当进行 I/O 操作时使用 CPU: 例如, 一个程序可能有长时间 I/O 操作的部分, 当一个线程正在等待 I/O 系统调用完成时, 其他线程可以执行 CPU 密集型工作. 优先级/实时调度: 更重要的任务可以被调度取代或重大优先级更低的任务. 异步的事件处理: 可以交错执行有不确定频率和持续时间的服务事件的任务. 例如, Web 服务器既可以从先前的请求传输数据, 也可以管理新请求的到达. 一个完美的例子是典型的 Web 浏览器, 其中许多交错任务可以同时发生, 并且任务可以在优先级上变化. 另一个很好的例子是现代操作系统, 线程得到了广泛使用, MS Windows 操作系统和使用线程的应用程序的屏幕截图如下所示: 设计线程程序并行编程 在现代的多核机器上, Pthreads 非常适合并行编程. 适用于一般并发编程的都可以使用并发线程程序. 设计并行程序有很多注意事项, 例如: 使用什么类型的并行编程模型? 问题分区 负载均衡 通信 数据依赖性 同步和竞争条件 内存问题 I/O 问题 程序复杂性 程序员的努力/成本/时间 … 这些问题超出了本教程涵盖的范围, 但是感兴趣的读者可以在Introduction to Parallel Computing教程中快速了解概念. 通常, 为了能够利用 Pthreads, 程序必须能够组织成分散的可以并发执行的独立任务. 例如, 如果函数1和函数2可以被交替执行(实时交错和/或重叠), 它们将可以成为线程. 具有以下特征的程序可能非常适合 Pthreads: 同时由多个任务执行的工作或操作的数据 因为长时间 I/O 产生的阻塞 一些地方消耗大量 CPU 周期, 其他地方不消耗(CPU 使用不均匀) 必须响应的异步事件 有些工作比其他工作更重要(优先中断) 存在几种用于线程程序的常见模型 Manager/worker: 在一个线程(manager)中将工作分配给其他线程(worker). 通常, manager 处理所有输入和封装工作到其他任务中. 在 manager/worker 模式中至少有两种形式是常见的: 静态线程池和动态线程池. Pipeline: 任务被分解为一系列子操作, 每个子操作都是串行处理的, 但由不同的线程并行处理. 汽车装配线最能描述这种模型. Peer: 类似于 manager/worker 模型, 共享内存模型 所有线程都可以访问相同的全局共享内存 线程也有自己的私有数据 程序员负责同步访问(保护)全局共享数据 线程安全 线程安全: 简而言之, 指一个程序具有同时执行多个线程而不破坏共享数据或产生 race conditions 的能力. 例如, 假设你的应用程序创造几个线程, 每一个线程都调用同一个库函数: 这个库函数访问或修改一个全局结构体或指针. 每一个线程可能会调用这个函数在同一时间去尝试修改这个全局结构体或指针. 如果函数不使用某种同步的修改方式来防止数据损坏, 那么这个它就不是线程安全的. 这意味着使用外部库函数如果不能 100% 确定它是线程安全的, 那么就需要抓住机会解决可能出现的问题. 建议: 如果应用程序使用没有明确保证线程安全的库或对象, 请务必小心. 如果对线程安全有疑问, 那么除非另有证明, 否则假设它不是线程安全的. 可以通过有序访问有疑问的函数等方式保证线程安全. 线程限制 尽管 Pthreads API 是 ANSI/IEEE 标准, 但是它的实现方式标准并未指定, 通常在不同平台会有所变化. 因此, 在一个平台上运行良好的程序, 在另一个平台上运行可能失败或产生错误. 例如, 允许的最大线程数和默认线程堆栈大小是设计程序时要考虑的两个重要限制. 本教程后面将详细讨论几个线程的限制. The Pthreads API ANSI / IEEE POSIX 1003.1-1995 标准中定义了最初的 Pthreads API. POSIX 标准(包括 Pthreads 规范)在不断发展和修订. 标准的副本可以从IEEE购买或从其他网站免费下载. 组成 Pthreads API 的函数可以被非正式的划分为四个类别: 线程管理: 直接作用于线程的函数 - creating, detaching, joining, 等. 还包括设置/查询线程属性的函数(joinable, scheduling, 等). 互斥锁: 处理同步的函数, 被称为 mutex, 是 mutual exclusion 的缩写. 互斥函数提供 creating, destroying, locking 和 unlocking 互斥锁功能. 还包括用于设置或修改与互斥锁相关联属性的互斥锁属性函数. 条件变量: 解决共享互斥锁的线程之间的通信问题的函数. 这基于程序员指定的条件. 这一类包括基于指定条件变量的 create, destroy, wait 和 signal 函数. 还包括用于设置/查询条件变量属性的函数. 同步: 管理读写锁和同步屏障(barriers)的函数. 命名约定: 线程库以 pthread_ 开头作为标识. 如下有一些例子: Routine Prefix Functional Group pthread_ 线程本身和杂项的函数 pthreadattr 线程属性对象 Pthreadmutex 互斥锁 pthreadmutexattr 互斥锁属性对象 pthreadcond 环境变量 pthreadcondattr 环境变量属性对象 pthreadkey 用于特定线程的数据密钥 pthreadrwlock 读写锁 pthreadbarrier 同步屏障 不透明对象的概念遍及API的设计. 基本调用用于创建或修改不透明对象 - 可以通过调用属性函数来修改和处理不透明对象. Pthreads API 包含大约100个子函数. 本教程将重点介绍其中的一部分 - 特别是那些对刚刚开始使用 Pthreads 的程序有用的内容. 为了可移植性, 在使用 Pthreas 库时应该将 pthread.h 包含在每个源文件中. 当前的 POSIX 标准仅针对 C 语言定义. Fortran 程序员可以使用 C 函数调用的封装. 一些 Fortran 编译器可能提供 Fortran pthreads API. 有很多关于Pthreads的优秀书籍. 其中一些列在本教程的参考部分中. 编译线程程序 下表列出了几个用于 Pthreads 代码的编译命令示例: 线程管理创建和终止线程函数12345int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);void pthread_exit(void *retval);int pthread_cancel(pthread_t thread);int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr); 创建线程 最开始, main() 函数包含一个默认线程. 所有其他线程必须由程序员显式创建. pthread_create 创建一个新的线程并执行它. 这个函数可以在代码任何位置任意调用. pthread_create 参数: thread: 输出参数, 新线程唯一的不透明标识符. attr: 可用于设置线程属性的不透明属性对象. 你可以指定一个线程属性对象或使用 NULL 的默认值. start_routine: 线程创建后执行的 C 函数. arg: 传递给 start_routine 的单个参数, 必须通过转换为 void 类型指针进行传递. 如果不传递参数, 可以使用 NULL. 进程可以创建的最大线程数取决于系统设置. 尝试超出限制的程序可能会失败或产生错误的结果. 这里以 Linux 为例, 介绍查询和设置系统的线程限制. 下图演示查询默认线程(软)限制, 然后将最大进程(包括线程)数设置为硬限制, 验证设置是否成功. 一旦创建完成, 线程之间就是平等的, 并且可以创建其他线程. 线程之间没有隐含的层次结构或依赖关系. 线程属性 在默认情况下, 使用某些属性创建一个线程. 这些属性可以被程序员通过线程属性对象修改. pthread_attr_init 和 pthread_attr_destroy 初始化/销毁线程属性对象. 之后使用其他函数查询/设置线程属性对象中的特定属性. 属性包括: Detached(已分离)或 joinable(可合并)状态 Scheduling inheritance Scheduling policy(调度策略) Scheduling parameters(调度参数) Scheduling contention scope 栈大小 栈地址 Stack guard (overflow) size 其中一些属性将在后面讨论. 线程的绑定和调度 问题: 当一个线程被创建后, 你如何知道: 操作系统何时调度它运行? 它将运行在哪个 CPU/core? 答案: 除非你使用 Pthreads 调度机制, 否则线程的执行位置和时间将由操作系统和系统设置决定. 健壮的程序不应该依赖于以特定顺序或在特定 CPU/core 执行的线程. Pthreads API 提供了几个用于指定线程执行调度方式的函数. 例如, 可以将线程以 FIFO(先进先出), RR(循环), OTHER(操作系统确定) 等方式调度. 它还提供了设置线程调度优先级的功能. 本教程没有涉及这个话题, 但是在 man page 的 sched_setscheduler 中有它 工作原理 的概述. Pthreads API 不提供将线程绑定到特定 CPU/core 的函数. 但系统的线程库可能提供了自己实现的这个功能 - 例如提供一个非标准的 pthread_setaffinity_np 函数. 请注意, 名称中的 _np 代表 非便携式. 此外, 操作系统自身也提供这种功能的方法, 例如 Linux 提供了 sched_setaffinity 函数. 终止线程 &amp; exit() 有几种方法可以终止一个线程: 线程执行完启动函数正常退出, 它已经完成工作. 线程调用 pthread_exit 子函数 - 无论其工作是否完成都会退出. 线程由另一个线程通过 pthread_cancel 函数取消. 线程调用 exec() 整个进程将终止被替换为另一个进程; 调用 exit() 这个进程将终止. 主线程 main() 首先完成, 其他线程将在没有调用 pthread_exit 的情况下终止. pthread_exit() 函数允许程序员指定一个可选的终止 retval 参数. 此可选参数通常返回到 joining 终止线程的线程中(稍后介绍). 除非想要传回可选参数, 否则在正常执行完成的子程序中, 可以省去调用 pthread_exit(). 清理: pthread_exit() 函数不会关闭文件; 在线程终止后, 线程内打开的任何文件都将保持打开状态. 在 main() 中调用 pthread_exit() 的讨论: 如果你没有显式调用 pthread_exit(), 但是 main() 函数先于它创建的线程退出, 那么肯定存在问题. main() 创建的所有线程都将终止, 因为它已经退出, 不在支持其他线程. main() 可以通过在最后显式调用 pthread_exit(), main() 将阻塞并保持活跃状态以支持它创建的线程, 直到它们完成为止. 示例: 线程的创建和终止 这是使用 pthread_create() 函数创建 5 个线程的简单示例代码. 每个线程输出 Hello World! 消息, 然后调用 pthread_exit() 退出. 1234567891011121314151617181920212223242526272829303132333435363738/******************************************************************************* FILE: hello.c* DESCRIPTION:* A "hello world" Pthreads program. Demonstrates thread creation and* termination.* AUTHOR: Blaise Barney* LAST REVISED: 08/09/11******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 5void *PrintHello(void *threadid)&#123; long tid; tid = (long)threadid; printf("Hello World! It's me, thread #%ld!\n", tid); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0;t&lt;NUM_THREADS;t++)&#123; printf("In main: creating thread %ld\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); if (rc)&#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; /* Last thing that main() should do */ pthread_exit(NULL);&#125; source output 将参数传递给线程 pthread_create() 线程允许程序员将一个参数传递给线程的启动函数. 对于必须传递多个参数的情况, 可以创建一个包含所有参数的结构体, 在 pthread_create() 函数中传递这个结构体的指针实现. 所有参数必须通过引用传递并转换为 (void *) 类型. 问题: 考虑在不确定线程是否启动和调度的情况下, 如何将数据安全的传递给新创建的线程? 答案: 确保所有的数据都是线程安全的 - 数据不能被其他线程更改. 接下来的三个示例说明什么是可以做的, 什么是不能做的. 线程参数传递示例 这个代码展示了如何将简单的整型传递给每一个参数. 使用唯一的数据结构变量调用线程, 以确保每个线程的参数在整个程序中保持不变. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/******************************************************************************* FILE: hello_arg1.c* DESCRIPTION:* A "hello world" Pthreads program which demonstrates one safe way* to pass arguments to threads during thread creation.* AUTHOR: Blaise Barney* LAST REVISED: 08/04/15******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8char *messages[NUM_THREADS];void *PrintHello(void *threadid)&#123; long taskid; sleep(1); taskid = (long) threadid; printf("Thread %d: %s\n", taskid, messages[taskid]); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; long taskids[NUM_THREADS]; int rc, t; messages[0] = "English: Hello World!"; messages[1] = "French: Bonjour, le monde!"; messages[2] = "Spanish: Hola al mundo"; messages[3] = "Klingon: Nuq neH!"; messages[4] = "German: Guten Tag, Welt!"; messages[5] = "Russian: Zdravstvuyte, mir!"; messages[6] = "Japan: Sekai e konnichiwa!"; messages[7] = "Latin: Orbis, te saluto!"; for(t=0;t&lt;NUM_THREADS;t++) &#123; taskids[t] = t; printf("Creating thread %d\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) taskids[t]); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 这个示例显示了如何通过结构体设置/传递多个参数. 每个线程都接收一个唯一的结构体实例. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/******************************************************************************* FILE: hello_arg2.c* DESCRIPTION:* A "hello world" Pthreads program which demonstrates another safe way* to pass arguments to threads during thread creation. In this case,* a structure is used to pass multiple arguments.* AUTHOR: Blaise Barney* LAST REVISED: 01/29/09******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8char *messages[NUM_THREADS];struct thread_data&#123; int thread_id; int sum; char *message;&#125;;struct thread_data thread_data_array[NUM_THREADS];void *PrintHello(void *threadarg)&#123; int taskid, sum; char *hello_msg; struct thread_data *my_data; sleep(1); my_data = (struct thread_data *) threadarg; taskid = my_data-&gt;thread_id; sum = my_data-&gt;sum; hello_msg = my_data-&gt;message; printf("Thread %d: %s Sum=%d\n", taskid, hello_msg, sum); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int *taskids[NUM_THREADS]; int rc, t, sum; sum=0; messages[0] = "English: Hello World!"; messages[1] = "French: Bonjour, le monde!"; messages[2] = "Spanish: Hola al mundo"; messages[3] = "Klingon: Nuq neH!"; messages[4] = "German: Guten Tag, Welt!"; messages[5] = "Russian: Zdravstvytye, mir!"; messages[6] = "Japan: Sekai e konnichiwa!"; messages[7] = "Latin: Orbis, te saluto!"; for(t=0;t&lt;NUM_THREADS;t++) &#123; sum = sum + t; thread_data_array[t].thread_id = t; thread_data_array[t].sum = sum; thread_data_array[t].message = messages[t]; printf("Creating thread %d\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) &amp;thread_data_array[t]); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 这个示例是不正确的参数传递方式. 传递变量 t 的地址会使所有线程可见并且共享内存地址空间. 12345678910111213141516171819202122232425262728293031323334353637383940/****************************************************************************** FILE: hello_arg3.c* DESCRIPTION:* This "hello world" Pthreads program demonstrates an unsafe (incorrect)* way to pass thread arguments at thread creation. In this case, the* argument variable is changed by the main thread as it creates new threads.* AUTHOR: Blaise Barney* LAST REVISED: 07/16/14******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 8void *PrintHello(void *threadid)&#123; long taskid; sleep(1); taskid = *(long *)threadid; printf("Hello from thread %ld\n", taskid); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0;t&lt;NUM_THREADS;t++) &#123; printf("Creating thread %ld\n", t); rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *) &amp;t); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; pthread_exit(NULL);&#125; source output 合并和分离线程函数1234int pthread_join(pthread_t threadid, void **status);int pthread_detach(pthread_t threadid);int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);int pthread_attr_getdetachstate(const pthread_attr_t *attr, int detachstate); 合并(Joining) “Joining” 是一种完成后的线程与其他线程同步的方式. 例如: pthread_join() 子函数会阻塞当前的线程执行, 直到 threadid 指定的线程终止. 如果 status 参数在 threadid 指定的目标线程调用 pthread_exit() 中被设置, 那么程序员可以在目标线程终止时获取到 status. 一个合并的线程可以匹配一个 pthread_join() 调用. 尝试多次合并同一个线程是一个逻辑错误. 另外两种同步方式互斥和条件变量将在后面讨论. 是否为可合并的 当一个线程被创建时, 它的其中一个属性的定义就是该线程是可合并的还是已分离的. 只有以可合并属性创建的线程才可以被合并. 如果一个线程以已分离属性创建, 那么它将永远不能被合并. POSIX 标准的最终草案规定默认情况下线程应该以可合并属性创建. 想要显式的以可合并或已分离属性创建一个线程, 要使用 pthread_create() 函数中的 attr 参数. 典型的 4 步流程是: 声明一个 pthread_attr_t 数据类型的线程属性变量. 使用 pthread_attr_init() 初始化属性变量. 使用 pthread_attr_setdetachstate() 设置属性分离状态. 当设置完成时, 使用 pthread_attr_destroy() 释放使用的库资源. 分离 pthread_detach() 函数可以显式分离一个线程, 即使这个线程以可合并属性被创建. 没有作用相反的函数. 建议 如果一个线程需要合并, 请考虑显式的以可合并属性创建它. 这样做到了可移植性, 因为并非所有实现方式都是默认以可合并属性创建线程. 如果你提前知道一个线程将永远不会需要合并到另一个线程, 请考虑使用已分离状态创建它. 这样可以释放一些系统资源. 线程合并示例 这个示例演示了如何使用 Pthread join 函数”等待”线程完成. 因为一些 Pthread 的实现可能不是默认使用可合并状态创建线程, 所以这个示例中的线程是显式的使用可合并状态去创建, 以便后面进行合并. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/****************************************************************************** FILE: join.c* DESCRIPTION:* This example demonstrates how to "wait" for thread completions by using* the Pthread join routine. Threads are explicitly created in a joinable* state for portability reasons. Use of the pthread_exit status argument is * also shown. Compare to detached.c* AUTHOR: 8/98 Blaise Barney* LAST REVISED: 01/30/09******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 4void *BusyWork(void *t)&#123; int i; long tid; double result=0.0; tid = (long)t; printf("Thread %ld starting...\n",tid); for (i=0; i&lt;1000000; i++) &#123; result = result + sin(i) * tan(i); &#125; printf("Thread %ld done. Result = %e\n",tid, result); pthread_exit((void*) t);&#125;int main (int argc, char *argv[])&#123; pthread_t thread[NUM_THREADS]; pthread_attr_t attr; int rc; long t; void *status; /* Initialize and set thread detached attribute */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(t=0; t&lt;NUM_THREADS; t++) &#123; printf("Main: creating thread %ld\n", t); rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (void *)t); if (rc) &#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; /* Free attribute and wait for the other threads */ pthread_attr_destroy(&amp;attr); for(t=0; t&lt;NUM_THREADS; t++) &#123; rc = pthread_join(thread[t], &amp;status); if (rc) &#123; printf("ERROR; return code from pthread_join() is %d\n", rc); exit(-1); &#125; printf("Main: completed join with thread %ld having a status of %ld\n",t,(long)status); &#125; printf("Main: program completed. Exiting.\n"); pthread_exit(NULL);&#125; source output 栈空间管理函数1234int pthread_attr_getstacksize(const pthread_addr_t *attr, size_t stacksize);int pthread_attr_setstacksize(pthread_addr_t *attr, size_t stacksize);int pthread_attr_getstackaddr(const pthread_addr_t *attr, size_t stacksize);int pthread_attr_setstackaddr(pthread_addr_t *attr, size_t stacksize); 防止栈空间出错 POSIX 标准没有规定一个线程的栈空间大小, 它取决于 POSIX 的实现和系统设置的变化. 超出默认栈空间限制经常是很容易出现的, 产生的后果是: 程序终止和/或数据被破坏. 具有安全性和可移植性的程序不能依赖于默认的栈空间大小, 而是通过 pthread_attr_setstacksize 为每个线程显式分配足够的栈空间. pthread_attr_getstackaddr 和 pthread_addrgetstackaddr 函数可以由特定环境中运行的应用程序使用, 在该环境中线程栈空间必须在放某个特定的内存区域中. LC 的一些实际例子 默认线程栈空间大小变化很大. 可以获取到的最大栈空间大小变化也很大, 且这也依赖于每个系统可以创建的线程数. 过去和现在的体系结构都显示出默认线程堆空间大小的广泛变化. 系统体系结构 #CPUs Memory(GB) Default Size(bytes) Intel Xeon E5-2670 16 32 2,097,152 Intel Xeon 5660 12 24 2,097,152 AMD Opteron 8 16 2,097,152 Intel IA64 4 8 33,554,432 Intel IA32 2 4 2,097,152 IBM Power5 8 32 196,608 IBM Power4 8 16 196,608 IBM Power3 16 16 98,304 栈空间管理示例 这个示例演示了如何获取和设置一个线程的栈空间大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#define NTHREADS 4#define N 1000#define MEGEXTRA 1000000pthread_attr_t attr;void *dowork(void *threadid)&#123; double A[N][N]; int i,j; long tid; size_t mystacksize; tid = (long)threadid; pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); printf("Thread %ld: stack size = %li bytes \n", tid, mystacksize); for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) A[i][j] = ((i*j)/3.452) + (N-i); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; pthread_t threads[NTHREADS]; size_t stacksize; int rc; long t; pthread_attr_init(&amp;attr); pthread_attr_getstacksize (&amp;attr, &amp;stacksize); printf("Default stack size = %li\n", stacksize); stacksize = sizeof(double)*N*N+MEGEXTRA; printf("Amount of stack needed per thread = %li\n",stacksize); pthread_attr_setstacksize (&amp;attr, stacksize); printf("Creating threads with stack size = %li bytes\n",stacksize); for(t=0; t&lt;NTHREADS; t++)&#123; rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (void *)t); if (rc)&#123; printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); &#125; &#125; printf("Created %ld threads.\n", t); pthread_exit(NULL);&#125; 杂项函数12pthread_t pthread_self(void);int pthread_equal(pthread_t t1, pthread_t t2); pthread_self 返回一个系统分配的唯一的当前调用线程的线程 ID(线程描述符). pthread_equal 对比两个线程 ID. 如果两个线程 ID 不同则返回 0, 否则返回一个非零整数. 注意: 对于这两个函数所使用的线程 ID 对象都是不透明的, 无法轻松检查. 因为线程 ID 是不透明的, 所以不应该使用 C 语言相等运算符 == 来比较两个线程 ID 或者将单个线程 ID 与另一个值进行比较. 1int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); pthread_once 在一个进程中只执行一次 init_routine. 由进程中的任何线程第一次调用该函数是执行给定的没有参数的 init_routine. 任何后续的调用都将是无效的. init_routine 函数通常是一个初始化的函数. once_control 参数是一个同步控制结构体，需要在调用 pthread_once 之前进行初始化. 例如: 1pthread_once_t once_control = PTHREAD_ONCE_INIT; 线程练习一入门和线程管理函数 概述: 使用你的用户名和OTP令牌登录一个LC集群 将练习文件复制到家目录 熟悉 LC 的 Pthreads 环境 写一个简单的“Hello World” Pthreads 程序 成功编译程序 成功运行程序 - 使用几种不同的方式 查看, 编译, 运行和/或调试一些相关的 Pthreads 程序(已提供) 在这里练习 互斥变量概述 Mutex 是 mutual exclusion 的缩写. 互斥变量是实现线程同步和发生多次写入时保护共享数据的方法之一. 互斥变量的行为类似以”锁定”的方式保护对共享数据资源的访问, 一般称作互斥锁. 在 Pthread 中使用互斥的基本概念指在任何时间内只有一个线程能锁定(或拥有[^1])一个互斥变量. 因此, 即使多个线程试图锁定互斥锁, 只有一个线程会成功. 在拥有该互斥锁的线程解锁该互斥锁之前，没有其他线程可以拥有该互斥锁. 互斥锁可以用于防止”竞争(race)”条件. 涉及银行交易竞争条件没有进行同步的示例如下所示: 在上面的示例中, 当线程使用共享数据资源时应该使用互斥锁来锁定”balance”. 通常, 拥有互斥锁的线程回去更新全局变量. 这是确保多个线程更新同一个变量时,一个安全的方法. 最终的结果与只有一个线程执行所有更新的结果是相同的. 正在更新的变量属于应该加锁的”关键部分”. 使用互斥锁的典型顺序如下: 创建并初始化互斥变量 几个线程试图锁定互斥锁 只有一个成功, 该线程拥有互斥锁 拥有锁的线程执行一些操作 拥有者解锁互斥锁 另一个线程获取互斥锁并重复该过程 最后互斥锁被销毁 当多个线程去竞争一个互斥锁时, 失败者将阻塞在 lock 调用处 - 通过 trylock 而不是 lock 可以做到非阻塞调用. 在保护共享数据时, 程序员的责任是确保每个需要使用互斥锁的线程都是这样做的. 例如, 如果4个线程正在更新同一个数据, 但只有一个线程使用了互斥锁, 那么数据仍然可能被破坏. 创建和销毁互斥锁函数1234int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutexattr_init(pthread_mutexattr_t *attr);int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); 用法 必须使用 pthread_mutex_t 类型声明互斥变量并且初始化后才能使用. 有两种方法可以初始化一个变量: 静态, 声明时初始化. 例如: 1pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; 动态, 使用 pthread_mutex_init() 函数初始化. 这个方法允许设置互斥对象属性 attr. 互斥锁初始化后默认是解锁的. pthread_mutex_init 中的 attr 对象用于为互斥对象设置属性, 如果使用必须是 pthread_mutexattr_t 类型(可以指定为 NULL 以使用默认值). Pthread 标准定义了三个可选的互斥锁属性: Protocol(协议): 指定用于防止互斥锁的优先级反转的协议. prioceiling: 指定已初始化的互斥锁的优先级上限. Process-shared: 指定互斥锁的进程共享. 请注意, 不是所有实现都可以提供了这三个可选的互斥锁属性. pthread_mutexattr_init 和 pthread_mutexattr_destroy 函数分别用于创建和销毁互斥锁属性对象. 应该使用 pthread_mutex_destroy 来释放不再需要的互斥对象. 锁定和解锁互斥锁函数123int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 用法 线程使用 pthread_mutex_lock() 对指定参数 mutex 变量进行锁定. 如果这个互斥锁已经被其他线程锁定了, 那么调用这个函数的线程将会阻塞在这个调用处直到这个互斥锁被其他线程解锁. pthread_mutex_trylock() 会去尝试锁定一个互斥锁. 然而, 如果这个互斥锁已经锁定, 这个函数将立即返回一个”忙碌”的错误代码. 这个函数可能会被用来防止死锁条件, 例如在优先级倒置的情况下. pthread_mutex_unlock 被拥有互斥锁的线程调用会解锁这个互斥锁. 如果其他线程获取正在包含数据的互斥锁(处于被锁定), 那么在线程完成对被保护数据的访问后需要调用这个函数. 如果出现以下错误, pthread_mutex_unlock 将返回错误: 如果互斥锁已经被解锁 如果互斥锁被另一个线程拥有 互斥锁并没有什么”神奇”的. 事实上, 它类似于所有参与共享数据访问的线程之间的”绅士协议”. 程序员需要确保必要的线程都能正确的使用锁定和解锁调用. 以下方案演示了一个逻辑错误: 问题: 当多个线程正在等待一个被锁定的互斥锁时, 那个线程在释放后将首先锁定这个互斥锁? 答案: 除非使用线程优先级调度(未被覆盖), 否则分配的权利将留给本机系统调度程序, 并且可能或多或少是随机的. 使用互斥锁的示例 这个示例程序展示了在一个计算点积的线程程序中使用互斥变量. 主要的数据通过全局可访问的结构体提供给所有线程. 每个线程处理不同的一部分数据. 主线程等待所有线程完成计算, 然后打印结果总和. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/****************************************************************************** FILE: dotprod_mutex.c* DESCRIPTION:* This example program illustrates the use of mutex variables * in a threads program. This version was obtained by modifying the* serial version of the program (dotprod_serial.c) which performs a * dot product. The main data is made available to all threads through * a globally accessible structure. Each thread works on a different * part of the data. The main thread waits for all the threads to complete * their computations, and then it prints the resulting sum.* SOURCE: Vijay Sonnad, IBM* LAST REVISED: 01/29/09 Blaise Barney******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* The following structure contains the necessary information to allow the function "dotprod" to access its input data and place its output into the structure. This structure is unchanged from the sequential version.*/typedef struct &#123; double *a; double *b; double sum; int veclen; &#125; DOTDATA;/* Define globally accessible variables and a mutex */#define NUMTHRDS 4#define VECLEN 100000DOTDATA dotstr; pthread_t callThd[NUMTHRDS];pthread_mutex_t mutexsum;/*The function dotprod is activated when the thread is created.As before, all input to this routine is obtained from a structure of type DOTDATA and all output from this function is written intothis structure. The benefit of this approach is apparent for the multi-threaded program: when a thread is created we pass a singleargument to the activated function - typically this argumentis a thread number. All the other information required by the function is accessed from the globally accessible structure. */void *dotprod(void *arg)&#123; /* Define and use local variables for convenience */ int i, start, end, len ; long offset; double mysum, *x, *y; offset = (long)arg; len = dotstr.veclen; start = offset*len; end = start + len; x = dotstr.a; y = dotstr.b; /*Perform the dot product and assign resultto the appropriate variable in the structure. */ mysum = 0; for (i=start; i&lt;end ; i++) &#123; mysum += (x[i] * y[i]); &#125; /*Lock a mutex prior to updating the value in the sharedstructure, and unlock it upon updating.*/ pthread_mutex_lock (&amp;mutexsum); dotstr.sum += mysum; printf("Thread %ld did %d to %d: mysum=%f global sum=%f\n",offset,start,end,mysum,dotstr.sum); pthread_mutex_unlock (&amp;mutexsum); pthread_exit((void*) 0);&#125;/* The main program creates threads which do all the work and then print out result upon completion. Before creating the threads,The input data is created. Since all threads update a shared structure, weneed a mutex for mutual exclusion. The main thread needs to wait forall threads to complete, it waits for each one of the threads. We specifya thread attribute value that allow the main thread to join with thethreads it creates. Note also that we free up handles when they areno longer needed.*/int main (int argc, char *argv[])&#123; long i; double *a, *b; void *status; pthread_attr_t attr; /* Assign storage and initialize values */ a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); for (i=0; i&lt;VECLEN*NUMTHRDS; i++) &#123; a[i]=1; b[i]=a[i]; &#125; dotstr.veclen = VECLEN; dotstr.a = a; dotstr.b = b; dotstr.sum=0; pthread_mutex_init(&amp;mutexsum, NULL); /* Create threads to perform the dotproduct */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(i=0;i&lt;NUMTHRDS;i++) &#123; /* Each thread works on a different set of data. * The offset is specified by 'i'. The size of * the data for each thread is indicated by VECLEN. */ pthread_create(&amp;callThd[i], &amp;attr, dotprod, (void *)i); &#125; pthread_attr_destroy(&amp;attr); /* Wait on the other threads */ for(i=0;i&lt;NUMTHRDS;i++) &#123; pthread_join(callThd[i], &amp;status); &#125; /* After joining, print out the results and cleanup */ printf ("Sum = %f \n", dotstr.sum); free (a); free (b); pthread_mutex_destroy(&amp;mutexsum); pthread_exit(NULL);&#125; Serial version source Pthreads version source 条件变量概述 条件变量为线程提供了另一种同步方式. 互斥锁通过控制对数据的线程访问来实现同步, 而条件变量允许线程根据数据的实际值进行同步. 如果没有条件变量, 程序员需要让线程去不断轮询(可能在关键部分)检查条件是否得到满足. 这可能是非常消耗资源的, 因为线程将在这个过程中持续忙碌. 条件变量是一种在不用轮询的情况下达到同一效果的方法. 条件变量始终与互斥锁一起使用. 使用条件变量的典型顺序如下所示: Main Thread 声明并初始化需要同步的全局数据/变量(例如“count”) 声明并初始化条件变量对象 声明并初始化关联的互斥锁 创建线程A和B来完成工作 Thread A 工作直到必须发生某种情况(例如“计数”必须达到指定值) 锁定关联的互斥锁并检查全局变量的值 全局变量的值不满足条件, 调用 pthread_cond_wait() 阻塞在这里等待 Thread B 的信号. 注意: 对 pthread_cond_wait() 的调用会自动并原子的解锁与条件变量关联的互斥锁, 以便 Thread B 可以使用它 收到信号后, 线程会从阻塞状态被唤醒. 与条件变量关联的互斥锁会自动并原子的锁定 明确的解锁互斥锁 继续 Thread B 工作 锁定与条件变量关联的互斥锁 更改 Thread A 正在等待的全局变量的值 检查 Thread A 等待的全局变量的值, 如果它满足所需条件，则向 Thread A 发出信号 解锁互斥锁 继续 Thread A 与 Thread B 并行运行. Main Thread ​ 合并/继续 创建和销毁条件变量函数1234int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);int pthread_cond_destroy(pthread_cond_t *cond);int pthread_condattr_init(pthread_condattr_t *attr);int pthread_condattr_destroy(pthread_condattr_t *attr); 用法 必须使用 pthread_cond_t 类型声明条件变量并且初始化后才能使用. 有两种方法可以初始化条件变量: 静态, 声明时初始化. 例如: 1pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER; 动态, 使用 pthread_cond_init() 函数初始化. 创建的条件变量的 ID 通过 condition 参数返回给调用线程. 这个方法允许设置条件变量对象属性 attr. 可选的参数 attr 对象用于设置条件变量属性. 条件变量只定义了一个属性: process-shared, 它允许条件变量被其他进程中的线程看到. 如果使用属性对象, 它必须是 pthread_condattr_t 类型(可以指定为 NULL 以使用默认值). 请注意, 并非所有实现都提供了 process-shared 属性. pthread_condattr_init 和 pthread_condattr_destroy 函数用于创建和销毁条件变量属性对象. 应该使用 pthread_cond_destroy 来释放不再需要的条件变量. 条件变量等待和发信号123int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); pthread_cond_wait() 在收到达到规定条件的信号之前会一直阻塞调用线程. 这个函数应该在锁定互斥锁后调用, 它会在等待时自动释放互斥锁. 当收到信号后会线程会被唤醒, 互斥锁将会被自动锁定以供线程使用. 然后程序员负责在线程处理完成后解锁互斥锁. 建议: 调用 pthread_cond_wait() 时使用 WHILE 循环而不是 IF 语句(可以参考下面示例中的 watch_count 函数)来检查等待的条件, 这样可以帮助处理几个潜在的问题, 例如: 如果多个线程在等待同一个唤醒信号, 当收到信号时, 它们将轮流获取互斥锁, 然后它们中的任何一个线程都可以修改它们等待条件. 如果线程由于程序错误而收到错误的信号. 线程库允许在不违反标准的情况下向等待的线程发出虚假唤醒. pthread_cond_signal() 函数用于发送信号给(或唤醒)另一个正在使用条件变量等待的线程. 必须在与 pthread_cond_wait() 参数 mutex 相同的互斥锁锁定后才能调用它, 同时为了 pthread_cond_wait() 自动加锁能够执行完成必须要对参数 mutex 相同的互斥锁进行解锁. 如果多个线程处于阻塞等待状态, 那么应该使用 pthread_cond_broadcast() 函数而不是 pthread_cond_signal(). 在调用 pthread_cond_wait() 之前调用 pthread_cond_signal() 是一个逻辑错误. 警告: 当使用这些函数时, 必须正确锁定和解锁相关联的互斥锁变量. 例如: 调用 pthread_cond_wait() 之前没有锁定互斥锁可能导致它不被阻塞. 调用 pthread_cond_signal 后没有解锁互斥锁可能不允许对应的 pthread_cond_wait 函数完成(它将保持阻塞状态). 使用条件变量的示例 这个简单的示例代码演示了几个 Pthread 条件变量相关函数的使用. main 函数创建了三个线程. 其中两个线程执行工作并更新 count 变量. 第三个线程等待, 直到 count 变量达到指定值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/******************************************************************************* FILE: condvar.c* DESCRIPTION:* Example code for using Pthreads condition variables. The main thread* creates three threads. Two of those threads increment a "count" variable,* while the third thread watches the value of "count". When "count" * reaches a predefined limit, the waiting thread is signaled by one of the* incrementing threads. The waiting thread "awakens" and then modifies* count. The program continues until the incrementing threads reach* TCOUNT. The main program prints the final value of count.* SOURCE: Adapted from example code in "Pthreads Programming", B. Nichols* et al. O'Reilly and Associates. * LAST REVISED: 03/07/17 Blaise Barney******************************************************************************/#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_THREADS 3#define TCOUNT 10#define COUNT_LIMIT 12int count = 0;pthread_mutex_t count_mutex;pthread_cond_t count_threshold_cv;void *inc_count(void *t) &#123; int i; long my_id = (long)t; for (i=0; i &lt; TCOUNT; i++) &#123; pthread_mutex_lock(&amp;count_mutex); count++; /* Check the value of count and signal waiting thread when condition is reached. Note that this occurs while mutex is locked. */ if (count == COUNT_LIMIT) &#123; printf("inc_count(): thread %ld, count = %d Threshold reached. ", my_id, count); pthread_cond_signal(&amp;count_threshold_cv); printf("Just sent signal.\n"); &#125; printf("inc_count(): thread %ld, count = %d, unlocking mutex\n", my_id, count); pthread_mutex_unlock(&amp;count_mutex); /* Do some work so threads can alternate on mutex lock */ sleep(1); &#125; pthread_exit(NULL);&#125;void *watch_count(void *t) &#123; long my_id = (long)t; printf("Starting watch_count(): thread %ld\n", my_id); /* Lock mutex and wait for signal. Note that the pthread_cond_wait routine will automatically and atomically unlock mutex while it waits. Also, note that if COUNT_LIMIT is reached before this routine is run by the waiting thread, the loop will be skipped to prevent pthread_cond_wait from never returning. */ pthread_mutex_lock(&amp;count_mutex); while (count &lt; COUNT_LIMIT) &#123; printf("watch_count(): thread %ld Count= %d. Going into wait...\n", my_id,count); pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); printf("watch_count(): thread %ld Condition signal received. Count= %d\n", my_id,count); &#125; printf("watch_count(): thread %ld Updating the value of count...\n", my_id); count += 125; printf("watch_count(): thread %ld count now = %d.\n", my_id, count); printf("watch_count(): thread %ld Unlocking mutex.\n", my_id); pthread_mutex_unlock(&amp;count_mutex); pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; int i, rc; long t1=1, t2=2, t3=3; pthread_t threads[3]; pthread_attr_t attr; /* Initialize mutex and condition variable objects */ pthread_mutex_init(&amp;count_mutex, NULL); pthread_cond_init (&amp;count_threshold_cv, NULL); /* For portability, explicitly create threads in a joinable state */ pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;threads[0], &amp;attr, watch_count, (void *)t1); pthread_create(&amp;threads[1], &amp;attr, inc_count, (void *)t2); pthread_create(&amp;threads[2], &amp;attr, inc_count, (void *)t3); /* Wait for all threads to complete */ for (i = 0; i &lt; NUM_THREADS; i++) &#123; pthread_join(threads[i], NULL); &#125; printf ("Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n", NUM_THREADS, count); /* Clean up and exit */ pthread_attr_destroy(&amp;attr); pthread_mutex_destroy(&amp;count_mutex); pthread_cond_destroy(&amp;count_threshold_cv); pthread_exit (NULL);&#125; source output Pthreads的监控，调试和性能分析工具略 LLNL特定信息和建议略 未涵盖的主题Pthreads API有几个功能本教程未涉及. 这些列在下面. 有关详细信息, 请参考Pthread 库函数参考部分. 线程调度 线程调度方式不同实现将导致线程的运行方式上有所不同. 在大多数情况下, 默认机制就足够了. Pthreads API 提供了显式设置线程调度策略和优先级的函数, 这些策略和优先级可能会覆盖默认机制. API 不需要特定的实现来支持这些功能. Keys: 线程特定数据(TSD) 当线程调用不同的函数或从不同的函数中返回时, 线程堆空间上的本地数据不断创建和销毁. 为了保留堆空间上的数据, 你通常需要将其作为参数从一个函数传递到下一个函数, 或者将数据存储在与线程关联的一个全局变量中. Pthread 提供了另一种通过 Keys 实现这个目的的方法, 这种方法可能更方便, 更多用途. 用于处理“优先级倒置”问题的互斥锁 Protocol 属性和互斥锁优先级管理. 条件变量共享 - 跨进程 线程取消(Thread Cancellation) 线程和信号 同步构造 - 屏障(barriers)和锁定 线程练习二互斥锁, 条件变量和带Pthreads的混合MPI 概述: 使用你的用户名和OTP令牌登录一个LC集群 将练习文件复制到家目录 熟悉 LC 的 Pthreads 环境 写一个简单的“Hello World” Pthreads 程序 成功编译程序 成功运行程序 - 使用几种不同的方式 查看, 编译, 运行和/或调试一些相关的 Pthreads 程序(已提供) 在这里练习 参考和更多信息 作者: Blaise Barney, Livermore Computing. POSIX 标准: www.unix.org/version3/ieee_std.html Pthreads Programming. B. Nichols et al. O’Reilly and Associates. Programming With POSIX Threads. D. Butenhof. Addison Wesley Programming With Threads. S. Kleiman et al. Prentice Hall Pthread 库函数参考为方便起见, 下面提供了按字母顺序排列的Pthread函数列表, 并链接到了相应的手册页. pthread_atfork pthread_attr_destroy pthread_attr_getdetachstate pthread_attr_getguardsize pthread_attr_getinheritsched pthread_attr_getschedparam pthread_attr_getschedpolicy pthread_attr_getscope pthread_attr_getstack pthread_attr_getstackaddr pthread_attr_getstacksize pthread_attr_init pthread_attr_setdetachstate pthread_attr_setguardsize pthread_attr_setinheritsched pthread_attr_setschedparam pthread_attr_setschedpolicy pthread_attr_setscope pthread_attr_setstack pthread_attr_setstackaddr pthread_attr_setstacksize pthread_barrier_destroy pthread_barrier_init pthread_barrier_wait pthread_barrierattr_destroy pthread_barrierattr_getpshared pthread_barrierattr_init pthread_barrierattr_setpshared pthread_cancel pthread_cleanup_pop pthread_cleanup_push pthread_cond_broadcast pthread_cond_destroy pthread_cond_init pthread_cond_signal pthread_cond_timedwait pthread_cond_wait pthread_condattr_destroy pthread_condattr_getclock pthread_condattr_getpshared pthread_condattr_init pthread_condattr_setclock pthread_condattr_setpshared pthread_create pthread_detach pthread_equal pthread_exit pthread_getconcurrency pthread_getcpuclockid pthread_getschedparam pthread_getspecific pthread_join pthread_key_create pthread_key_delete pthread_kill pthread_mutex_destroy pthread_mutex_getprioceiling pthread_mutex_init pthread_mutex_lock pthread_mutex_setprioceiling pthread_mutex_timedlock pthread_mutex_trylock pthread_mutex_unlock pthread_mutexattr_destroy pthread_mutexattr_getprioceiling pthread_mutexattr_getprotocol pthread_mutexattr_getpshared pthread_mutexattr_gettype pthread_mutexattr_init pthread_mutexattr_setprioceiling pthread_mutexattr_setprotocol pthread_mutexattr_setpshared pthread_mutexattr_settype pthread_once pthread_rwlock_destroy pthread_rwlock_init pthread_rwlock_rdlock pthread_rwlock_timedrdlock pthread_rwlock_timedwrlock pthread_rwlock_tryrdlock pthread_rwlock_trywrlock pthread_rwlock_unlock pthread_rwlock_wrlock pthread_rwlockattr_destroy pthread_rwlockattr_getpshared pthread_rwlockattr_init pthread_rwlockattr_setpshared pthread_self pthread_setcancelstate pthread_setcanceltype pthread_setconcurrency pthread_setschedparam pthread_setschedprio pthread_setspecific pthread_sigmask pthread_spin_destroy pthread_spin_init pthread_spin_lock pthread_spin_trylock pthread_spin_unlock pthread_testcancel [^1]: 译者注: 这里拥有的意思是当一个互斥变量被锁定时, 锁定的线程占有这个互斥变量的使用权, 其他线程无法使用.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户堆栈扩展]]></title>
    <url>%2F2018-02-13-%E7%94%A8%E6%88%B7%E5%A0%86%E6%A0%88%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 越界访问 中, 对于 do_page_fault() 的分析只进行了部分, 只分析了 find_vma 返回 vma 紧邻其上的区间不是栈区的处理情况. 这里分析一下如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. &emsp;&emsp;当系统为一个进程分配的栈空间已经被使用完, 栈顶指针 %esp 已经指向已映射的栈区区间的开始地址(栈自顶而下分配空间)时, 如果出现新的函数调用, 就需要先将函数的参数入栈到 %esp - 4 的位置, 但是由于栈区区间已经到达开始地址, 再向下就是还没有映射的空洞. 在访问 %esp - 4 时, 就会发生一次页面出错异常. 12345678910111213141516171819202122232425262728293031323334353637383940// arch/i386/mm/fault.c [do_page_fault()] // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; // 内存映射的空洞紧邻其上的是一个栈区区间 // 处于用户模式 if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. * * 访问 %esp 所指向的栈顶之下的空间总是一个 bug. * 由于一些指令(如 pusha)会使 %esp 做递减, 并在更下面的位置, * 所以会 "+ 32" */ // 在参数入栈时一次入栈最多通过 pusha 入栈 32 个字节 // 所以如果访问的位置超出 32 个字节说明访问的页面出错异常不是堆栈扩展造成的 if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; // 本次页面出错异常是堆栈扩展造成的 // 扩展堆栈: expand_stack 建立页面映射并扩展栈区 if (expand_stack(vma, address)) goto bad_area; &emsp;&emsp;出现页面出错异常在 vma 排除其他三种情况(if (!vma), if (vma-&gt;vm_start &lt;= address), if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)))后, 剩下的就是如果内存映射的空洞紧邻其上的是一个栈区区间的处理情况. 这时也分为两种可能: 由于栈区空间被使用完, 栈空间自顶向下扩展时产生的页面出错异常. 由于内存非法越界访问, 访问的地址落入栈空间与堆空间的空洞中. &emsp;&emsp;区分这两种可能是使用访问地址的位置进行判断. 栈空间扩展都是先参数入栈, 然后再开辟栈帧. 当参数入栈时, 通常是一次压入 4 个字节, 这时访问的虚拟地址为 %esp - 4, 但在 i386 CPU 中有一个 pusha 指令, 一次可以将 32 个字节(8 个 32 位寄存器的内容)压入栈空间. 所以如果是栈区扩展产生的页面出错异常那么访问的虚拟地址就会在 %esp - 32 及其以上的区域, 否则访问的地址就会低于 %esp - 32, 出现这种情况的处理方式与 越界访问 中的处理方式相同. &emsp;&emsp;当确认页面出错异常为扩展栈空间的要求时, 就要开始从当前空洞的顶部为栈空间扩展: 建立页面映射, 并将之并入栈区区间(if (expand_stack(vma, address))). 扩展栈区123456789101112131415161718192021222324252627282930// include/linux/mm.h [do_page_fault() &gt; expand_stack()]/* vma is the first one with address &lt; vma-&gt;vm_end, * and even address &lt; vma-&gt;vm_start. Have to extend vma. * * 参数 vma 是第一个 address &lt; vma-&gt;vm_end 甚至 address &lt; vma-&gt;vm_start 的区间. * 必须扩展 vma * */// 将栈区自顶向下扩展static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)&#123; unsigned long grow; // 将地址按照页面边界对齐 address &amp;= PAGE_MASK; // 获取扩展页面数 grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT; // 进程栈空间的大小超过了限制的最大值或进程可用存储区超过了限制的最大长度 if (vma-&gt;vm_end - address &gt; current-&gt;rlim[RLIMIT_STACK].rlim_cur || ((vma-&gt;vm_mm-&gt;total_vm + grow) &lt;&lt; PAGE_SHIFT) &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur) return -ENOMEM; // 扩展栈区 vma-&gt;vm_start = address; vma-&gt;vm_pgoff -= grow; vma-&gt;vm_mm-&gt;total_vm += grow; if (vma-&gt;vm_flags &amp; VM_LOCKED) vma-&gt;vm_mm-&gt;locked_vm += grow; return 0;&#125; &emsp;&emsp;由于系统资源有限, 所以进程对各种资源的使用有限制. 每个进程的 task_struct 结构中都有一个 rlim 结构数组规定了每种资源分配的使用限制. 代码中的 RLIMIT_STACK 限制了栈的最大大小, RLIMIT_AS 限制了进程可用存储区的最大长度(字节). 如果扩展以后栈区大小超过了限制的最大值或者动态分配的页面总量超过了可用于该进程的资源限制, 就不能再扩展了, 返回一个 -ENOMEM 的出错代码. &emsp;&emsp;expand_stack() 函数扩展栈区以页面为单位进行扩展, 只是改变栈区的 vm_area_struct 结构, 并未建立起新扩展的页面对物理内存的映射. &emsp;&emsp;从 expand_stack() 函数中正确返回, 会进入 do_page_fault() 函数的 good_vma 中, 表示访问的地址在一个 vma 中, 这里会根据 error_code 判断页面出错异常出错原因. 1234567891011121314151617181920212223// arch/i386/mm/fault.c [do_page_fault()]/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code) &emsp;&emsp;出现页面出错异常是由于需要压栈, 即数据写入(error_code 中 bit 1 == 1). 已经扩展了 vm_area_struct 但是没有建立物理页面的映射, 即物理页面不存在(error_code 中 bit 0 == 0). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// arch/i386/mm/fault.c [do_page_fault()]/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. * * 对于这次内存访问, 我们有一个好的 vm_area_struct, 因此我们可以处理它.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */ /* 出错指令为读操作, 物理页面在内存中 */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ /* 出错指令为写操作, 物理页面不在内存中 */ // 检查当前 vma 是否可写 if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ /* 出错指令为读操作, 物理页面在内存中 */ goto bad_area; case 0: /* read, not present */ /* 出错指令为读操作, 物理页面不在内存中 */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. * * 如果因为任何原因我们无法处理错误, 请确保我们优雅的退出, 而不是无休止的重复处理错误. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ // 处理与 VM86 模式及 VGA 的图像存储区相关的特殊情况 if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return; &emsp;&emsp;所以 switch (error_code &amp; 3) 时会进入 case 2: 分支检查当前 vm_area_struct 是否可写, 不可写与 越界访问 处理方式相同. 可写进入 handle_mm_fault() 函数. 建立映射123456789101112131415161718192021222324252627282930// mm/memory.c [do_page_fault() &gt; handle_mm_fault()]/* * By the time we get here, we already hold the mm semaphore * * 当我们到达这里, 我们已经有了 mm */// 处理页面映射过程中的错误int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access)&#123; int ret = -1; pgd_t *pgd; pmd_t *pmd; // 获取当前虚拟地址所在的 pgd_t 指针 pgd = pgd_offset(mm, address); // 获取当前虚拟地址所在的 pmd_t 指针 pmd = pmd_alloc(pgd, address); // 如果虚拟地址所在 pmd_t 指针不为空 if (pmd) &#123; // 获取当前虚拟地址所在的 pte_t 指针 pte_t * pte = pte_alloc(pmd, address); // 如果虚拟地址所在 pte_t 指针不为空 if (pte) ret = handle_pte_fault(mm, vma, address, write_access, pte); &#125; return ret;&#125; &emsp;&emsp;先获取虚拟地址所在的页目录项指针. 页目录总是存在的. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; pgd_offset()]/* to find an entry in a page-table-directory. *//* 在页目录中查找虚拟地址所在的页目录项 */// 获取页目录中虚拟地址所在下标#define pgd_index(address) ((address &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))#define __pgd_offset(address) pgd_index(address)// 获取页目录中虚拟地址所在的页目录项的指针#define pgd_offset(mm, address) ((mm)-&gt;pgd+pgd_index(address)) &emsp;&emsp;然后获取虚拟地址所在的中间目录项指针. 由于 i386 CPU 中没有使用 PMD, 所以把页目录项当做只有一个表项的 PMD, 所以 pmd_alloc() 绝对不会执行失败. 所以 handle_mm_fault() 中的 pmd 绝对不会为 0. 12345678910// include/asm-i386/pgalloc-2level.h [do_page_fault() &gt; handle_mm_fault() &gt; pmd_alloc()]// 在中间目录中查找虚拟地址所在的中间目录项// i386 中没有启用 PMD, 把页目录项当做只有一个表项的 PMDextern inline pmd_t * pmd_alloc(pgd_t *pgd, unsigned long address)&#123; if (!pgd) BUG(); return (pmd_t *) pgd;&#125; &emsp;&emsp;其次获取虚拟地址所在的页表项指针. 中间目录项指针有可能指向一个存在的页表, 可以直接获取页表项指针; 也有可能中间目录项为空, 页表不存在, 需要在 getnew 中申请一个新的页表. 一个页表与一个物理页面大小相同, 内核中对页面表的分配作了一些优化. 当释放一个页表时, 内核将释放的页表保存在页表缓存池中, 而不直接释放物理内存页面. 只有在缓存池已满的情况下才真正将页表所占用的物理内存页面释放. 如果页表缓存池中有页表, 就直接获取, 如果没有则使用 get_pte_slow() 获取页表, 这时如果物理内存页面用完, 则需要将长时间没有使用的物理内存页面交换到磁盘上去, 获取页表的速度会很慢. 123456789101112131415161718192021222324252627282930313233// include/asm-i386/pgalloc.h [do_page_fault() &gt; handle_mm_fault() &gt; pte_alloc()]// 在页表中查找虚拟地址所在的页表项// 如果页表不存在则创建页表extern inline pte_t * pte_alloc(pmd_t * pmd, unsigned long address)&#123; // 获取虚拟地址所在物理页面指针在页表中的下标 address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1); // 判断 pmd_t 是否为空 if (pmd_none(*pmd)) goto getnew; // 判断中间目录项权限是否正确 if (pmd_bad(*pmd)) goto fix; return (pte_t *)pmd_page(*pmd) + address;// 获取一个新的页表getnew:&#123; // 从页表缓存池中获取一页页表 unsigned long page = (unsigned long) get_pte_fast(); // 判读是否缓存池已空 if (!page) return get_pte_slow(pmd, address); // 获取页表, 返回给定偏移量位置的页表项指针 // 将获取的页表绑定到中间目录项中 set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(page))); return (pte_t *)page + address;&#125;fix: __handle_bad_pmd(pmd); return NULL;&#125; &emsp;&emsp;最后就是映射到物理页面本身了, 对应到栈区扩展的情况, 物理内存页面还没有分配, 所以物理页面不在内存中, 一定会进入 if (!pte_present(entry)), 对应的页表项也一定会为空, 一定会进入 if (pte_none(entry)). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault()]/* * These routines also need to handle stuff like marking pages dirty * and/or accessed for architectures that don't do it in hardware (most * RISC architectures). The early dirtying is also good on the i386. * * 这些程序也需要处理如硬件体系结构(大部分为 RISC 体系结构)无法做到的设置页面脏和/或已访问. * * There is also a hook called "update_mmu_cache()" that architectures * with external mmu caches can use to update those (ie the Sparc or * PowerPC hashed page tables that act as extended TLBs). * * Note the "page_table_lock". It is to protect against kswapd removing * pages from under us. Note that kswapd only ever _removes_ pages, never * adds them. As such, once we have noticed that the page is not present, * we can drop the lock early. * * The adding of pages is protected by the MM semaphore (which we hold), * so we don't need to worry about a page being suddenly been added into * our VM. */static inline int handle_pte_fault(struct mm_struct *mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t * pte)&#123; pte_t entry; /* * We need the page table lock to synchronize with kswapd * and the SMP-safe atomic PTE updates. */ // 加锁 spin_lock(&amp;mm-&gt;page_table_lock); entry = *pte; // 判断 PTE 的 P 标志位和第 8 位是否设置(查看物理页面是否在内存中) if (!pte_present(entry)) &#123; /* * If it truly wasn't present, we know that kswapd * and the PTE updates will not touch it later. So * drop the lock. * * 如果它确实不存在, 我们知道 kswapd 和 PTE 更新不会稍后不会触及它. * 因此解锁. */ spin_unlock(&amp;mm-&gt;page_table_lock); // 判断 PTE 是否为 0, 是则表示映射还未建立, 否表示映射已经建立 if (pte_none(entry)) return do_no_page(mm, vma, address, write_access, pte); // 如果页表项不为空, 说明物理页面在磁盘上 return do_swap_page(mm, vma, address, pte, pte_to_swp_entry(entry), write_access); &#125; if (write_access) &#123; if (!pte_write(entry)) return do_wp_page(mm, vma, address, pte, entry); entry = pte_mkdirty(entry); &#125; entry = pte_mkyoung(entry); establish_pte(vma, address, pte, entry); spin_unlock(&amp;mm-&gt;page_table_lock); return 1;&#125; &emsp;&emsp;vm_area_struct 中存在一个 vm_operations_struct 结构体(数据结构 中介绍), 这个结构实际上是一个函数跳转表, 结构中通常是一些与文件操作有关的函数指针, 这样, 当通过 mmap() 将一块虚存区间与一个已打开的文件(包括设备)建立映射后, 就可以通对这些函数的操作转化成对文件操作, 或者进行一些必要的对文件的附加操作. 另一方面, 物理页面的盘区交换显然也和文件操作有关. 所以为特定的虚存空间预先指定一些操作是很有必要的. &emsp;&emsp;其中 nopage 用于物理内存页面的分配. 为什么物理内存页面的分配与文件操作有关? 因为这对文件共享很有意义. 当多个进程将同一个文件映射到各自的虚存空间中时, 内存中通常只会保存一份物理页面就可以. 只有当一个进程需要写入该文件时, 才有必要另外复制一份独立的副本, 称为 copy on write 或者 COW(后面进程中关于 fork() 的内容详细介绍). &emsp;&emsp;由于这里是栈区扩展, 与文件系统或页面共享没有关系, 所以不会指定 nopage 操作, 会进入 do_anonymous_page() 函数处理. 123456789101112131415161718192021222324252627// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page()]/* * do_no_page() tries to create a new page mapping. It aggressively * tries to share with existing pages, but makes a separate copy if * the "write_access" parameter is true in order to avoid the next * page fault. * * do_no_page() 尝试创建一个新的页面映射. 它积极尝试与已存在的页面共享, 但是如果 write_access 参数为 true, * 为了避免再次出现页面错误, 它会创建单独的副本. * * As this is called only for pages that do not currently exist, we * do not need to flush old virtual caches or the TLB. * * 仅针对当前不存在的页面调用这个函数, 因此我们不需要刷新就得虚拟缓存或 TLB. * * This is called with the MM semaphore held. */static int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma, unsigned long address, int write_access, pte_t *page_table)&#123; struct page * new_page; pte_t entry; // 如果当前区间没有定义 vm_operation_struct 的函数操作或者没有定义 vm_operation_struct 中缺页时的操作 nopage if (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage) return do_anonymous_page(mm, vma, page_table, write_access, address); &emsp;&emsp;进入 do_anonymous_page() 函数后, 如果引发异常的是读操作就会将页表项指向一个始终为 0 的只读的全局共享物理内存页面; 如果是写操作就会获取一个新的物理页面, 将页表项指向可写的物理内存页面. 1234567891011121314151617181920212223242526272829// mm/memory.c [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page()]/* * This only needs the MM semaphore */static int do_anonymous_page(struct mm_struct * mm, struct vm_area_struct * vma, pte_t *page_table, int write_access, unsigned long addr)&#123; struct page *page = NULL; // 将页表项指向一个始终为 0 的只读的全局共享物理内存页面 mk_pte: 设置页表项中的权限位 pte_t entry = pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot)); // 如果出现异常的指令是写操作 if (write_access) &#123; // 获取一个物理页面 page = alloc_page(GFP_HIGHUSER); if (!page) return -1; clear_user_highpage(page, addr); // 将页表项指向可写的物理内存页面 page entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot))); mm-&gt;rss++; flush_page_to_ram(page); &#125; // 将页表项的值填入一个页表项中. set_pte(page_table, entry); /* No need to invalidate - it was non-present before */ // i386 的 MMU 在 CPU 中, 不需要这个功能, 这里为空函数 update_mmu_cache(vma, addr, entry); return 1; /* Minor fault */&#125; &emsp;&emsp;只要是只读页面, 开始时都会不管其虚拟地址是什么, 直接映射向同一个始终为 0 物理页面 empty_zero_page. 只有是可写页面时才会分配新的独立物理内存. 1234567891011// include/asm-i386/pgtable.h [do_page_fault() &gt; handle_mm_fault() &gt; handle_pte_fault() &gt; do_no_page() &gt; do_anonymous_page() &gt; ZERO_PAGE()]/* * ZERO_PAGE is a global shared page that is always zero: used * for zero-mapped memory areas etc.. * * ZERO_PAGE 是一个始终为 0 的全局共享页面: 用于零映射内存区域等.. */extern unsigned long empty_zero_page[1024];// 获取一个全局共享的初始化为 0 的物理页面#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page)) &emsp;&emsp;栈区扩展是由于写操作异常引起的, 所以会调用 alloc_page() 为其分配新的物理内存页面, 并将分配的物理页面及权限写入页表项中. 至此映射建立完成, 逐层退出函数. 注意&emsp;&emsp;当 CPU 从一次页面出错异常处理返回到用户空间时, 将会先重新执行因映射失败而中断的那条指令, 然后才会继续向下执行, 这是异常处理的特殊性. 中断以及自陷(trap 指令) 发生时, CPU 都会将下一条指令, 也就是接下去本来要执行的指令的地址入栈作为恢复中断服务的返回地址. 而当异常发生时, CPU 将因无法完成(例如除以 0, 映射失败等) 而夭折的指令本身的地址(而不是下一条指令的地址)压入栈, 当从异常处理返回时继续刚刚没有完成的指令. 这个过程是在 CPU 内部电路中实现的, 不需要软件干预. 从这个意义上来讲, 缺页中断 正确的说法应该是 缺页异常. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[越界访问]]></title>
    <url>%2F2018-02-07-%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;页式存储管理机制通过页目录和页表将每个线性地址映射到物理地址. 但是在这个过程中可能存在一些问题导致映射失败, 这时 CPU 就会产生 页面出错异常(Page Fault Exception), 也成 缺页中断, 进而执行预定的页面异常处理程序, 使应用程序从产生异常的指令处恢复执行或进行善后处理. 产生 页面出错异常(Page Fault Exception) 的原因有: 访问的 pgd_t 或 pte_t 为空. 这可能是还未映射或映射已经撤销导致的. 物理页面被交换出内存. 指令的访问方式与页面要求的权限不符. 如修改只读页面. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291// arch/i386/mm/fault.c/* * This routine handles page faults. It determines the address, * and the problem, and then passes it off to one of the appropriate * routines. * * 这个函数处理页面错误. 它确定地址和问题, 然后把错误传递给一个合适的程序. * * error_code: * bit 0 == 0 means no page found, 1 means protection fault * bit 1 == 0 means read, 1 means write * bit 2 == 0 means kernel, 1 means user-mode * * 错误代码: * bit 0 == 0 表示未找到页面, 1 表示保护错误 * bit 1 == 0 表示读取, 1 表示写入 * bit 2 == 0 表示内核, 1 表示用户模式 */// 处理页面错误异常(缺页中断)// struct pt_regs *regs 出现异常时 CPU 各个寄存器值的副本// error_code 指明映射失败原因asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)&#123; // 当前出现异常进程的 task_struct struct task_struct *tsk; // 当前出现异常进程用户空间 mm_struct struct mm_struct *mm; // 当前出现异常进程的出错区间 struct vm_area_struct * vma; // 当前出现异常进程访问的出错地址 unsigned long address; unsigned long page; unsigned long fixup; int write; siginfo_t info; /* get the address */ /* 获取出错地址 */ __asm__("movl %%cr2,%0":"=r" (address)); // 获取 task_struct tsk = current; /* * We fault-in kernel-space virtual memory on-demand. The * 'reference' page table is init_mm.pgd. * * NOTE! We MUST NOT take any locks for this case. We may * be in an interrupt or a critical region, and should * only copy the information from the master page table, * nothing more. */ if (address &gt;= TASK_SIZE) goto vmalloc_fault; // 获取 mm_struct mm = tsk-&gt;mm; info.si_code = SEGV_MAPERR; /* * If we're in an interrupt or have no user * context, we must not take the fault.. * * 如果我们处于中断或没有用户上下文环境的情况下, 我们绝不能处理这种错误. */ // in_interrupt() 返回非零, 说明映射失败发生在某个中断/异常处理程序中, 与当前出现异常进程无关. // mm 为空, 说明当前出现异常进程的映射还没有建立, 与该进程无关. 说明映射发生在某个 in_interrupt() 程序无法检测的某个中断/异常处理程序中. if (in_interrupt() || !mm) goto no_context; // 信号量, 锁住 mm_struct 及其下属的 vm_area_struct, 防止其他进程打扰. down(&amp;mm-&gt;mmap_sem); // 查找当前出现异常进程区间中第一个结束地址大于出错地址的区间 vma = find_vma(mm, address); // 用户程序越界访问系统空间 if (!vma) goto bad_area; // vma-&gt;vm_struct &lt;= address 说明 address 在这个区间中 if (vma-&gt;vm_start &lt;= address) goto good_area; // 虚拟地址处于用户空间, 但是不在任何一个 vm_area_struct 之中 // VM_GROWSDOWN 表示当前 vma 处于栈区 // 紧邻其上的不是是一个栈区区间, 当前异常虚拟地址所在的空间没有建立映射或映射已经被销毁 if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) goto bad_area; if (error_code &amp; 4) &#123; /* * accessing the stack below %esp is always a bug. * The "+ 32" is there due to some instructions (like * pusha) doing post-decrement on the stack and that * doesn't show up until later.. */ if (address + 32 &lt; regs-&gt;esp) goto bad_area; &#125; if (expand_stack(vma, address)) goto bad_area;/* * Ok, we have a good vm_area for this memory access, so * we can handle it.. */good_area: info.si_code = SEGV_ACCERR; write = 0; switch (error_code &amp; 3) &#123; default: /* 3: write, present */#ifdef TEST_VERIFY_AREA if (regs-&gt;cs == KERNEL_CS) printk("WP fault at %08lx\n", regs-&gt;eip);#endif /* fall through */ case 2: /* write, not present */ if (!(vma-&gt;vm_flags &amp; VM_WRITE)) goto bad_area; write++; break; case 1: /* read, present */ goto bad_area; case 0: /* read, not present */ if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) goto bad_area; &#125; /* * If for any reason at all we couldn't handle the fault, * make sure we exit gracefully rather than endlessly redo * the fault. */ switch (handle_mm_fault(mm, vma, address, write)) &#123; case 1: tsk-&gt;min_flt++; break; case 2: tsk-&gt;maj_flt++; break; case 0: goto do_sigbus; default: goto out_of_memory; &#125; /* * Did it hit the DOS screen memory VA from vm86 mode? */ if (regs-&gt;eflags &amp; VM_MASK) &#123; unsigned long bit = (address - 0xA0000) &gt;&gt; PAGE_SHIFT; if (bit &lt; 32) tsk-&gt;thread.screen_bitmap |= 1 &lt;&lt; bit; &#125; up(&amp;mm-&gt;mmap_sem); return;/* * Something tried to access memory that isn't in our memory map.. * Fix it, but check if it's kernel or user first.. * * 尝试访问的内存不在内存映射(vm_area_struct)之中.. * 首先检查当前出现异常进程属于用户还是内核, 然后修复.. */bad_area: // 对于 mm_struct 及其下属 vm_area_struct 的使用完成, 信号量解锁 up(&amp;mm-&gt;mmap_sem);bad_area_nosemaphore: /* User mode accesses just cause a SIGSEGV */ /* 用户模块访问只会导致 SIGSEGV */ // 用户模式 if (error_code &amp; 4) &#123; // 设置当前出现异常进程的 task_struct tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; // 向当前出现异常进程发送一个强制 SIGSEGV 信号, 产生 Segment Fault info.si_signo = SIGSEGV; info.si_errno = 0; /* info.si_code has been set above */ info.si_addr = (void *)address; force_sig_info(SIGSEGV, &amp;info, tsk); return; &#125; /* * Pentium F0 0F C7 C8 bug workaround. */ if (boot_cpu_data.f00f_bug) &#123; unsigned long nr; nr = (address - idt) &gt;&gt; 3; if (nr == 6) &#123; do_invalid_op(regs, 0); return; &#125; &#125;no_context: /* Are we prepared to handle this kernel fault? */ if ((fixup = search_exception_table(regs-&gt;eip)) != 0) &#123; regs-&gt;eip = fixup; return; &#125;/* * Oops. The kernel tried to access some bad page. We'll have to * terminate things with extreme prejudice. */ bust_spinlocks(); if (address &lt; PAGE_SIZE) printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference"); else printk(KERN_ALERT "Unable to handle kernel paging request"); printk(" at virtual address %08lx\n",address); printk(" printing eip:\n"); printk("%08lx\n", regs-&gt;eip); asm("movl %%cr3,%0":"=r" (page)); page = ((unsigned long *) __va(page))[address &gt;&gt; 22]; printk(KERN_ALERT "*pde = %08lx\n", page); if (page &amp; 1) &#123; page &amp;= PAGE_MASK; address &amp;= 0x003ff000; page = ((unsigned long *) __va(page))[address &gt;&gt; PAGE_SHIFT]; printk(KERN_ALERT "*pte = %08lx\n", page); &#125; die("Oops", regs, error_code); do_exit(SIGKILL);/* * We ran out of memory, or some other thing happened to us that made * us unable to handle the page fault gracefully. */out_of_memory: up(&amp;mm-&gt;mmap_sem); printk("VM: killing process %s\n", tsk-&gt;comm); if (error_code &amp; 4) do_exit(SIGKILL); goto no_context;do_sigbus: up(&amp;mm-&gt;mmap_sem); /* * Send a sigbus, regardless of whether we were in kernel * or user mode. */ tsk-&gt;thread.cr2 = address; tsk-&gt;thread.error_code = error_code; tsk-&gt;thread.trap_no = 14; info.si_code = SIGBUS; info.si_errno = 0; info.si_code = BUS_ADRERR; info.si_addr = (void *)address; force_sig_info(SIGBUS, &amp;info, tsk); /* Kernel mode? Handle exceptions or die */ if (!(error_code &amp; 4)) goto no_context; return;vmalloc_fault: &#123; /* * Synchronize this task's top level page-table * with the 'reference' page table. */ int offset = __pgd_offset(address); pgd_t *pgd, *pgd_k; pmd_t *pmd, *pmd_k; pgd = tsk-&gt;active_mm-&gt;pgd + offset; pgd_k = init_mm.pgd + offset; if (!pgd_present(*pgd)) &#123; if (!pgd_present(*pgd_k)) goto bad_area_nosemaphore; set_pgd(pgd, *pgd_k); return; &#125; pmd = pmd_offset(pgd, address); pmd_k = pmd_offset(pgd_k, address); if (pmd_present(*pmd) || !pmd_present(*pmd_k)) goto bad_area_nosemaphore; set_pmd(pmd, *pmd_k); return; &#125;&#125; &emsp;&emsp;代码开始时使用汇编获取 address 是因为 i386 CPU 产生 页面出错异常(Page Fault Exception) 时, 会将访问产生这个错误的虚拟地址放入控制寄存器 CR2 中. 由于 C 语言没有直接读取 CR2 的语句, 所以需要使用汇编进行获取. &emsp;&emsp;对于获取到的 vma 的分析: 进程的内存布局代码段, 数据段, bss段, 堆等自底向上分布, 栈区自顶向下发展, 所以结束地址最高的区间为栈区, 如果访问异常的虚拟地址比最高区间的结束地址还高(find_vma 返回 NULL, if (!vma)), 说明其处于高 1G 的系统空间中. 如果访问异常的虚拟地址大于等于当前区间的其实地址(if (vma-&gt;vm_start &lt;= address)), 说明异常发生在当前区间. 如果访问异常的虚拟地址不在系统空间, 也不再任何一个区间, 说明其处于一个内存映射的空洞中: VM_GROWSDOWN 表示一个区间处于栈区, 如果内存映射的空洞紧邻其上的是一个栈区区间说明空洞是栈区一下的空洞, 这个空洞是供动态分配使用(通过系统调用 brk())但是还没有分配出去的空间. 如果紧邻其上的区间没有设置 VM_GROWSDOWN, 说明空洞是因为一个没有建立映射区间或映射区间已经被销毁的空间. &emsp;&emsp;每次从中断/异常处理程序中返回之前, 都要检查当前进程是否有信号(或称软中断)需要处理, 在 vma 处于最后一种情况时需要处理 SIGSEGV 信号. 内核会根据这些待处理信号的性质以及进程本身的选择进行处理. 有些信号是强制执行, 有些是按照进程设置处理. SIGSEGV 信号需要强制执行, 会是该进程产生 Segment Fault, 然后使进程退出. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018-01-28-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[页面映射结构&emsp;&emsp;页目录 PGD, 中间目录 PMD, 页表 PT 分别是由表项 pgd_t, pmd_t 以及 pte_t 构成的数组. 123456789101112131415161718192021222324252627282930// include/asm-i386/page.h/* * These are used to make use of C type-checking.. * * 这些用于 C 类型检查.. */#if CONFIG_X86_PAE // 三层映射 PAE 模式// PT 表项typedef struct &#123; unsigned long pte_low, pte_high; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low | ((unsigned long long)(x).pte_high &lt;&lt; 32))#else // 两层映射// PT 表项typedef struct &#123; unsigned long pte_low; &#125; pte_t;// PMD 表项typedef struct &#123; unsigned long pmd; &#125; pmd_t;// PGD 表项typedef struct &#123; unsigned long pgd; &#125; pgd_t;// 计算 pte 的值#define pte_val(x) ((x).pte_low)#endif#define PTE_MASK PAGE_MASK// 页面状态信息和访问权限结构体typedef struct &#123; unsigned long pgprot; &#125; pgprot_t; &emsp;&emsp;32 位地址时, pgd_t, pmd_t 和 pte_t 实际上就是长整型. 36 位地址时, 则是 long long 整型. 不直接定义成整型是因为这样可以让 gcc 在编译时加以更严格的类型检查. &emsp;&emsp;所有的物理页面都是 4K 边界对齐, 因此这些表项作为页面的指针一定是 4K 的倍数, 所以指针实际只需要高 20 位, 这高 20 位也可以看做物理页面的下标序号. 所以这些表项的低 12 位就被用于记录页面的状态信息和访问权限. 内核中并没有在表项中定义相关的位段, 而是单独定义用来说明页面保护的结构 pgprot_t. 对 pgprot_t 中位段说明如下: 1234567891011121314// include/asm-i386/pgtable.h#define _PAGE_PRESENT 0x001#define _PAGE_RW 0x002#define _PAGE_USER 0x004#define _PAGE_PWT 0x008#define _PAGE_PCD 0x010#define _PAGE_ACCESSED 0x020#define _PAGE_DIRTY 0x040#define _PAGE_PSE 0x080 /* 4 MB (or 2MB) page, Pentium+, if present.. */#define _PAGE_GLOBAL 0x100 /* Global TLB entry PPro+ */// 对应 pte_t 中第 8 位, Intel 手册指定这一位保留不用, 所以对 MMU 不起作用#define _PAGE_PROTNONE 0x080 /* If not present */ &emsp;&emsp;pgprot_t 设置 pte 低 12 位, 所以总是小于 0x1000, pte 中的指针部分总是大于等于 0x1000, 将二者合在一起就得到实际用于 PT 中的表项. 1234// include/asm-i386/pgtable-2level.h// 为 pte_t 设置 pgprot_t 权限#define __mk_pte(page_nr,pgprot) __pte(((page_nr) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot)) &emsp;&emsp;当 PTE 为 0 时, 表示这个表项所代表的虚拟内存页面没有建立映射. 在映射过程中 MMU 会首先检查 P 标志位, 即 _PAGE_PRESENT, 表示映射的页面是否在内存中. 只有当 P 标志位为 1 时, MMU 才会完成映射的全过程; 如果 PTE 不为 0, P 标志位为 0 时, 表示映射已经建立, 但是所映射的物理页面不在内存中, 会产生一次缺页异常. 物理内存管理结构page 结构&emsp;&emsp;在内核中有个全局的 mem_map 指针, 指向一个 page 结构体的数组, 每个 page 代表一个物理页面, 整个数组代表系统中的所有物理页面. PTE 不仅仅低 12 位为 0 时对于硬件是物理页面的地址, 同时它的高 20 位对于软件也代表这个数组的下标. 1234// include/asm-i386/pgtable-2level.h// 根据 PTE 获取 PTE 指向的物理页面的 page 指针#define pte_page(x) (mem_map+((unsigned long)(((x).pte_low &gt;&gt; PAGE_SHIFT)))) 1234567891011121314151617181920212223242526272829303132// include/linux/mm.h/* * Try to keep the most commonly accessed fields in single cache lines * here (16 bytes or greater). This ordering should be particularly * beneficial on 32-bit processors. * * 尝试在单个缓存线中保留最常访问的字段(16 字节或更大). 这一点对 32 位处理器应该特别有利. * * The first line is data used in page cache lookup, the second line * is used for linear searches (eg. clock algorithm scans). * * 第一行是用于页面缓存的查找的数据, 第二行是用于线性搜索(如时钟算法扫描). */// 物理页面结构体, 代表一个物理页面typedef struct page &#123; struct list_head list; struct address_space *mapping; // 当页面内容来自一个文件时, index 表示该页面在文件中的序号 // 当页面的内容被交换到磁盘上, index 表示页面的去向 unsigned long index; struct page *next_hash; atomic_t count; unsigned long flags; /* atomic flags, some possibly updated asynchronously */ /* 原子标志, 有可能异步更新 */ struct list_head lru; unsigned long age; wait_queue_head_t wait; struct page **pprev_hash; struct buffer_head * buffers; void *virtual; /* non-NULL if kmapped */ struct zone_struct *zone;&#125; mem_map_t; &emsp;&emsp;page 结构中各个成分的次序是有讲究的, 目的是尽量使得联系紧密的若干成分在执行是被装填入高速缓存的同一缓冲线(16个字节)中. 系统在初始化时会创建一个由 page(或 mem_map_t) 组成的 mem_map 数组, 每个 page 代表系统中的一个物理页面, 物理页面初始地址的高 20 位就是对应 page 的下标. zone_struct 结构&emsp;&emsp;mem_map 中的所有物理页面被划分成 ZONE_DMA 和 ZONE_NORMAL 两个管理区(也有可能存在第三个 ZONE_HIGHMEM). ZONE_DMA 中管理的是专供 DMA 使用的内存页. 为什么供 DMA 使用的页面要单独加以管理? DMA 使用的页面需要进行磁盘 I/O, 单独管理防止内存页面全部被分配出去无法进行页面与盘区的交换. 在 i386 中 MMU 存在于 CPU 中, DMA 不经过 MMU 的地址映射, 外设直接访问物理内存, 但是部分外设访问物理内存地址较小. DMA 所需的内存当超过 4K 时, 需要连续的物理内存页面, 无法使用 MMU 提供的连续的虚拟内存页面. &emsp;&emsp;每个管理区由 none_struct 结构创建, 一旦创建成功, 每个物理页面就永久属于一个管理区. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// include/linux/mmzone.h/* * Free memory management - zoned buddy allocator. * * 空闲内存管理 - zoned buddy allocator. */// free_area_struct 链接的最大内存块为 2 ^ MAX_ORDER#define MAX_ORDER 10typedef struct free_area_struct &#123; // 双向链表 struct list_head free_list; unsigned int *map;&#125; free_area_t;struct pglist_data;// 管理区结构体typedef struct zone_struct &#123; /* * Commonly accessed fields: * * 常用字段 */ spinlock_t lock; // 当前管理区在 mem_map 中的起始位置(页面序号) unsigned long offset; unsigned long free_pages; unsigned long inactive_clean_pages; unsigned long inactive_dirty_pages; unsigned long pages_min, pages_low, pages_high; /* * free areas of different sizes * * 不同大小的空闲空间 */ struct list_head inactive_clean_list; // 数组中每个成员都是由双向链表连接起来的内存块的链表指针, 每个成员中内存块都是由 2 ^ n 个物理页面组成(1 &lt;= n &lt;= MAX_ORDER, MAX_ORDER = 10). free_area_t free_area[MAX_ORDER]; /* * rarely used fields: * * 很少使用的字段 */ char *name; unsigned long size; /* * Discontig memory support fields. */ // 指向当前 node 节点的管理结构 pglist_data(下一小节介绍) struct pglist_data *zone_pgdat; unsigned long zone_start_paddr; unsigned long zone_start_mapnr; struct page *zone_mem_map;&#125; zone_t;// 管理区类型#define ZONE_DMA 0#define ZONE_NORMAL 1#define ZONE_HIGHMEM 2// 管理区最大数量#define MAX_NR_ZONES 3 pglist_data 结构&emsp;&emsp;计算机内存系统存在两种结构. 均质存储结构(Uniform Memory Architecture) 指计算机中所有物理内存地位均等, 访问任意物理内存消耗时间相同, 简称 UMA. 非均质存储结构(Non-Uniform Memory Architecture) 指计算机中物理内存地址虽然是连续的, 但是却分为不同的模块, 访问速度不同, 消耗的时间也不同, 简称 NUMA. &emsp;&emsp;在真实的计算机系统中, 绝对的 UMA 是不存在的. 真正的系统会存在不同的内存模块, 如多级高速缓存, RAM, ROM, 显存等. Linux 内核从 2.4.0 版本开始支持 NUMA. 在 NUMA 结构的系统中, 分配连续多个物理内存页面要求分配在质地相同的区间(称为 node, 即 节点). 这里的 node 对应到 Linux 系统中就是 pglist_data 结构. 这时 mem_map 数组将不再管理整个物理内存, 而是管理当前 node 中的物理页面. 而 zone_struct 则表示当前 node 中的管理区. 在 zone_struct 和 mem_map 之上则是 pglist_data 结构, 管理整个存储节点. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mmzone.h/* * One allocation request operates on a zonelist. A zonelist * is a list of zones, the first one is the 'goal' of the * allocation, the other zones are fallback zones, in decreasing * priority. * * 一个分配请求在一个 zonelist(管理区列表) 上运行. 一个 zonelist 是 zone 的列表, * 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. * * Right now a zonelist takes up less than a cacheline. We never * modify it apart from boot-up, and only a few indices are used, * so despite the zonelist table being relatively big, the cache * footprint of this construct is very small. * * 现在一个 zonelist 占用的空间比一个缓存线小. * 除非在启动时, 否则我们从不修改它, 并且只有少数索引被使用, 因此尽管 zonelist 表相对较大(0x100(256) 项), * 但是构造它的缓存空间是非常小的. */typedef struct zonelist_struct &#123; // zone_struct 管理区, 类型相同(猜测), 第一个管理区是分配的 'goal`(目标), 剩下管理区是后备区域, 优先级依次降低. zone_t * zones [MAX_NR_ZONES+1]; // NULL delimited int gfp_mask;&#125; zonelist_t;// zonelist 数组最大长度#define NR_GFPINDEX 0x100struct bootmem_data;typedef struct pglist_data &#123; // 当前 node 的 zone_struct 管理区, 最大为 3 个 zone_t node_zones[MAX_NR_ZONES]; // zonelist 表, 规定最多 0x100(256) 中内存分配策略 zonelist_t node_zonelists[NR_GFPINDEX]; // 指向当前 node 的 mem_map 数组 struct page *node_mem_map; unsigned long *valid_addr_bitmap; struct bootmem_data *bdata; unsigned long node_start_paddr; unsigned long node_start_mapnr; unsigned long node_size; int node_id; // 单向链表, 指向下一个 pglist_data 节点 struct pglist_data *node_next;&#125; pg_data_t; 虚拟内存管理结构vm_area_struct 结构&emsp;&emsp;在虚拟内存中, 以进程为基础分为两个部分: 系统空间 和 用户空间. 系统空间 为所有进程共享; 用户空间 为每个进程私有. 其中 用户空间 中的各个部分未必是连续的, 通常形成许多分散的虚拟内存区间. Linux 内核中 vm_area_struct 就表示这些虚拟内存区间, 使用单链表将所有区间连接, 同时为了提高搜索效率, 在区间数量增大到 32 时(&gt;=), 会创建 AVL 树. 在Linux内核中 vm_area_struct 的变量名常常是 vma. vm_area_struct 的划分不仅仅取决于地址的连续性, 还要求同一 vm_area_struct 中的虚拟内存具有相同访问权限(vm_page_prot)和其他一些属性(vm_flags). &emsp;&emsp;同时 vm_area_struct 还会与磁盘文件发生交互: 盘去交换(swap): 指在物理内存页面不够分配时, 一些长时间不用的内存交换到磁盘上, 腾出物理页面以供应急. 这就是一般意义上的 &quot;按需调度&quot;页式虚存管理(demand paging). 系统调用 mmap(): 可以将一个打开的文件映射到用户空间中, 使进程像访问内存中的字符数组一样访问文件中的数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// include/linux/mm.h/* * This struct defines a memory VMM memory area. There is one of these * per VM-area/task. A VM area is any part of the process virtual memory * space that has a special rule for the page-fault handlers (ie a shared * library, the executable area etc). */struct vm_area_struct &#123; // 当前 vm_area_struct 所在进程用户空间的管理结构 mm_struct(下一小节介绍) struct mm_struct * vm_mm; /* VM area parameters */ // vm_area_struct 起始地址, 包含在 vm_area_struct 中 unsigned long vm_start; // vm_area_struct 结束地址, 不包含在 vm_area_struct 中 unsigned long vm_end; /* linked list of VM areas per task, sorted by address */ // 单链表, 每个进程的 vm_area_struct 按照地址高低依次链接 struct vm_area_struct *vm_next; // vm_area_struct 访问权限 pgprot_t vm_page_prot; // vm_area_struct 属性 unsigned long vm_flags; /* AVL tree of VM areas per task, sorted by address */ // AVL 树, 每个进程的 vm_area_struct 按照地址高低组成 AVL 树, 便于查找 short vm_avl_height; struct vm_area_struct * vm_avl_left; struct vm_area_struct * vm_avl_right; /* For areas with an address space and backing store, * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists, * for shm areas, the list of attaches, otherwise unused. */ // 记录, 管理 vm_area_struct 与磁盘文件交互 struct vm_area_struct *vm_next_share; struct vm_area_struct **vm_pprev_share; // 定义了 vm_area_struct 操作执行函数指针, 包括打开, 关闭, 缺页时建立映射 struct vm_operations_struct * vm_ops; unsigned long vm_pgoff; /* offset in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */ struct file * vm_file; unsigned long vm_raend; void * vm_private_data; /* was vm_pte (shared mem) */&#125;; 123456789101112131415// include/linux/mm.h/* * These are the virtual MM functions - opening of an area, closing and * unmapping it (needed to keep files on disk up-to-date etc), pointer * to the functions called when a no-page or a wp-page exception occurs. */struct vm_operations_struct &#123; // vma 打开操作 void (*open)(struct vm_area_struct * area); // vma 关闭操作 void (*close)(struct vm_area_struct * area); // vma 中产生缺页异常时建立映射操作 struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int write_access);&#125;; mm_struct 结构&emsp;&emsp;在 vm_area_struct 结构中存在指向 mm_struct 结构的指针, mm_struct 是整个进程用户空间的管理结构, 在内核中的变量名常常为mm, 比 vm_area_struct 更高一个层次, 对 vm_area_struct 进行管理. 每一个进程控制块即 task_struct 结构中都有一个指向当前进程 mm_struct 结构的指针. 虽然每个进程都只有一个 mm_struct 结构, 但是一个 mm_struct 结构可以被多个进程共用, 如 vfork() 的父子进程共享一个 mm_struct 结构. 123456789101112131415161718192021222324252627282930313233// include/linux/sched.hstruct mm_struct &#123; struct vm_area_struct * mmap; /* list of VMAs */ /* vma 链表 */ struct vm_area_struct * mmap_avl; /* tree of VMAs */ /* vma AVL 树 */ struct vm_area_struct * mmap_cache; /* last find_vma result */ /* find_vma 返回的结果 ,即上一次访问的 vma */ // pgd 指针 pgd_t * pgd; // atomic_t 原子操作整数 atomic_t mm_users; /* How many users with user space? */ atomic_t mm_count; /* How many references to "struct mm_struct" (users count as 1) */ int map_count; /* number of VMAs */ /* 当前 mm_struct 中 vma 的数量 */ // P, V 操作信号量. 使对 mm_struct 及下属 vm_area_struct 的访问互斥 struct semaphore mmap_sem; // 类似 mmap_sem spinlock_t page_table_lock; // 双向链表 struct list_head mmlist; /* List of all active mm's */ /* 所有存活 mm_struct 组成的链表 */ // 代码段, 数据段起始地址和终止地址 unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; unsigned long rss, total_vm, locked_vm; unsigned long def_flags; unsigned long cpu_vm_mask; unsigned long swap_cnt; /* number of pages to swap on next pass */ unsigned long swap_address; /* Architecture-specific MM context */ mm_context_t context;&#125;; &emsp;&emsp;CPU 实际进行的映射并不涉及 mm_struct 结构, 而是像 地址映射 中讲的那样通过 PGD 和 PT 进行, 但是 mm_struct 结构描述了这种映射. &emsp;&emsp;通过 mm_struct 结构查找给定虚拟地址所在的 vma: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// mm/mmap.c/* Look up the first VMA which satisfies addr &lt; vm_end, NULL if none. *//* 查找满足 addr &lt; vm_end 的 vma, 没有则返回 NULL */// 给出一个虚拟地址, 查找对应用户空间 mm 中第一个虚拟地址大于其结束地址的 vma// 返回 NULL 表示该虚拟地址所在区间还未创建struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr)&#123; struct vm_area_struct *vma = NULL; if (mm) &#123; /* Check the cache first. */ /* 实现检查缓存 */ /* (Cache hit rate is typically around 35%.) */ /* 缓存命中率大约为 35% */ vma = mm-&gt;mmap_cache; // 如果不在缓存中 if (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123; // 如果没有建立 AVL 树 if (!mm-&gt;mmap_avl) &#123; /* Go through the linear list. */ /* 通过线性链表查找 */ vma = mm-&gt;mmap; while (vma &amp;&amp; vma-&gt;vm_end &lt;= addr) vma = vma-&gt;vm_next; &#125; else &#123; /* Then go through the AVL tree quickly. */ /* 建立了 AVL 树, 通过 AVL 树快速查找 */ struct vm_area_struct * tree = mm-&gt;mmap_avl; vma = NULL; for (;;) &#123; if (tree == vm_avl_empty) break; if (tree-&gt;vm_end &gt; addr) &#123; vma = tree; if (tree-&gt;vm_start &lt;= addr) break; tree = tree-&gt;vm_avl_left; &#125; else tree = tree-&gt;vm_avl_right; &#125; &#125; if (vma) mm-&gt;mmap_cache = vma; // 将当前查到的 vma 保存到缓存中. &#125; &#125; return vma;&#125; &emsp;&emsp;在创建一个新的 vm_area_struct 将其插入 mm_struct 时, 会调用 insert_vm_struct() 函数, 在这里加了两把锁, 第一把加在新区间 vm_area_struct 上, 第二把加在代表整个虚拟空间的 mm_struct 结构中, 使得操作过程中不让其他进程能够中途也能对这两个数据结构进行修改. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// mm/mmap.c/* Insert vm structure into process list sorted by address * and into the inode's i_mmap ring. If vm_file is non-NULL * then the i_shared_lock must be held here. */void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; struct vm_area_struct **pprev; struct file * file; // 如果没有创建 AVL 树 if (!mm-&gt;mmap_avl) &#123; // 在单链表中查找 pprev = &amp;mm-&gt;mmap; while (*pprev &amp;&amp; (*pprev)-&gt;vm_start &lt;= vmp-&gt;vm_start) pprev = &amp;(*pprev)-&gt;vm_next; &#125; else &#123; // 已经创建 AVL 树, 插入 AVL 树 struct vm_area_struct *prev, *next; avl_insert_neighbours(vmp, &amp;mm-&gt;mmap_avl, &amp;prev, &amp;next); pprev = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap); if (*pprev != next) printk("insert_vm_struct: tree inconsistent with list\n"); &#125; // 将新的 vm_area_struct 加入单链表 vmp-&gt;vm_next = *pprev; *pprev = vmp; // mm_struct 中 vm_area_struct 总数++ mm-&gt;map_count++; // 当 mm_struct 中 vm_area_struct 数量达到 AVL_MIN_MAP_COUNT(32) 且没有创建 AVL 树时, 创建 vm_area_struct 的 AVL 树 if (mm-&gt;map_count &gt;= AVL_MIN_MAP_COUNT &amp;&amp; !mm-&gt;mmap_avl) build_mmap_avl(mm); // 文件映射相关操作 file = vmp-&gt;vm_file; if (file) &#123; struct inode * inode = file-&gt;f_dentry-&gt;d_inode; struct address_space *mapping = inode-&gt;i_mapping; struct vm_area_struct **head; if (vmp-&gt;vm_flags &amp; VM_DENYWRITE) atomic_dec(&amp;inode-&gt;i_writecount); head = &amp;mapping-&gt;i_mmap; if (vmp-&gt;vm_flags &amp; VM_SHARED) head = &amp;mapping-&gt;i_mmap_shared; /* insert vmp into inode's share list */ if((vmp-&gt;vm_next_share = *head) != NULL) (*head)-&gt;vm_pprev_share = &amp;vmp-&gt;vm_next_share; *head = vmp; vmp-&gt;vm_pprev_share = head; &#125;&#125;// 将一个新创建的 vm_area_struct 结构插入当前用户空间的 mm_struct 中void insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vmp)&#123; // 加在 vm_area_struct 上的第一把锁, 防止插入过程中其他进程修改当前的 vm_area_struct lock_vma_mappings(vmp); // 加在 mm_struct 上的第二把锁, 防止插入过程中其他进程修改当前的 mm_struct spin_lock(&amp;current-&gt;mm-&gt;page_table_lock); __insert_vm_struct(mm, vmp); spin_unlock(&amp;current-&gt;mm-&gt;page_table_lock); unlock_vma_mappings(vmp);&#125; 总结 &emsp;&emsp;mm_struct 及其下属 vm_area_struct 只是说明了对虚拟内存的需求, 一个虚拟内存有相应的区间存在并不保证其所在的页面已经映射到了一个物理(物理内存或磁盘)页面, 更不保证该页面就在内存中. 总结&emsp;&emsp;mm_struct 和 vm_area_struct 说明了对页面的需求; page, zone_struct 和 pglist_data 说明了对页面的供应; PGD, PMD 和 PT 则是二者之间的桥梁. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地址映射]]></title>
    <url>%2F2018-01-23-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux 采用页式内存管理. 优点: 页面固定大小, 便于管理. 灵活度高, 在将内存交换到磁盘上时, 按内存页进行交换. 页式内存管理有内部碎片, 无外部碎片. &emsp;&emsp;即使 i386 CPU 在硬件上限制必须先段式再页式的映射方式, Linux 也是避开了段式映射, 在 Linux 内存映射时(除用来模拟80286的 VM86模式), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. 当然 i386 存在段式映射是有历史原因的, 对于其他 CPU 来说就不存在这一层了. 段式映射&emsp;&emsp;在获取到一个虚拟地址后, 首先确定其属于进程的哪一段内存, 然后获取相应内存段的段寄存器中的值. Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段. 1234567891011121314// include/asm-i386/processor.h// 创建进程时设置对应进程的段寄存器和栈顶,栈底寄存器// Linux 在实现时没有区分除代码段以外的其他各内存段, 统一设置为数据段.#define start_thread(regs, new_eip, new_esp) do &#123; \ __asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0)); \ set_fs(USER_DS); \ regs-&gt;xds = __USER_DS; \ regs-&gt;xes = __USER_DS; \ regs-&gt;xss = __USER_DS; \ regs-&gt;xcs = __USER_CS; \ regs-&gt;eip = new_eip; \ regs-&gt;esp = new_esp; \&#125; while (0) 12345678910111213141516// include/asm-i386/segment.h#ifndef _ASM_SEGMENT_H#define _ASM_SEGMENT_H// 内核代码段寄存器初始值#define __KERNEL_CS 0x10// 内核数据段寄存器初始值#define __KERNEL_DS 0x18// 用户进程代码段寄存器初始值#define __USER_CS 0x23// 用户进程数据段寄存器初始值#define __USER_DS 0x2B#endif &emsp;&emsp;这里需要介绍一下段寄存器, RPL 为所要求的特权级别, 共分为 4 级, 00 为最高权限, 11 为最低权限, Linux 在实现时只使用了这两个级别. TI 为 0 时表示使用 GDT, 为 1 时表示使用 LDT. Index 表示对应段描述符表的下标. &emsp;&emsp;通过之前介绍, 解析 Linux 段寄存器初始值: &emsp;&emsp;TI 值均为 0, 说明都是 GDT, 没有使用 LDT, 在 Linux 中 LDT 只在 VM86模式 下使用. RPL 内核使用 00 级, 普通进程使用 11 级. index 为固定值. &emsp;&emsp;在 Linux 实现时会将 GDT 初始化为固定的值, GDT 第一项(下标为 0)会初始化为 0x0000000000000000, 这是为了防止加电后段寄存器未经初始化就进入保护模式并使用 GDT. 第 2 ~ 5 项对应之前四中段寄存器. 12345678910111213141516171819202122// arch/i386/kernel/head.S/* * This contains typically 140 quadwords, depending on NR_CPUS. * * 这通常包含140个四字(64位), 取决于NR_CPUS. * * NOTE! Make sure the gdt descriptor in head.S matches this if you * change anything. * * 注意! 如果你改变任何东西, 请确保 head.S 中的 gdt 描述符与此匹配. */// 初始化 GDTENTRY(gdt_table) .quad 0x0000000000000000 /* NULL descriptor */ .quad 0x0000000000000000 /* not used */ .quad 0x00cf9a000000ffff /* 0x10 kernel 4GB code at 0x00000000, __KERNEL_CS 指向的空间 */ .quad 0x00cf92000000ffff /* 0x18 kernel 4GB data at 0x00000000, __KERNEL_DS 指向的空间 */ .quad 0x00cffa000000ffff /* 0x23 user 4GB code at 0x00000000, __USER_CS 指向的空间 */ .quad 0x00cff2000000ffff /* 0x2b user 4GB data at 0x00000000, __USER_DS 指向的空间 */ .quad 0x0000000000000000 /* not used */ .quad 0x0000000000000000 /* not used */ 将 2 ~ 5 项按照二进制展开: 再按照段描述符表项内容进行分析: 相同: B0~B15, B16~B31 都是 0. 段基址全为 0. L0~L15, L16~L19 都是 1. 段长度全为 0xfffff. G 位都是 1. 段长度单位均为 4KB. D 位都是 1. 对四个段的访问指令都是 32 位指令. P 位都是 1. 四个段都在内存中. 结论: 每个段都是从 0 地址开始的整个 4G 虚拟空间, 虚拟地址到线性地址的映射保持原值不变. 不同: __KERNEL_CS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __KERNEL_DS : DPL = 0, 表示 0 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. __USER_CS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 1010, 表示代码段, 可读, 可执行, 尚未受到访问. __USER_DS : DPL = 3, 表示 3 级; S 位为 1, 表示代码段或数据段; type 为 0010, 表示数据段, 可读, 可执行, 尚未受到访问. 页式映射&emsp;&emsp;每个进程都有其自身的页目录 PGD, 指向这个目录的指针保存在每个进程的 mm_struct 数据结构(数据结构中介绍)中. 每当一个进程运行时, 内核都要为其设置控制寄存器 CR3, 而 MMU 的硬件总是从 CR3 中取得指向当前页目录的指针. CPU 在执行过程中使用的是虚拟地址, 而 MMU 硬件在进行映射时使用的是物理地址, 这其中的计算则是通过 基本框架 中介绍的 __ps 进行计算的. 这里存在一个问题: 使用不同的页目录, 不会使程序不能连续执行吗? 答案是不会. 因为所有进程的 PGD 对系统空间的 1G 空间映射完全相同. &emsp;&emsp;在获取到 PGD 地址后获取线性地址的最高 10 位作为下标, 在这个 PGD 表项中保存着 PT 的地址. 然后将线性地址接下来的 10 位作为 PT 的下标, 获取到对应的物理页面地址. 线性地址的最低 12 位为物理页面中的偏移量, 就是线性地址在物理内存中的地址. &emsp;&emsp;在页面映射的过程中, i386 CPU 需要访问三次内存. 第一次访问 PGD, 第二次访问 PT, 第三次才是真正的目标. 所以高效的虚拟内存有赖于两方面: 高速缓存(cache)的实现. 除第一次访问需要这三步, 之后就可以在高速缓存中找到. 这个过程由硬件实现, 速度很快. 本文整理自《Linux内核源代码情景分析》]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本框架]]></title>
    <url>%2F2018-01-23-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[i386 内存映射&emsp;&emsp;i386 CPU中采用的页式内存管理, 基本思路是：通过页目录和页表两层实现线性地址到物理地址的映射. 优点: 大多数情况下可以节省页表所占的内存空间。当页表为空时只需要将对应页目录项置为空，就可以节省对相应页表的空间. 缺点: 适用最大内存为 4G 的内存. Linux 内存映射&emsp;&emsp;由于 Linux 需要考虑不同CPU上的实现, 所有需要设计出一种通用的内存映射模型模型. Linux 内核的映射机制设计成三层, 在 i386 的页目录和页表的基础上在中间增设了一层”中间目录”. 在源码中, 页目录称为 PGD, 中间目录称为 PMD, 页表称为 PT. 三者均为数组. 相应的逻辑上也将线性地址由高到低分为四个段位, 分别作用于页目录 PGD 的下标, 中间目录 PMD 的下标, 页表 PT 的下标以及物理页面中的位移. &emsp;&emsp;对于 i386 中的段式内存映射在 Linux 内存映射时(除用来模拟80286的 VM86模式[^1]), 段式映射的基址总是 0, 所以线性地址与虚拟地址总是一致, 相当于没有使用段式内存映射. i386 在 Pentium Pro 开始引入了物理地址扩充功能 PAE, 可以将地址宽度从32位上升为36位. 所以在 Linux 的内存映射模型对应到 i386 CPU时, 如果设置了 PAE 则使用三层映射, 否则跳过中间的 PMD 层次, 使用两层映射. 123456789101112131415161718192021222324// include/asm-i386/pgtable.h/* * The Linux x86 paging architecture is 'compile-time dual-mode', it * implements both the traditional 2-level x86 page tables and the * newer 3-level PAE-mode page tables. * * Linux x86 分页架构是'编译时双模式', 它实现了传统两层 x86 页表和新的三层 PAE 模式页表两种映射方式. */#ifndef __ASSEMBLY__#if CONFIG_X86_PAE // 编译时设置# include &lt;asm/pgtable-3level.h&gt; // PAE模式三层映射#else# include &lt;asm/pgtable-2level.h&gt; // 两层映射#endif#endif#define __beep() asm("movb $0x3,%al; outb %al,$0x61")#define PMD_SIZE (1UL &lt;&lt; PMD_SHIFT)#define PMD_MASK (~(PMD_SIZE-1))// 每个页目录项所指向空间的大小#define PGDIR_SIZE (1UL &lt;&lt; PGDIR_SHIFT)#define PGDIR_MASK (~(PGDIR_SIZE-1)) 12345678910111213141516171819202122// include/asm-i386/pgtable-2level.h/* * traditional i386 two-level paging structure: * 传统 i386 两层分页结构 */// PGD 数组的下标在线性地址中的起始位置, 即线性地址的 23 ~ 32 位(从 0 开始)#define PGDIR_SHIFT 22// 每个 PGD 中的指针数, 即 PGD 中页目录项的数量, i386 中指针所用空间为 4 个字节, 则 PGD 所占空间为 1024 * 4 = 4KB#define PTRS_PER_PGD 1024/* * the i386 is two-level, so we don't really have any * PMD directory physically. * * 因为 i386 是两层分页结构, 所以我们不会有真正物理上的 PMD 目录. */// PMD 数组的下标在线性地址中的起始位置, 与 PGDIR_SHIFT 相同, 即 PMD 在线性地址中不存在, 长度为 0#define PMD_SHIFT 22// 每个 PMD 中的指针数, 只有 1 个, 直接指向 PT#define PTRS_PER_PMD 1 &emsp;&emsp;32位地址意味着4G字节的虚存空间, Linux 内核将这4G字节的空间分成两个部分. 将最高的1G字节(从虚拟地址 0xC0000000 至 0xFFFFFFFF), 用于内核本身, 称为系统空间. 而将较低的3G字节(从虚拟地址 0x00000000 至 0xBFFFFFFF), 用作各个进程的用户空间, 理论上每个进程拥有独立的3G字节的用户空间. 系统空间是所有进程逻辑上共用的1G字节空间, 每一个进程通过系统调用从用户空间进入内核, 在系统空间中运行. 即每一个进程都拥有4G的虚拟空间, 较低的3G虚拟空间独立使用, 最高的1G虚拟空间与所用进程及内核共享. 这里独立的虚拟空间只是在逻辑上独立, 但是在物理上所有的进程共用3G的物理内存. &emsp;&emsp;系统空间在虚拟内存中占据最高的1G空间, 但是在物理内存中却是从最低地址(0)开始, 处于最低1G空间. 123456789101112131415161718192021222324// include/asm-i386/page.h/* * This handles the memory map.. We could make this a config * option, but too many people screw it up, and too few need * it. * * 这里处理内核的内存映射. 我们可以将其设置为配置选项, 但是有许多人搞砸它, 并且很少需要它. * * A __PAGE_OFFSET of 0xC0000000 means that the kernel has * a virtual address space of one gigabyte, which limits the * amount of physical memory you can use to about 950MB. * * 值为 0xC0000000 的 __PAGE_OFFSET 意味着内核有 1GB 的虚拟空间, 这限制了可以内核使用的物理空间大约 950MB. * * If you want more physical memory than this then see the CONFIG_HIGHMEM4G * and CONFIG_HIGHMEM64G options in the kernel configuration. * * 如果你想要超过这些的物理内存, 请参阅内核配置中的 CONFIG_HIGHMEM4G * 和 CONFIG_HIGHMEM64G 选项 */// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define __PAGE_OFFSET (0xC0000000) 12345678// include/asm-i386/page.h// 系统空间在物理内存(从 0 开始)和在虚拟内存(从 0xC0000000 开始)中位置的偏移量, 同时也表示用户空间大小.#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)// 计算系统空间在虚拟内存中对应物理空间中的地址#define __pa(x) ((unsigned long)(x)-PAGE_OFFSET)// 计算系统空间在物理内存中对应虚拟空间中的地址#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET)) 123456789// include/asm-i386/processor.h/* * User space process size: 3GB (default). * * 用户空间进程大小: 3GB(默认) */// 用户空间进程大小.#define TASK_SIZE (PAGE_OFFSET) 本文整理自《Linux内核源代码情景分析》 [^1]: VM86模式 是为采用保护模式的系统提供 实模式(real-mode) 软件的兼容性, 用来在保护模式下模拟运行实模式的软件.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[etcd gateway]]></title>
    <url>%2F2018-01-02-etcd_gateway.html</url>
    <content type="text"><![CDATA[翻译自: etcd gateway etcd gateway 是什么?etcd gateway 是一个简单的转发网络数据到 etcd 集群的 TCP 代理. 这个 gateway 是无状态的, 透明的; 它既不检查客户端的请求, 也不干涉 etcd 集群的响应.这个 gateway 支持多 etcd 服务端点, 遵循简单的循环策略连接端点. 它只路由到可用的端点, 且对连接到它上的客户端隐藏 etcd 服务端点的故障. 其他的重试策略(如加权循环)在将来可能会得到支持. 什么时候使用 etcd gateway?每个访问 etcd 的应用必须首先拥有 etcd 集群的地址. 如果是同一台服务器上的多个应用访问同一个 etcd 集群, 每个应用仍然需要知道这个 etcd 集群公布的地址. 如果这个 etcd 集群重新配置为拥有不同端点的集群, 则每个应用程序可能还需要更新其端点列表. 这种大规模的重新配置既枯燥又容易出错. etcd gateway 通过作为一个稳定的本地端点提供服务解决了这个问题. 一个典型的 etcd gateway 配置是让每一个机器运行一个监听本地端口的 gateway, 同时每一个 etcd 应用连接到这个本地 gateway. 这样在 etcd 集群重新配置时只有 gateway 需要更新它的端点配置, 而不是更新每一个应用. 总之, 为了自动传播 etcd 集群端点更改, etcd gateway 应该运行在为访问同一个 etcd 集群的多个应用程序提供服务的每台机器上. 什么时候不应该使用 etcd gateway? 提高性能gateway 不是为了提高 etcd 集群性能而设置. 它不提供缓存, watch 的合并或批处理. etcd 团队正在开发一个旨在提高集群可扩展性的缓存代理. 在集群管理系统上运行高级集群管理系统(如 Kubernetes) 本身支持服务发现, 应用程序可以使用有系统管理的 DNS 名称或虚拟 IP 地址访问 etcd 集群. 例如: kube-proxy等同于etcd网关. 启动 etcd gateway考虑一个具有以下静态端点的 etcd 集群: Name Address Hostname infra0 10.0.1.10 infra0.example.com infra1 10.0.1.11 infra1.example.com infra2 10.0.1.12 infra2.example.com 使用包含这些静态端点的命令启动etcd gateway:12$ etcd gateway start --endpoints=infra0.example.com,infra1.example.com,infra2.example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 或者, 如果使用 DNS 进行服务发现, 请考虑 DNS SRV 条目:1234$ dig +noall +answer SRV _etcd-client._tcp.example.com_etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra0.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra1.example.com._etcd-client._tcp.example.com. 300 IN SRV 0 0 2379 infra2.example.com. 1234$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.cominfra0.example.com. 300 IN A 10.0.1.10infra1.example.com. 300 IN A 10.0.1.11infra2.example.com. 300 IN A 10.0.1.12 使用以下命令从 DNS SRV 条目获取端点启动 etcd gateway:12$ etcd gateway --discovery-srv=example.com2016-08-16 11:21:18.867350 I | tcpproxy: ready to proxy client requests to [...] 配置选项etcd 集群–endpoints 逗号分隔的转发客户端连接的目标 etcd 集群列表 默认配置: 127.0.0.1:2379 无效示例: https://127.0.0.1:2379(gateway 不终止 TLS) –discovery-srv 通过 SRV 记录引导集群端点的 DNS 域名 默认配置: (不设置) 网络–listen-addr 接口和端口绑定接收客户端请求 默认: 127.0.0.1:23790 –retry-delay 重试连接到失败的端点之前的延迟时间 默认配置: 1m0s 无效示例: “123”(使用指定格式的时间单位) 安全–insecure-discovery 接收 SRV 记录是不安全或易受到中间人攻击的 默认配置: false –trusted-ca-file 用于 etcd 集群的客户端 TLS CA 文件路径. 用于认证端点. 默认配置: (不设置)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(3)]]></title>
    <url>%2F2017-12-14-Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_3.html</url>
    <content type="text"><![CDATA[SDS 结构&emsp;&emsp;SDS 结构如下:12345678910111213141516171819202122232425262728293031323334353637struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;; &emsp;&emsp;其中: len 表示 sds 字符串的长度 alloc 表示 SDS 结构体剩余空间 flags 表示 SDS 结构体类型 buf 表示 sds 字符串&emsp;&emsp;4.0 版本将 3.0 版本时期统一的结构根据 SDS 结构体可以存储字符串的长度划分为不同的 5 种类型, 节省了内存占用的空间, 但是加大字符串操作的复杂度, 在字符串长度变动时需要改变 SDS 结构体类型. SDS 优势 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串时带来的内存重分配次数 二进制安全 兼容部分 C 字符串函数 SDS 内存分配策略 如果直接创建新结点, 会调用 sdsnewlen 函数根据指定字符串的长度创建一个新结点, 新结点没有空闲空间. 如果已有结点需要扩展空间时, 会调用 sdsMakeRoomFor 函数进行扩展.a. 已有结点 sds 字符串空间 &lt; SDS_MAX_PREALLOC, 则对 sds 字符串空间扩展一倍.b. 已有结点 sds 字符串空间 &gt;= SDS_MAX_PREALLOC(1024 * 1024), 则对 sds 字符串空间扩展 SDS_MAX_PREALLOC. SDS 会提供出一组接口使 SDS 的调用者需要释放或分配 SDS 相关的一些东西时可以使用. 同时将分配释放的宏封装起来可以在更换 SDS 分配器时不需要更改调用者中的分配器. SDS 应用 保存数据库中的字符串值. 用作缓冲区(buffer) AOF 模块中的 AOF 缓冲区. 客户端状态中的输入缓冲区. SDS 源码的思考 感觉没有必要使用 SDS_HDR_VAR, 会影响代码的可读性. sdsnewlen 中为什么把 len 和 alloc 设置相同的字符串的长度?len 表示字符串长度, alloc 表示字符串分配的空间, 这时分配空间是按照头结点长度 hdrlen + 字符串长度 initlen + null 终结符 1 进行计算, 分配给字符串的空间即为字符串长度, 所以这时的 len 等于 alloc. sdsnewlen 中为什么 initlen 为 0 时, 类型 5 不擅长?(后续关注对 SDS 的调用) sdsupdatelen 是否已经弃用?(后续关注对 SDS 的调用) sdsRemoveFreeSpace 的注释中 级联 是什么意思?(后续关注对 SDS 的调用) ssdsnew, sdsupdatelen, sdscat, sdscpy 不是二进制安全, sdscatrepr -&gt; sdscatprintf -&gt; sdscatvprintf -&gt; sdscat, sdsjoin -&gt; sdscat, 二级制不安全. 注意 sesdup 调用的 sdslen, 二进制安全的. zfree 的时间复杂度是 O(N)? sdsfree 时间复杂度是 O(N)?(后续关注对 SDS 的调用) sdscatvprintf 对于 buf 的处理为什么是将 -2 的位置置为 ‘\0’?因为在 vsnprintf(buf, buflen, fmt, cpy); 函数中, 无论真正的格式化输出字符串的长度是否超过 buflen, vsnprintf 函数都会将 buf[buflen - 1] 置为 ‘\0’, 所以如果用 -1 位置判断就会出错, 只能用最后一个可以判断的字符即 -2 位置判断. sdsfromlonglong 真的比 sdscatprintf 快吗?sdsfromlonglong 调用 sdsll2str 进行转换, sdscatprintf -&gt; sdscatvprintf -&gt; vsnprintf 函数进行转换, 使用了可变参数. 猜测 vsnprintf 底层转换与 sdsll2str 相似. 在我自己的机器上实测了一下, sdscatprintf 会比 sdsfromlonglong 慢 1us. sdscatrepr 中 ‘\\‘, ‘“‘, 为什么不和其他字符一样使用 sdscatlen?适用 SDS 中自带的测试集进行实测, 是可以实现的. sdssplitargs 如果处理类似 “ test\”aaa\” “ 会将参数识别为 test\”aaa\” 不影响吗?(后续关注对 SDS 的调用) 本文部分内容参考《Redis 设计与实现》一书.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(2)]]></title>
    <url>%2F2017-12-14-Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_2.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的实现. sds.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785/* SDSLib 2.0, 一个 C 实现的 strings 库 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;#include "sds.h"#include "sdsalloc.h"// 获取不同类型 sds 结构体大小// T = O(1)static inline int sdsHdrSize(char type)&#123; switch(type &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return sizeof(struct sdshdr5); case SDS_TYPE_8: return sizeof(struct sdshdr8); case SDS_TYPE_16: return sizeof(struct sdshdr16); case SDS_TYPE_32: return sizeof(struct sdshdr32); case SDS_TYPE_64: return sizeof(struct sdshdr64); &#125; return 0;&#125;// 根据 string 长度确定存储的 sds 类型// T = O(1)static inline char sdsReqType(size_t string_size)&#123; if(string_size &lt; 1 &lt;&lt; 5) // 最大 31 &#123; return SDS_TYPE_5; &#125; if(string_size &lt; 1 &lt;&lt; 8) // 最大 255 &#123; return SDS_TYPE_8; &#125; if(string_size &lt; 1 &lt;&lt; 16) // 最大 65535 &#123; return SDS_TYPE_16; &#125;#if(LONG_MAX == LLONG_MAX) if(string_size &lt; 1ll &lt;&lt; 32) //最大 2 ^ 32 - 1 &#123; return SDS_TYPE_32; &#125;#endif return SDS_TYPE_64; //最大 2 ^ 64 - 1&#125;// 二进制安全: 只会严格的按照二进制的数据存取. 不会妄图已某种特殊格式解析数据./* 使用 'init' 指针和 'initlen' 指定的内容创建一个新的 sds string. * 如果 'init' 是 NULL, 那么 string 将被初始化为 0 字节. * * 字符串始终为空终止(\0)(所有的 sds 字符串都是, 都总是) * 因此即使你创建一个这样的 sds 字符串: * * mystring = sdsnewlen("abc", 3); * * 你可以使用 printf() 打印字符串, 因为字符串的末尾有一个隐含的 \0. * 同时因为字符串长度保存在 sds 头结点中, 字符串是二进制安全的, \0也可以被包含在 sds 字符串中. * 也就是说 当 mystring = sdsnewlen("abc", 4); 时, \0 也是 sds 字符串中的一部分, 是二进制安全. */// 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化// T = O(N)sds sdsnewlen(const void *init, size_t initlen)&#123; void *sh; sds s; // 通过长度获取存储字符串的 SDS 类型 char type = sdsReqType(initlen); /* 为了添加字符串, 空字符串经常被创建. * 使用类型 8, 因为类型 5 在这里不适用. */ if(type == SDS_TYPE_5 &amp;&amp; initlen == 0) &#123; type = SDS_TYPE_8; &#125; // 通过 SDS 类型获取 SDS 头结点大小 int hdrlen = sdsHdrSize(type); unsigned char *fp; /* 标记指针 */ sh = s_malloc(hdrlen + initlen + 1); if(!init) &#123; memset(sh, 0, hdrlen + initlen + 1); &#125; if(sh == NULL) &#123; return NULL; &#125; s = (char *)sh + hdrlen; fp = ((unsigned char *)s) - 1; // 初始化 SDS 头结点 switch(type) &#123; case SDS_TYPE_5: &#123; *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS); break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); sh-&gt;len = initlen; sh-&gt;alloc = initlen; *fp = type; break; &#125; &#125; // 如果指定初始化内容, 将它们复制到 sdshdr 的 buf 中 // T = O(N) if(initlen &amp;&amp; init) &#123; memcpy(s, init, initlen); &#125; // 字符串以 \0 结尾 s[initlen] = '\0'; // 返回 buf 部分, 而不是整个 sdshdr return s;&#125;/* 创建一个空(长度为 0) sds 字符串. * 在这种情况下字符串总是含有一个 null(\0) 终结符. */// 创建并返回一个只保存了空字符串 "" 的 sds// T = O(1)sds sdsempty(void)&#123; return sdsnewlen("", 0);&#125;/* 根据一个空终止(\0)的 C 字符串开始创建一个新的 sds 字符串. */// 也只适合 C 字符串// 根据给定字符串 init 创建一个包含同样字符串的 sds// T = O(N)sds sdsnew(const char *init)&#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;/* 复制一个 sds 字符串 */// 复制给定 sds 的副本// T = O(N)sds sdsdup(const sds s)&#123; return sdsnewlen(s, sdslen(s));&#125;/* 释放 sds. 如果 s 为空, 则不需要干什么 */// T = O(N)void sdsfree(sds s)&#123; if(s == NULL) &#123; return ; &#125; s_free((char *)s - sdsHdrSize(s[-1]));&#125;/* 设置 sds 字符串长度为通过 strlen() 获取的长度, * 因此要考虑到内容只能到达第一个 null(\0) 字符. * * 当 sds 字符串被黑客以某种手动方式入侵时, 这个函数是很有用的, * 如下例所示: * * s = sdsnew("foobar"); * s[2] = '\0'; * sdsupdatelen(s); * printf("%d\n", sdslen(s)); * * 输出将会是 2, 如果我们注释调用 sdsupdatelen() 的部分, * 输出将会是 6, 因为字符串被修改, 但是逻辑长度依然是 6. */// 更新 sds 的长度// T = O(1)void sdsupdatelen(sds s)&#123; int reallen = strlen(s); sdssetlen(s, reallen);&#125;/* 修改一个字符串, 使它立刻变成空(长度为 0). * 但是所有现有的缓冲区不会被丢弃, 而是设置为可用空间, * 以便下一次增加操作不需要预先分配可用的字节数. */// 清空 sds 字符串的内容// T = O(1)void sdsclear(sds s)&#123; sdssetlen(s, 0); s[0] = '\0';&#125;/* 在 sds 字符串的尾部扩增可用空间, 以便确保该函数的调用者在调用该函数后可以 sds 字符串末尾写入 addlen 个字节. * 再在末尾加上一个 null 终结符. * * 注意: 注意这个函数不会改变 sdslen() 返回的 sds 字符串的 *length*, * 只能改变我们拥有的可用缓冲区空间. */// 当 sds 字符串空间充足时, 直接返回, 空间不足时, 重新分配空间, 设置 sds 头结点, 字符串内容// T = O(N)sds sdsMakeRoomFor(sds s, size_t addlen)&#123; void *sh; void *newsh; // 获取当前空闲空间大小 size_t avail = sdsavail(s); size_t len; size_t newlen; char type; // 获取当前 sds 的类型 char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; /* 如果空间足够, 立刻返回 */ if(avail &gt;= addlen) &#123; return s; &#125; len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); newlen = (len + addlen); // 如果需要新分配给 sds 字符串的空间的长度小于 sds 最大预分配给 sds 字符串的空间长度 if(newlen &lt; SDS_MAX_PREALLOC) &#123; newlen *= 2; &#125; else &#123; // 如果需要新分配给 sds 字符串的空间的长度大于最大预分配给 sds 字符串的空间长度时, 每次增长最大预分配给 sds 字符串的空间长度 newlen += SDS_MAX_PREALLOC; &#125; // 根据需要新分配给 sds 字符串的空间的长度计算新的 sds 需要的类型 type = sdsReqType(newlen); /* 不要使用类型 5: 当用户扩增字符串时, 由于类型 5 不能记住空闲空间, * 因此调用 sdsMakeRoomFor() 时必须进行扩增操作 */ if(type == SDS_TYPE_5) &#123; type = SDS_TYPE_8; &#125; hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; // 如果新类型与原来的类型相同, 重新分配新长度的 sds 并将原来 sds 字符串(包括头结点和 null 终结符)拷贝到新空间. newsh = s_realloc(sh, hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; /* 由于头结点大小改变, 需要将字符串向前移动, 不能直接使用 realloc */ // 如果新类型与原来的类型不同, 重新分配新类型新长度的 sds newsh = s_malloc(hdrlen + newlen + 1); if(newsh == NULL) &#123; return NULL; &#125; // 将原来的 sds 字符串拷贝到新 sds 中 memcpy((char *)newsh + hdrlen, s, len + 1); // 释放原来的 sds s_free(sh); s = (char *)newsh + hdrlen; // 设置新 sds 类型, 长度 s[-1] = type; sdssetlen(s, len); &#125; // 更新分配空间大小 sdssetalloc(s, newlen); return s;&#125;/* 为了使 sds 字符串结尾没有可用空间, 对其重新分配空间. * 剩下的 sds 字符串没有改变, 但是下一个级联操作将需要重新分配空间. * * 在被调用后, 通过这个函数的 sds 字符串不能变的更长, 所有的指针必须被调用返回的新指针替换 */// 将 sds 字符串的空间缩短到字符串自身的长度.// T = O(N)sds sdsRemoveFreeSpace(sds s)&#123; void *sh; void *newsh; char type; char oldtype = s[-1] &amp; SDS_TYPE_MASK; int hdrlen; size_t len = sdslen(s); sh = (char *)s - sdsHdrSize(oldtype); type = sdsReqType(len); hdrlen = sdsHdrSize(type); if(oldtype == type) &#123; newsh = s_realloc(sh, hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; s = (char *)newsh + hdrlen; &#125; else &#123; newsh = s_malloc(hdrlen + len + 1); if(newsh == NULL) &#123; return NULL; &#125; memcpy((char *)newsh + hdrlen, s, len + 1); s_free(sh); s = (char *)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); &#125; sdssetalloc(s, len); return s;&#125;/* 返回指定 sds 字符串分配总空间的大小 * 包括: * 1) 指针前的 sds 头结点. * 2) 字符串. * 3) 结尾若干可用缓冲区. * 4) 隐含的 null 终结符. */// 获取分配给 sds 的总空间// T = O(1)size_t sdsAllocSize(sds s)&#123; size_t alloc = sdsalloc(s); return sdsHdrSize(s[-1]) + alloc + 1;&#125;/* 返回 sds 真实的分配总空间(通常, sds 字符串作为字符串缓冲区开始的参考) */// 获取 sds 总空间的指针// T = O(1)void *sdsAllocPtr(sds s)&#123; return (void *)(s = sdsHdrSize(s[-1]));&#125;/* 根据 'incr' 增加 sds 字符串长度, 并减小字符串左侧可用空间. * 同时在新的字符串结尾设置 null 终结符. * * 使用这个函数是为了在用户调用 sdsMakeRoomFor() 函数后, 在当前字符串的结尾写入一些东西, * 最后需要设置字符串新长度是修改字符串的长度. * * 注意: 可以使用负增量来从右侧缩减字符串. * * 用法示例: * * 使用以下模式调用 sdsIncrLen() 和 sdsMakeRoomFor(), 可以将字符串直接从内核挂载连接到 * sds 字符串末尾, 不需要复制到中间缓冲区. * * oldlen = sdslen(s); * s = sdsMakeRoomFor(s, BUFFER_SIZE); * nread = read(fd, s + oldlen, BUFFER_SIZE); * ... 检查 nread &lt;= 0 并处理它 ... * sdsIncrLen(s, nread); */// 修改 sds 字符串长度// T = O(1)void sdsIncrLen(sds s, int incr)&#123; unsigned char flags = s[-1]; size_t len; // 修改 sds 字符串长度 switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char oldlen = SDS_TYPE_5_LEN(flags); assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr))); *fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS); len = oldlen + incr; break; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr))); len = (sh-&gt;len +=incr); break; &#125; default: len = 0; /* 只是为了避免编译警告 */ &#125; s[len] = '\0';&#125;/* 将 sds 字符串的长度增长到指定长度. 增长的长度初始化为 0. * * 如果指定的长度比当前 sds 字符串的短, 则不执行任何操作. */// 增长字符串, 并将增加的部分置为 0// T = O(N)sds sdsgrowzero(sds s, size_t len)&#123; size_t curlen = sdslen(s); if(len &lt;= curlen) &#123; return s; &#125; // 扩增 sds 字符串分配的空间 s = sdsMakeRoomFor(s, len - curlen); if(s == NULL) &#123; return NULL; &#125; /* 确保添加的区域不包含垃圾 */ // 将添加区域初始化为 0 memset(s + curlen, 0, (len - curlen + 1)); sdssetlen(s, len); return s;&#125;/* 在 sds 字符串 's' 后添加二进制安全的 len 个字节的 't' 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加长度为 len 的字符串// T = O(N)sds sdscatlen(sds s, const void *t, size_t len)&#123; size_t curlen = sdslen(s); // 空间足够直接返回, 空间不足获取空间 s = sdsMakeRoomFor(s, len); if(s == NULL) &#123; return NULL; &#125; memcpy(s + curlen, t, len); sdssetlen(s, curlen + len); s[curlen + len] = '\0'; return s;&#125;/* 在 sds 字符串后添加指定以 null 终止的 C 字符串. * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定以 null 终止的 C 字符串.// T = O(N)sds sdscat(sds s, const char *t)&#123; return sdscatlen(s, t, strlen(t));&#125;/* 在现有 sds 字符串后添加指定 sds 字符串 * * 在调用后, 旧的 sds 字符串将不再有效, 所有指针必须用返回的新指针代替. */// 在 sds 字符串后添加指定 sds 字符串.// T = O(N)sds sdscatsds(sds s, const sds t)&#123; return sdscatlen(s, t, sdslen(t));&#125;/* 破坏性的修改 sds 字符串来保存指定的长度为 'len' 字节的二进制安全的字符串 't'. */// 拷贝二进制安全字符串 't' 到 sds 字符串中.// T = O(N)sds sdscpylen(sds s, const char *t, size_t len)&#123; // 查看字符串空间是否足够 if(sdsalloc(s) &lt; len) &#123; s = sdsMakeRoomFor(s, len - sdslen(s)); if(s == NULL) &#123; return NULL; &#125; &#125; memcpy(s, t, len); s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 类似 sdscpylen() 但是 't' 必须是一个以 null 终结的字符串, 以便通过 strlen() 获取字符串长度. */// 对 C 字符串进行拷贝// T = O(N)sds sdscpy(sds s, const char *t)&#123; return sdscpylen(s, t, strlen(t));&#125;/* 帮助 sdscatlonglong() 进行实际的数字 -&gt; 字符串的转换. * 's' 必须指向一个最少 SDS_LLSTR_SIZE 字节的字符串空间. * * 这个函数返回存储在 's' 中的以 null 终结的字符串表示的长度 */// long long 类型转换为 string 类型// T = O(N)#define SDS_LLSTR_SIZE 21int sdsll2str(char *s, long long value)&#123; char *p; char aux; unsigned long long v; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ // 将 long long 反转存储在字符串中 v = (value &lt; 0) ? -value : value; p = s; // T = O(N) do &#123; // 只能适用于 C 语言字符集 *p++ = '0' + (v % 10); v /= 10; &#125;while(v); if(value &lt; 0) &#123; *p++ = '-'; &#125; /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ // 将反转的字符串反转就是 long long 的顺序字符串表示 // T = O(N) p --; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 与 sdsll2str() 相同, 但是这个函数是针对 unsigned long long 类型. */// unsigned long long 类型转换为 string 类型// T = O(N)int sdsull2str(char *s, unsigned long long v)&#123; char *p; char aux; size_t l; /* 生成字符串表示, 这种方式产生一个反转的字符串 */ p = s; do &#123; *p++ = '0' + (v % 10); v /= 10; &#125;while(v); /* 计算长度并添加 null 终止符 */ l = p - s; *p = '\0'; /* 反转字符串 */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* 根据一个 long long 值创建一个 sds 字符串. 这要比以下方式快很多: * * sdscatprintf(sdsempty(), "%lld\n", value); */// long long 类型转换为 sds 类型// T = O(N)sds sdsfromlonglong(long long value)&#123; char buf[SDS_LLSTR_SIZE]; int len = sdsll2str(buf, value); return sdsnewlen(buf, len);&#125;/* 类似 sdscatprintf() 但是获取的是 va_list 而不是可变参数 */// 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// T = O(N)sds sdscatvprintf(sds s, const char *fmt, va_list ap)&#123; va_list cpy; char staticbuf[1024]; char *buf = staticbuf; char *t; size_t buflen = strlen(fmt) * 2; /* 我们尝试开始使用静态缓冲区来提升速度. * 如果不可能, 我们回到使用堆分配. */ if(buflen &gt; sizeof(staticbuf)) &#123; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; &#125; else &#123; buflen = sizeof(staticbuf); &#125; /* 每次当我们使用当前缓冲区大小无法适应字符串时, 尝试使用缓冲区的两倍大小. */ while(1) &#123; buf[buflen - 2] = '\0'; va_copy(cpy, ap); vsnprintf(buf, buflen, fmt, cpy); va_end(cpy); if(buf[buflen - 2] != '\0') &#123; // 缓冲区大小无法适应字符串. if(buf != staticbuf) &#123; // 在堆上分配的空间, 释放 s_free(buf); &#125; // 重新分配两倍大小的空间 buflen *= 2; buf = s_malloc(buflen); if(buf == NULL) &#123; return NULL; &#125; continue; &#125; // 直到适应字符串 break; &#125; /* 最后将获得的字符串添加到 sds 字符串并返回它. */ // 将字符串添加到 sds 字符串后 t = sdscat(s, buf); if(buf != staticbuf) &#123; s_free(buf); &#125; return t;&#125;/* 将使用类似 printf 指定格式获得的字符串添加到 sds 字符串. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("Sum is: "); * s = sdscatprintf(s, "%d+%d = %d", a, b, a + b); * * 通常, 你需要使用类似 printf 格式从头创建一个字符串. * 当你需要时, 只需要使用 sdsempty() 作为字符串: * * s = sdscatprintf(sdsempty(), "... your format ...", args); */// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串// T = O(N)sds sdscatprintf(sds s, const char *fmt, ...)&#123; va_list ap; char *t; va_start(ap, fmt); t = sdscatvprintf(s, fmt, ap); va_end(ap); return t;&#125;/* 这个函数类似 sdscatprintf, 但是要快很多, 它没有依靠 libc 中通常很慢的 sprintf() 系列函数. * 此外, 将 sds 字符串作为被连接新数据直接处理提供了性能改进. * * 然而, 这个函数只处理类似 printf 的格式说明符的不兼容子集. * * %s - C 字符串 * %S - SDS 字符串 * %i - 有符号整形 * %I - 64 位有符号整形(long long, int64_t) * %u - 无符号整形 * %U - 64 位无符号整形(unsigned long long, uint64_t) * %% - % 字符 */// 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串// T = O(N)sds sdscatfmt(sds s, char const *fmt, ...)&#123; size_t initlen = sdslen(s); const char *f = fmt; int i; va_list ap; // 开始遍历参数 va_start(ap, fmt); f = fmt; /* 遍历格式化输出字符串中格式说明符下一个要处理的字节. */ i = initlen; /* 写入目标字符串下一个字节的位置. */ // 遍历格式化输出字符串 while(*f) &#123; char next, *str; size_t l; long long num; unsigned long long unum; /* 确保至少有一个字节的空间 */ // 确保当该字符不是说明符时有可以存储的 1 字节空间 if(sdsavail(s) == 0) &#123; s = sdsMakeRoomFor(s, 1); &#125; // 处理有可能为说明符的情况, 即 *f 为 %. switch(*f) &#123; case '%': next = *(f + 1); f++; switch(next) &#123; case 's': case 'S': str = va_arg(ap, char *); l = (next == 's') ? strlen(str) : sdslen(str); // 空间不足时扩容 if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; // 将字符串添加到 sds 字符串后 memcpy(s + i, str, l); sdsinclen(s, l); i += l; break; case 'i': case 'I': if(next == 'i') &#123; num = va_arg(ap, int); &#125; else &#123; num = va_arg(ap, long long); &#125; // 将 long long 转换为字符串 char buf[SDS_LLSTR_SIZE]; l = sdsll2str(buf, num); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; case 'u': case 'U': if(next == 'u') &#123; unum = va_arg(ap, unsigned int); &#125; else &#123; unum = va_arg(ap, unsigned long long); &#125; char buf[SDS_LLSTR_SIZE]; l = sdsull2str(buf, unum); if(sdsavail(s) &lt; l) &#123; s = sdsMakeRoomFor(s, l); &#125; memcpy(s + i, buf, l); sdsinclen(s, l); i += l; break; default: /* 处理 %%, 通常为 %&lt;unknown&gt;. */ s[i++] = next; sdsinclen(s, 1); break; &#125; break; // 处理不是 % 开头的可能为说明符的情况 default: s[i++] = *f; sdsinclen(s, 1); break; &#125; f++; &#125; va_end(ap); /* 添加 null 终结符 */ s[i] = '\0'; return s;&#125;/* 从字符串左边和右边分别删除 sds 字符串的一部分, 删除的字符串为在 'cset' 中找到的字符组成的连续字符, * 'cset' 字符串是一个 null 终结的 C 字符串. * * 在调用这个函数后, 被修改 sds 字符串不再有效, * 所有指针必须被调用返回的新指针替代. * * 例如: * * s = sdsnew("AA...AA.a.aa.aHellWorld :::"); * s = sdstrim(s, "Aa. :"); * printf("%s\n", s); * * 只输出 "Hello World" */// 删除 sds 字符串首尾在 'cset' 中存在的字符串// T = O(M*N)，M 为 SDS 长度, N 为 cset 长度sds sdstrim(sds s, const char *cset)&#123; char *start; char *end; char *sp; char *ep; size_t len; sp = start = s; ep = end = s + sdslen(s) - 1; // 从头向尾遍历 // T = O(M * N) while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) &#123; sp++; &#125; // 从尾向头遍历 while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) &#123; ep--; &#125; len = (sp &gt; ep) ? 0 : ((ep - sp) + 1); // 移动剩余部分 if(s != sp) &#123; memmove(s, sp, len); &#125; s[len] = '\0'; sdssetlen(s, len); return s;&#125;/* 将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串. * * start 和 end 可以是负数, 其中 -1 表示字符串的最后一个字符, -2 表示倒数第二个字符, 等等. * * 间隔是包含的, 因此开始和结束字符是生成字符串的一部分. * * 字符串就地被修改. * * 例如: * * s = sdsnew("Hello World"); * sdsrange(s, 1, -1); // =&gt; "ello World" */// 将 sds 字符串缩短为 'start' 到 'end' 之间, 闭区间// T = O(N)void sdsrange(sds s, int start, int end)&#123; size_t newlen; size_t len = sdslen(s); if(len == 0) &#123; return ; &#125; // 如果指定 'start' 是负数 if(start &lt; 0) &#123; start = len + start; if(start &lt; 0) &#123; // 赋值负数超出字符串范围的 start 为 0 start = 0; &#125; &#125; if(end &lt; 0) &#123; end = len + end; if(end &lt; 0) &#123; end = 0; &#125; &#125; // 计算 start 和 end 指定子串的长度, 包含 start 和 end newlen = (start &gt; end) ? 0 : (end - start) + 1; if(newlen != 0) &#123; if(start &gt;= (signed)len) &#123; newlen = 0; &#125; else if(end &gt;= (signed)len) &#123; end = len - 1; newlen = (start &gt; end) ? 0 : (end - start) + 1; &#125; &#125; else &#123; // 这里 newlen = 0, 一定进入下一个 if start = 0; &#125; // 清楚 start 前的字符 if(start &amp;&amp; newlen) &#123; memmove(s, s + start, newlen); &#125; // newlen 为 0 时, 清空字符串. // 即为 s[newlen] = '\0'; s[newlen] = 0; sdssetlen(s, newlen);&#125;/* 对 sds 字符串 's' 的每一个字符调用 tolower() */// 将 sds 字符串 's' 中的字母转换为小写字母// T = O(N)void sdstolower(sds s)&#123; int len = sdslen(s); int j; // 转换每一个字符 for(j = 0; j &lt; len; j++) &#123; s[j] = tolower(s[j]); &#125;&#125;/* 对 sds 字符串 's' 的每一个字符调用 sdstoupper() */// 将 sds 字符串 's' 中的字母转换为大写字母// T = O(N)void sdstoupper(sds s)&#123; int len = sdslen(s); int j; for(j = 0; j &lt; len; j++) &#123; s[j] = toupper(s[j]); &#125;&#125;/* 使用 memcmp() 比较两个 sds 字符串 s1 和 s2. * * 返回值: * * 如果 s1 &gt; s2, 返回正数. * 如果 s1 &lt; s2, 返回负数. * 如果s1和s2是完全相同的二进制字符, 则为0. * * 如果两个字符串共享完全相同的前缀, 但是其中的一个长度更长, 则较长的字符串被认为大于较小的字符串. */// 比较两个字符串// T = O(N)int sdscmp(const sds s1, const sds s2)&#123; size_t l1; size_t l2; size_t minlen; int cmp; l1 = sdslen(s1); l2 = sdslen(s2); // 获取最小长度 minlen = (l1 &lt; l2) ? l1 : l2; // 比较最小长度空间中的字符 cmp = memcmp(s1, s2, minlen); if(cmp == 0) &#123; // 最小长度空间中字符相同, 返回长度的差值, 为 0 则两个字符串相同 return l1 - l2; &#125; // 返回最小长度空间中不同字符的差 return cmp;&#125;/* 使用分隔符 'sep' 分割 's'. 返回 sds 字符串数组. * *count 将会被指针设置为 sds 的数量. * * 内存溢出, 空字符串, 空分隔符将会返回 NULL. * * 注意: 'sep' 可以是一个由多个字符组成的分隔符. 例如: * sdssplit("foo_-_bar", "_-_"); * 将返回 "foo" 和 "bar" 两个元素. * * 这个函数的版本是二级制安全的, 但是需要参数长度. * sdssplit() 是只针对 NULL 终结的字符串的相同函数. */// 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾// T = O(N ^ 2)sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count)&#123; int elements = 0; int slots = 5; int start = 0; int j; sds *tokens; if(seplen &lt; 1 || len &lt; 0) &#123; return NULL; &#125; tokens = s_malloc(sizeof(sds) * slots); if(tokens == NULL) &#123; return NULL; &#125; if(len == 0) &#123; *count = 0; return tokens; &#125; // 遍历字符串 // T = O(N ^ 2) for(j = 0; j &lt; (len - (seplen - 1)), j++) &#123; /* 确保下一个元素和最后一个元素有空间 */ if(slots &lt; elements + 2) &#123; sds *newtokens; slots *= 2; newtokens = s_realloc(tokens, sizeof(sds) * slots); if(newtokens == NULL) &#123; goto cleanup; &#125; tokens = newtokens; &#125; /* 搜索分隔符 */ // T = O(N) if((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) &#123; // 找到分隔符 tokens[elements] = sdsnewlen(s + start, j - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; start = j + seplen; // 麻蛋, -1 是因为 for 循环自己加了 1 j = j + seplen - 1; /* 跳过分隔符 */ &#125; &#125; /* 添加最后一个元素. 我们确定在标记数组中存在空间. */ tokens[elements] = sdsnewlen(s + start, len - start); if(tokens[elements] == NULL) &#123; goto cleanup; &#125; elements++; *count = elements; return tokens; // 错误处理 cleanup: &#123; int i; // 清理空间 for(i = 0; i &lt; elements; i++) &#123; sdsfree(tokens[i]); &#125; s_free(tokens); *count = 0; return NULL; &#125;&#125;/* 释放 sdssplitlen() 返回的结果, 或者当 'tokens' 为 NULL 时什么都不做. */// 释放分割的结果// T = O(N)void sdsfreesplitres(sds *tokens, int count)&#123; if(!tokens) &#123; return ; &#125; while(count--) &#123; sdsfree(tokens[count]); &#125; s_free(tokens);&#125;/* 为 sds 字符串 's' 添加将所有无法打印的字符(使用 isprint() 测试) * 变成 "\n\r\a..." 或 "\x&lt;hex-number&gt;" 转移的形式组成的转义字符串的表示. * * 在被调用后, 被修改的 sds 字符串将不再有效, * 所有指针必须被调用返回的新指针替代. */// 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.// T = O(N)sds sdscatrepr(sds s, const char *p, size_t len)&#123; s = sdscatlen(s, "\"", 1); while(len--) &#123; switch(*p) &#123; case '\\': case '"': s = sdscatprintf(s, "\\%c", *p); break; // case '\\': s = sdscatlen(s, "\\\\", 2); break; // case '"': s = sdscatlen(s, "\\\"", 2); break; case '\n': s = sdscatlen(s, "\\n", 2); break; case '\r': s = sdscatlen(s, "\\r", 2); break; case '\t': s = sdscatlen(s, "\\t", 2); break; case '\a': s = sdscatlen(s, "\\a", 2); break; case '\b': s = sdscatlen(s, "\\b", 2); break; default: if(isprint(*p)) &#123; s = sdscatprintf(s, "%c", *p); &#125; else &#123; s = sdscatprintf(s, "\\x%02x", (unsigned char) *p); &#125; break; &#125; p++; &#125; return sdscatlen(s, "\"", 1);&#125;/* sdssplitargs() 的辅助函数, 如果 'c' 是有效的十六进制, 则返回非零. */// 测试字符是否为十六进制字符// T = O(1)int is_hex_digit(char c)&#123; return (c &gt;= '0' &amp;&amp; c &lt;='9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F');&#125;/* sdssplitargs() 的辅助函数, 将十六进制数转换为从 0 到 15 的整数. */// 将十六进制转换为从 0 到 15 的整数.// T = O(1)int hex_digit_to_int(char c)&#123; switch(c) &#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; default: return 0; &#125;&#125;/* 把一行文本切割成多个参数, 每个参数可以有以下的类编程语言 REPL 格式: * * foo bar "newline are suported\n" and "\xff\x00otherstuff" * * 参数的数量存储在 *argc 中, 这个函数会返回一个 sds 数组. * * 调用者应该调用 sdsfreesplitres() 函数释放生成的 sds 数组. * * 注意: sdscatrepr() 可以将一个字符串转换为一个带引号的字符串, * 相同格式的字符串可以被 sdssplitargs() 函数解析. * * 即使当输入出现空字符串, 函数仍然会将成功处理的字符串返回. * 或当输入不对应的引号或后引号后面没有跟空格例如: "foo"bar 或 "foo' 时返回 NULL. */// * 这个函数主要用于 config.c 中对配置文件进行分析, 将字符串按照 REPL 格式切分成一个 sds 参数数组.// * // * 例如:// * sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");// * 会得出:// * arr[0] = "timeout"// * arr[1] = "10086"// * arr[2] = "port"// * arr[3] = "123321"// * T = O(N)sds *sdssplitargs(const char *line, int *argc)&#123; const char *p = line; char *current = NULL; char **vector = NULL; *argc = 0; while(1) &#123; // 遇到空格跳过 // T = O(N) while(*p &amp;&amp; isspace(*p)) &#123; p++; &#125; if(*p) &#123; /* 获取一个标记 */ int inq = 0; /* 如果遇到引号设置为 1 */ int insq = 0; /* 如果遇到单引号设置为 1 */ // 当前参数结束了设置为 1 int done = 0; // 获取一个 sds 存储参数 if(current == NULL) &#123; current = sdsempty(); &#125; // T = O(N) while(!done) &#123; if(inq) &#123; // 前面遍历过前引号 if(*p == '\\' &amp;&amp; *(p + 1) == 'x' &amp;&amp; is_hex_digit(*(p + 2)) &amp;&amp; is_hex_digit(*(p + 3))) &#123; // 遇到十六进制表示, 转换为字符 unsigned char byte; byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3)); current = sdscatlen(current, (char *)&amp;byte, 1); p += 3; &#125; else if(*p == '\\' &amp;&amp; *(p + 1)) &#123; // 遇到转义字符, 转换为对应的字符 char c; p++; switch(*p) &#123; case 'n': c = '\n'; break; case 'r': c = '\r'; break; case 't': c = '\t'; break; case 'b': c = '\b'; break; case 'a': c = '\a'; break; default: c = *p; break; &#125; current = sdscatlen(current, &amp;c, 1); &#125; else if(*p == '"') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; // 不是执行错误处理代码 goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ // 没有后引号就结束 goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else if(insq) &#123; // 前面遍历过前单引号 if(*p == '\\' &amp;&amp; *(p + 1) == '\'') &#123; // 遇到转义的单引号 p++; current = sdscatlen(current, "'", 1); &#125; else if(*p == '\'') &#123; /* 后引号后面必须紧跟空格或者在字符串结尾 */ // 遇到后单引号, 检测后一个字符是否为空格或结束 if(*(p + 1) &amp;&amp; !isspace(*(p + 1))) &#123; goto err; &#125; done = 1; &#125; else if(!*p) &#123; /* 引号没有终止 */ goto err; &#125; else &#123; // 否则为普通字符 current = sdscatlen(current, p, 1); &#125; &#125; else &#123; // 不在引号内的字符 switch(*p) &#123; // 分隔参数的符号 case ' ': case '\n': case '\r': case '\t': case '\0': done = 1; break; // 前引号 case '"': inq = 1; break; // 后引号 case '\'': insq = 1; break; // 普通字符 default: current = sdscatlen(current, p, 1); break; &#125; &#125; // 指针向后移动 if(*p) &#123; p++; &#125; &#125; /* 在 vector 中添加标记 */ // 将参数添加到参数数组 vector 中 // T = O(N) vector = s_realloc(vector, ((*argc) + 1) * sizeof(char *)); vector[*argc] = current; (*argc)++; current = NULL; &#125; else &#123; /* 即使是空字符串仍然返回一些内容, 不会返回 NULL */ // 字符串遍历结束 if(vector == NULL) &#123; vector = s_malloc(sizeof(void *)); &#125; return vector; &#125; &#125; err: &#123; // 出错时, 清理内存空间, 返回 NULL while((*argc)--) &#123; sdsfree(vector[*argc]); &#125; s_free(vector); if(current) &#123; sdsfree(current); &#125; *argc = 0; return NULL; &#125;&#125;/* 将 sds 字符串中所有 'from' 字符串中指定的字符集出现的字符替换为 'to' 数组中相应位置的字符. * * 例如: * sdsmapchars(mystring, "ho", "01", 2); * 将具有将字符串 "hello" 转换为 "0ell1" 的效果. * * 这个函数返回 sds 字符串指针, 它总是与输入指针大小相同, 因此不需要调整大小. */// 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符// T = O(M * N) M 为 setlen 的长度, N 为 s 的长度sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen)&#123; size_t j; size_t i; size_t l = sdslen(s); for(j = 0; j &lt; l; j++) &#123; for(i = 0; i &lt; setlen; i++) &#123; if(s[j] == from[i]) &#123; s[j] = to[i]; break; &#125; &#125; &#125; return s;&#125;/* 使用指定分隔符(C 字符串)将一个 C 字符串数组组合成一个 sds 字符串. * 以 sds 字符串形式返回结果 */// 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全// T = O(N)sds sdsjoin(char **argv, int argc, char *sep)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscat(join, argv[j]); if(j != argc - 1) &#123; join = sdscat(join, sep); &#125; &#125; return join;&#125;/* 类似 sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串. */// T = O(N)sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)&#123; sds join = sdsempty(); int j; for(j = 0; j &lt; argc; j++) &#123; join = sdscatsds(join, argv[j]); if(j != argc - 1) &#123; join = sdscatlen(join, sep, seplen); &#125; &#125; return join;&#125;/* 低等级函数作为 API 暴露给用户使用 *//* 封装被 SDS 使用的分配器. * 注意: 为了避免函数调用过程的付出开销, SDS 实际上只使用 sdsalloc.h 中定义的宏. * 这里, 我们定义这些封装只有在当链接 SDS 的程序想要接触 SDS 构件的时候使用, 即使它们使用的是不同的分配器. */// 在 SDS 的调用者需要释放或申请 SDS 相关的一些东西时可以使用这三个程序.// 将分配释放的宏封装起来应该是为了在更换 SDS 分配器时不需要更改调用者中的分配器.void *sds_malloc(size_t size)&#123; return s_malloc(size);&#125;void *sds_realloc(void *ptr, size_t size)&#123; return s_realloc(ptr, size);&#125;void sds_free(void *ptr)&#123; s_free(ptr);&#125;// 测试代码#if defined(SDS_TEST_MAIN)#include &lt;stdio.h&gt;#include "testhelp.h"#include "limits.h"#define UNUSED(x) (void)(x)int sdsTest(void) &#123; &#123; sds x = sdsnew("foo"), y; test_cond("Create a string and obtain the length", sdslen(x) == 3 &amp;&amp; memcmp(x,"foo\0",4) == 0) sdsfree(x); x = sdsnewlen("foo",2); test_cond("Create a string with specified length", sdslen(x) == 2 &amp;&amp; memcmp(x,"fo\0",3) == 0) x = sdscat(x,"bar"); test_cond("Strings concatenation", sdslen(x) == 5 &amp;&amp; memcmp(x,"fobar\0",6) == 0); x = sdscpy(x,"a"); test_cond("sdscpy() against an originally longer string", sdslen(x) == 1 &amp;&amp; memcmp(x,"a\0",2) == 0) x = sdscpy(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"); test_cond("sdscpy() against an originally shorter string", sdslen(x) == 33 &amp;&amp; memcmp(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0",33) == 0) sdsfree(x); x = sdscatprintf(sdsempty(),"%d",123); test_cond("sdscatprintf() seems working in the base case", sdslen(x) == 3 &amp;&amp; memcmp(x,"123\0",4) == 0) sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX); test_cond("sdscatfmt() seems working in the base case", sdslen(x) == 60 &amp;&amp; memcmp(x,"--Hello Hi! World -9223372036854775808," "9223372036854775807--",60) == 0) printf("[%s]\n",x); sdsfree(x); x = sdsnew("--"); x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX); test_cond("sdscatfmt() seems working with unsigned numbers", sdslen(x) == 35 &amp;&amp; memcmp(x,"--4294967295,18446744073709551615--",35) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," x"); test_cond("sdstrim() works when all chars match", sdslen(x) == 0) sdsfree(x); x = sdsnew(" x "); sdstrim(x," "); test_cond("sdstrim() works when a single char remains", sdslen(x) == 1 &amp;&amp; x[0] == 'x') sdsfree(x); x = sdsnew("xxciaoyyy"); sdstrim(x,"xy"); test_cond("sdstrim() correctly trims characters", sdslen(x) == 4 &amp;&amp; memcmp(x,"ciao\0",5) == 0) y = sdsdup(x); sdsrange(y,1,1); test_cond("sdsrange(...,1,1)", sdslen(y) == 1 &amp;&amp; memcmp(y,"i\0",2) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,-1); test_cond("sdsrange(...,1,-1)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,-2,-1); test_cond("sdsrange(...,-2,-1)", sdslen(y) == 2 &amp;&amp; memcmp(y,"ao\0",3) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,2,1); test_cond("sdsrange(...,2,1)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,1,100); test_cond("sdsrange(...,1,100)", sdslen(y) == 3 &amp;&amp; memcmp(y,"iao\0",4) == 0) sdsfree(y); y = sdsdup(x); sdsrange(y,100,100); test_cond("sdsrange(...,100,100)", sdslen(y) == 0 &amp;&amp; memcmp(y,"\0",1) == 0) sdsfree(y); sdsfree(x); x = sdsnew("foo"); y = sdsnew("foa"); test_cond("sdscmp(foo,foa)", sdscmp(x,y) &gt; 0) sdsfree(y); sdsfree(x); x = sdsnew("bar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) == 0) sdsfree(y); sdsfree(x); x = sdsnew("aar"); y = sdsnew("bar"); test_cond("sdscmp(bar,bar)", sdscmp(x,y) &lt; 0) sdsfree(y); sdsfree(x); x = sdsnewlen("\a\n\0foo\r",7); y = sdscatrepr(sdsempty(),x,sdslen(x)); test_cond("sdscatrepr(...data...)", memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0) &#123; unsigned int oldfree; char *p; int step = 10, j, i; sdsfree(x); sdsfree(y); x = sdsnew("0"); test_cond("sdsnew() free/len buffers", sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0); /* Run the test a few times in order to hit the first two * SDS header types. */ for (i = 0; i &lt; 10; i++) &#123; int oldlen = sdslen(x); x = sdsMakeRoomFor(x,step); int type = x[-1]&amp;SDS_TYPE_MASK; test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen); if (type != SDS_TYPE_5) &#123; test_cond("sdsMakeRoomFor() free", sdsavail(x) &gt;= step); oldfree = sdsavail(x); &#125; p = x+oldlen; for (j = 0; j &lt; step; j++) &#123; p[j] = 'A'+j; &#125; sdsIncrLen(x,step); &#125; test_cond("sdsMakeRoomFor() content", memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0); test_cond("sdsMakeRoomFor() final length",sdslen(x)==101); sdsfree(x); &#125; &#125; test_report() return 0;&#125;#endif#ifdef SDS_TEST_MAINint main(void) &#123; return sdsTest();&#125;#endif]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析: SDS(1)]]></title>
    <url>%2F2017-12-14-Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_SDS_1.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文将介绍 SDS 的头文件. SDS 的头文件包括两个文件: sds.h 和 sdsalloc.h. sds.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/* SDSLib 2.0, 一个 C 实现的 strings 库 */#ifndef __SDS_H#define __SDS_H// 最大预分配给 sds 字符串的空间长度(分配给 sds 字符串的空间最大增长长度)#define SDS_MAX_PREALLOC (1024 * 1024)#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdint.h&gt;// 类别名, 用于指向 sdshdr 的 buf 属性typedef char *sds;// lsb 最低有效位/* 注意: sdshdr5 是永远不会被使用的, 它只是被我们用来直接获取 flags 标记字节. * 这里是记录 SDS strings类型 5 的布局. */struct __attribute__ ((__packed__)) sdshdr5&#123; unsigned char flags; /* 类型为 3 lsb, string 长度为 5 msb. */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8&#123; uint8_t len; /* 被使用 */ uint8_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16&#123; uint16_t len; /* 被使用 */ uint16_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32&#123; uint32_t len; /* 被使用 */ uint32_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64&#123; uint64_t len; /* 被使用 */ uint64_t alloc; /* 不包括头结点和空字节符 */ unsigned char flags; /* 类型为 3 lsb, 5 个没有使用的位 */ char buf[];&#125;;#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3// 麻蛋, C 实现的多态... 吓尿了... // 但是感觉在代码中突然冒出一个 sh 会影响程序的可读性.#define SDS_HDR_VAR(T, s) struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)))#define SDS_HDR(T, s) ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))#define SDS_TYPE_5_LEN(f) ((f) &gt;&gt; SDS_TYPE_BITS)// 获取 sds 实际保存的字符串的长度// T = O(1)static inline size_t sdslen(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;len; &#125; return 0;&#125;// 获取 sds 分配给 sds 字符串的空间的长度与保存的字符串长度之差, 即空闲空间// T = O(1)static inline size_t sdsavail(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32, s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64, s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125;// 设置 sds 实际保存的字符串长度// T = O(1)static inline void sdssetlen(sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len = newlen; break; &#125;&#125;// 设置 sds 实际保存字符串增加的长度// T = O(1)static inline void sdsinclen(sds s, size_t inc)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char *)s) - 1; unsigned char newlen = SDS_TYPE_5_LEN(flags) + inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); //=============================感觉没有必要呀 &#125; break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;len += inc; break; &#125;&#125;/* sdsalloc() = sdsavail() + sdslen() */// 获取 sds 分配给 sds 字符串的空间的长度// T = O(1)static inline size_t sdsalloc(const sds s)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8, s)-&gt;alloc; case SDS_TYPE_16: return SDS_HDR(16, s)-&gt;alloc; case SDS_TYPE_32: return SDS_HDR(32, s)-&gt;alloc; case SDS_TYPE_64: return SDS_HDR(64, s)-&gt;alloc; &#125; return 0;&#125;// 设置分配给 sds 字符串的空间长度// T = O(1)static inline void sdssetalloc(const sds s, size_t newlen)&#123; unsigned char flags = s[-1]; switch(flags &amp; SDS_TYPE_MASK) &#123; case SDS_TYPE_5: /* 不需要做什么事, 这个类型没有分配给 sds 字符串的空间信息 */ break; case SDS_TYPE_8: SDS_HDR(8, s)-&gt;alloc = newlen; break; case SDS_TYPE_16: SDS_HDR(16, s)-&gt;alloc = newlen; break; case SDS_TYPE_32: SDS_HDR(32, s)-&gt;alloc = newlen; break; case SDS_TYPE_64: SDS_HDR(64, s)-&gt;alloc = newlen; break; &#125;&#125;sds sdsnewlen(const void *init, size_t initlen); // 根据给定的字符串 init 和字符串长度 initlen 创建一个新的 sds 并初始化sds sdsnew(const char *init); // 根据给定字符串 init 创建一个包含同样字符串的 sdssds sdsempty(void); // 创建并返回一个只保存了空字符串 "" 的 sdssds sdsdup(const sds s); // 复制给定 sds 的副本void sdsfree(sds s); // 释放 sds. 如果 s 为空, 则不需要干什么sds sdsgrowzero(sds s, size_t len); // 增长字符串, 并将增加的部分置为 0sds sdscatlen(sds s, const void *t, size_t len); // 在 sds 字符串后添加长度为 len 的字符串sds sdscat(sds s, const char *t); // 在 sds 字符串后添加指定以 null 终止的 C 字符串.sds sdscatsds(sds s, const sds t); // 在 sds 字符串后添加指定 sds 字符串.sds sdscpylen(sds s, const char *t, size_t len); // 拷贝二进制安全字符串 't' 到 sds 字符串中.sds sdscpy(sds s, const char *t); // 对 C 字符串进行拷贝sds sdscatvprintf(sds s, const char *fmt, va_list ap); // 将 va_list 中的内容格式化输出添加到 sds 字符串空间中, 这里格式化输出 C 字符串// 将参数格式化输出添加到 sds 字符串中, 这里格式化输出 C 字符串#ifdef __GNUC__sds sdscatprintf(sds s, const char *fmt, ...) __attribute__((format(printf, 2, 3)));#elsesds sdscatprintf(sds s, const char *fmt, ...);#endifsds sdscatfmt(sds s, char const *fmt, ...); // 将可变参数格式化输出添加到 sds 字符串中, 这里格式化输出为 sds 字符串sds sdstrim(sds s, const char *cset); // 删除 sds 字符串首尾在 'cset' 中存在的字符串void sdsrange(sds s, int start, int end); //将字符串转换为一个较小(或相等)的, 仅包含由 'start' 到 'end' 索引指定的子串.void sdsupdatelen(sds s); // 更新 sds 的长度void sdsclear(sds s); // 清空 sds 字符串的内容int sdscmp(const sds s1, const sds s2); // 比较两个字符串sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count); // 分割 's' 保存在 sds 数组中, 二进制安全, 不可以以分隔符结尾void sdsfreesplitres(sds *tokens, int count); // 释放分割的结果void sdstolower(sds s); // 将 sds 字符串 's' 中的字母转换为小写字母void sdstoupper(sds s); // 将 sds 字符串 's' 中的字母转换为大写字母sds sdsfromlonglong(long long value); // long long 类型转换为 sds 类型sds sdscatrepr(sds s, const char *p, size_t len); // 将源字符串所有无法打印的字符转换为转义字符添加到 sds 字符串中, 转义后的字符串在 sds 字符串中被 '"' 包裹.sds *sdssplitargs(const char *line, int *argc); // 将字符串按照 REPL 格式切分成一个 sds 参数数组sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen); // 将 sds 字符串中 'from' 中的字符替换为 'to' 中对应位置的字符sds sdsjoin(char **argv, int argc, char *sep); // 将参数以 sep 为间隔连接成一个 sds 字符串, 二进制不安全sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen); // 类似sdsjoin, 但是是将一个 sds 字符串数组组合成一个 sds 字符串/* 低等级函数作为 API 暴露给用户使用 */sds sdsMakeRoomFor(sds s, size_t addlen);void sdsIncrLen(sds s, int incr);sds sdsRemoveFreeSpace(sds s);size_t sdsAllocSize(sds s);void *sdsAllocPtr(sds s);/* 将 SDS 使用的分配器输出给调用 SDS 的程序使用. * 有时链接 SDS 的程序可能会设置不同的迭代器, 但是可能想要分配或释放 SDS 分别释放或分配的一些东西. */// 封装 SDS 分配器给调用者使用void *sds_malloc(size_t size);void *sds_realloc(void *ptr, size_t size);void sds_free(void *ptr);#ifdef REDIS_TESTint sdsTest(int argc, char *argv[]);#endif#endif sdsalloc.h12345678910111213/* SDSLib 2.0, 一个 C 实现的 strings 库 *//* SDS 选择分配器. * * 使用这个文件是为了在编译时可以改变 SDS 的分配器. * 只需要根据你需要使用的分配器定义宏. * 也需要根据需要 include(导入) 你用来替换的分配器的库 * (使用默认分配器不需要). */#include "zmalloc.h"#define s_malloc zmalloc#define s_realloc zrealloc#define s_free zfree]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 4.0源码解析]]></title>
    <url>%2F2017-12-14-Redis_4_0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于Redis一直想学习源码但是人懒, 一直没有行动也就渐渐没有了想法. 最近工作用到了Redis, 开始学习Redis最基本的用法. 想要学习Redis源码的欲望有冒出来了, 同时由于在工作中一直感觉自己的能力不足, 需要给自己充充电. 于是决定开始阅读Redis源码.&emsp;&emsp;以前一直没有阅读过真正大项目的源码, 真正开始阅读才发现Redis的源码对我来说真的是好庞大, 一个文件上千行代码, 利用工作之余阅读, 尽量做到认真阅读每行代码, 大于要花大半个月的时间, 算算时间可能阅读完Redis源码需要花费的时间要超过一年. 回顾以往经历, 对自己能否坚持下来很是担心. 正好这两天我也在看一个大神的博客, 想自己搞个博客, 写点东西. 所以搞个博客记录一下自己的学习. 一方面可以归纳总结自己所学到的东西, 有不对的地方也可以被其他人指正; 另一方面有人阅读我的文章也是对我的一种激励, 避免一个人独自学习因为无聊而放弃.最开始在网上找到了一份关于Redis 2.8 的中文注释源码, 就开始阅读这份源码. 在阅读过程中查资料时发现了 Redis设计与实现 , 感觉这个本书写的挺不错, 而且也附带有一份关于Redis 3.0 的中文注释源码, 同时由于发现了一处Redis源码中的小问题在向Redis提交代码是发现最新的Redis已经到了4.0版本. 于是决定参考2.8和3.0的源码阅读Redis 4.0版本的源码. 由于对redis还没有一个整体的认识, 所以在阅读过程中可能存在一些错误的认识, 欢迎大家指正. Redis 学习资源 Redis 官网 Redis 中文官方网站 Github 上 Redis 源码 线上 Redis 示范环境 Redis 使用教程 如何阅读 Redis 源码? Redis 设计与实现 Redis 3.0中文注释源码 Redis 2.8源码解析 Reids 2.8中文注释源码]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
