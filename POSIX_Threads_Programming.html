<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">




  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="翻译自: POSIX Threads Programming 摘要在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于UNIX 系统, IEEE POSIX 1003.1c 标准已经规定了一个标准化的 C 语言线程编程接口. 遵循此标准的实现称为 POSIX线程 或 Pthread">
<meta name="keywords" content="翻译,线程">
<meta property="og:type" content="article">
<meta property="og:title" content="POSIX Threads Programming">
<meta property="og:url" content="http://chunqiublog.github.io/POSIX_Threads_Programming.html">
<meta property="og:site_name" content="CHUNQIULFQ">
<meta property="og:description" content="翻译自: POSIX Threads Programming 摘要在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于UNIX 系统, IEEE POSIX 1003.1c 标准已经规定了一个标准化的 C 语言线程编程接口. 遵循此标准的实现称为 POSIX线程 或 Pthread">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/unix_process.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threads_within_a_unix_process.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/fork_and_pthread.png">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/MPI_and_pthread.png">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Click_for_larger_image.jpg">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/concurrent.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/shared_Memory_Model.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread_Unsafe.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Compiling_Threaded_Programs.png">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/process%28thread%29_num_limit.png">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/peer_Threads.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/joining.gif">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/race_conditions.png">
<meta property="og:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/error_lock_unlock.png">
<meta property="og:updated_time" content="2018-10-07T04:07:59.857Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="POSIX Threads Programming">
<meta name="twitter:description" content="翻译自: POSIX Threads Programming 摘要在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于UNIX 系统, IEEE POSIX 1003.1c 标准已经规定了一个标准化的 C 语言线程编程接口. 遵循此标准的实现称为 POSIX线程 或 Pthread">
<meta name="twitter:image" content="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/unix_process.gif">



  <link rel="alternate" href="/atom.xml" title="CHUNQIULFQ" type="application/atom+xml" />




  <link rel="canonical" href="http://chunqiublog.github.io/POSIX_Threads_Programming.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>POSIX Threads Programming | CHUNQIULFQ</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CHUNQIULFQ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">技术博客</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">12</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">2</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">8</span></a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chunqiublog.github.io/POSIX_Threads_Programming.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chunqiulfq">
      <meta itemprop="description" content="黄沙百战穿金甲 不破楼兰终不还">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHUNQIULFQ">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">POSIX Threads Programming
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-02 12:45:32" itemprop="dateCreated datePublished" datetime="2018-09-02T12:45:32+08:00">2018-09-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-07 12:07:59" itemprop="dateModified" datetime="2018-10-07T12:07:59+08:00">2018-10-07</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p><em>翻译自: <a href="https://computing.llnl.gov/tutorials/pthreads" target="_blank" rel="noopener">POSIX Threads Programming</a></em></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在共享内存多处理器体系结构中, 线程被用来实现并行. 在历史上, 硬件供应商已经实现了他们自己专有的线程版本, 这使得多线程代码的可移植性称为软件开发者关心的问题. 对于<code>UNIX</code> 系统, <code>IEEE POSIX 1003.1c</code> 标准已经规定了一个标准化的 <code>C</code> 语言线程编程接口. 遵循此标准的实现称为 <code>POSIX线程</code> 或 <code>Pthreads</code>.</p>
<p>本教程首先介绍使用Pthreads的概念, 动机和设计意图. 然后介绍 <code>Pthreads API</code> 中三大种类每一种示例程序: 线程管理, 互斥变量和条件变量. 示例代码始终被用来演示一个新的 <code>Pthreads</code> 程序员所需要的如何使用大多数 <code>Pthread</code>. 本教程最后讨论了 <code>LLNL</code> 细节以及如何将 <code>MPI</code> 与 <code>Pthreads</code> 混合使用. 还包括一个实验练习, 其中包含大量示例代码(C语言).</p>
<p>水平/先决条件: 本教程非常适合那些不熟悉<code>Pthreads</code>并行编程的人. 需要对 <code>C</code> 中的并行编程有基本的了解. 对于那些一般不熟悉并行编程的人来说, <a href="https://computing.llnl.gov/tutorials/parallel_comp" target="_blank" rel="noopener">EC3500: Introduction to Parallel Computing</a> 中的内容有所帮助.</p>
<a id="more"></a>
<h2 id="Pthreads-Overview-Pthreads-概述"><a href="#Pthreads-Overview-Pthreads-概述" class="headerlink" title="Pthreads Overview(Pthreads 概述)"></a><code>Pthreads Overview</code>(<code>Pthreads</code> 概述)</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程?"></a>什么是线程?</h3><ul>
<li>从技术上讲, 线程被定义为一个可以被操作系统调度运行的独立指令流. 但是这是什么意思?</li>
<li>对于软件开发者来说, 独立于其主程序运行的 <code>procedure(过程)</code> 的概念可能可以最好的描述一个线程.</li>
<li>更进一步来说, 假设一个一个主程序(a.out)有多个过程, 这些过程可以被操作系统调度的同时和/或独立运行. 这被称作一个 <code>multi-threaded</code> 程序.</li>
<li>这是如何完成的?</li>
<li>在理解线程之前, 首先需要理解 <code>UNIX</code> 进程. 进程由操作系统创建, 需要相当数量的开销负担. 进程包含有关程序资源和程序执行状态的信息如下:<ul>
<li>进程ID, 进程组ID, 用户ID, 用户组ID</li>
<li>环境变量</li>
<li>工作目录</li>
<li>寄存器</li>
<li>栈</li>
<li>堆</li>
<li>文件描述符</li>
<li>信号</li>
<li>动态库</li>
<li>进程间通信工具(如消息队列, 管道, 信号量或共享内存)</li>
</ul>
</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/unix_process.gif" alt="UNIX PROCESS"></p>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threads_within_a_unix_process.gif" alt="THREADS WITHIN A UNIX PROCESS"></p>
<ul>
<li>线程使用进程的资源并存在于进程中, 但是线程能够由操作系统调度并作为独立实体运行, 主要是因为线程只复制了使它们可以作为可执行代码存在的基本必需资源.</li>
<li>这种独立的控制流程能够完成是因为线程维持了它独有的:<ul>
<li>堆栈指针</li>
<li>寄存器</li>
<li>调度属性(例如策略或优先级)</li>
<li>一组待处理和阻止的信号</li>
</ul>
</li>
<li>总而言之, <code>UNIX</code> 环境中的一个线程:<ul>
<li>存在于一个进程中, 并使用该进程的资源.</li>
<li>只要线程的父进程存在且操作系统支持, 它就有自己独立的控制流程.</li>
<li>仅复制其可独立调度所需的基本资源.</li>
<li>可以与其他线程共享进程资源, 这些线程同样是独立地, 并且依赖于进程存在.</li>
<li>如果父进程死亡则死亡(or something similar).</li>
<li>是 <code>lightweight(轻量级)</code> 的, 因为大部分开销已经通过创建进程完成了.</li>
</ul>
</li>
<li>因为同一进程中的线程共享资源:<ul>
<li>所有其他线程将看到一个线程对共享系统资源(例如关闭文件)所做的更改.</li>
<li>具有相同值的两个指针指向相同的数据.</li>
<li>可以读取和写入相同的存储器位置, 因此需要程序员进行显式同步.</li>
</ul>
</li>
</ul>
<h3 id="什么是-Pthreads"><a href="#什么是-Pthreads" class="headerlink" title="什么是 Pthreads?"></a>什么是 <code>Pthreads</code>?</h3><ul>
<li>在历史上, 硬件供应商已经实现了他们自己专有的线程版本. 这些实现彼此差异很大使得程序员很难开发具有可移植性的线程应用程序.</li>
<li>为了充分利用线程提供的功能, 需要标准化的编程接口:<ul>
<li>对于 <code>UNIX</code> 系统, 该接口已由 <code>IEEE POSIX 1003.1c</code> 标准(1995)指定.</li>
<li>遵循此标准的实现称为 <code>POSIX</code> 线程或 <code>Pthreads</code>.</li>
<li>除了专有 <code>API</code> 之外，大多数硬件供应商现在都提供 <code>Pthreads</code>.</li>
</ul>
</li>
<li><code>POSIX</code> 标准(包括 <code>Pthreads</code> 规范)仍在不断发展和修订.</li>
<li>一些有用的链接:<ul>
<li><a href="standards.ieee.org/findstds/standard/1003.1-2008.html">standards.ieee.org/findstds/standard/1003.1-2008.html</a></li>
<li><a href="www.unix.org/version3/ieee_std.html">www.unix.org/version3/ieee_std.html</a></li>
<li><a href="www.unix.org/version3/ieee_std.html">www.unix.org/version3/ieee_std.html</a></li>
</ul>
</li>
<li><code>Pthread</code> 被定义为一组 <code>C</code> 语言类型和函数调用, 使用 <code>pthread.h</code> 头文件和一个线程库实现(尽管在某些实现中该库可能是另一个库的一部分, 例如 <code>libc</code>).</li>
</ul>
<h3 id="为什么选择-Pthreads"><a href="#为什么选择-Pthreads" class="headerlink" title="为什么选择 Pthreads?"></a>为什么选择 <code>Pthreads</code>?</h3><h4 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h4><ul>
<li>与创建和管理进程的成本相比, 可以创建一个具有更少操作系统开销的线程. 管理线程比管理进程需要更少的系统资源.</li>
<li>例如, 下表比较了 <code>fork()</code> 子函数和 <code>pthread_create()</code> 子函数的计时结果. 使用 <code>time</code> 程序计时反映了50000个进程/线程创建, 单位是秒, 没有使用编译优化.</li>
</ul>
<p>注意: 不要期望 <code>sys time</code> + <code>user time</code> 等于 <code>real time</code>, 因为这是具有多个 <code>CPUs/cores</code> 的 <code>SMP</code> 系统同时处理该问题.</p>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/fork_and_pthread.png" alt="fork() vs pthread_create()"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*==============================================================================</span></span><br><span class="line"><span class="comment">C Code for fork() creation test</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFORKS 50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid, j, status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NFORKS; j++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** error handling ***/</span></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"fork failed with error code= %d\n"</span>, pid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** this is the child of the fork ***/</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid ==<span class="number">0</span>) &#123;</span><br><span class="line">    do_nothing();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*** this is the parent of the fork ***/</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    waitpid(pid, status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================================</span></span><br><span class="line"><span class="comment">C Code for pthread_create() test</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_nothing</span><span class="params">(<span class="keyword">void</span> *null)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;                      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc, i, j, detachstate;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NTHREADS; j++) &#123;</span><br><span class="line">  rc = pthread_create(&amp;tid, &amp;attr, do_nothing, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (rc) &#123;              </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the thread */</span></span><br><span class="line">  rc = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_join() is %d\n"</span>, rc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/fork_vs_thread.txt" target="_blank" rel="noopener">source</a></p>
<h4 id="高效的通信-数据交换"><a href="#高效的通信-数据交换" class="headerlink" title="高效的通信/数据交换"></a>高效的通信/数据交换</h4><ul>
<li>考虑在高性能计算环境中使用 <code>Pthreads</code> 的主要动机是为了实现最佳性能, 特别是当应用程序使用 <code>MPI</code> 进行节点间通信时, 通过使用 <code>Pthreads</code> 可以改善性能.</li>
<li>MPI</li>
<li>对于Pthreads, 可以不需要中间内存复制, 因为线程在单个进程中共享同一地址空间; 可以通过指针方便的实现高效的数据传递.</li>
<li>在最坏的情况下, <code>Pthreads</code> 通信速度更多的变成了缓存到 <code>CPU</code> 或内存到 <code>CPU</code> 的带宽问题, 但是这样的速度仍然远高于 <code>MPI</code> 共享内存通信的速度.</li>
<li>例如: 这里有一些过去和当前的对比数据如下所示:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/MPI_and_pthread.png" alt="MPI and Pthreads"></p>
<h4 id="其他常见原因"><a href="#其他常见原因" class="headerlink" title="其他常见原因"></a>其他常见原因</h4><ul>
<li>与非线程应用程序相比, 线程应用程序在以下几个方面提供了潜在的性能提升和实用优势:<ul>
<li>当进行 <code>I/O</code> 操作时使用 <code>CPU</code>: 例如, 一个程序可能有长时间 <code>I/O</code> 操作的部分, 当一个线程正在等待 <code>I/O</code> 系统调用完成时, 其他线程可以执行 <code>CPU</code> 密集型工作.</li>
<li>优先级/实时调度: 更重要的任务可以被调度取代或重大优先级更低的任务.</li>
<li>异步的事件处理: 可以交错执行有不确定频率和持续时间的服务事件的任务. 例如, <code>Web</code> 服务器既可以从先前的请求传输数据, 也可以管理新请求的到达.</li>
</ul>
</li>
<li>一个完美的例子是典型的 <code>Web</code> 浏览器, 其中许多交错任务可以同时发生, 并且任务可以在优先级上变化.</li>
<li>另一个很好的例子是现代操作系统, 线程得到了广泛使用, <code>MS Windows</code> 操作系统和使用线程的应用程序的屏幕截图如下所示:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Click_for_larger_image.jpg" alt="Click for larger image"></p>
<h3 id="设计线程程序"><a href="#设计线程程序" class="headerlink" title="设计线程程序"></a>设计线程程序</h3><h4 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h4><ul>
<li>在现代的多核机器上, <code>Pthreads</code> 非常适合并行编程. 适用于一般并发编程的都可以使用并发线程程序.</li>
<li>设计并行程序有很多注意事项, 例如:<ul>
<li>使用什么类型的并行编程模型?</li>
<li>问题分区</li>
<li>负载均衡</li>
<li>通信</li>
<li>数据依赖性</li>
<li>同步和竞争条件</li>
<li>内存问题</li>
<li><code>I/O</code> 问题</li>
<li>程序复杂性</li>
<li>程序员的努力/成本/时间</li>
<li>…</li>
</ul>
</li>
<li>这些问题超出了本教程涵盖的范围, 但是感兴趣的读者可以在<a href="https://computing.llnl.gov/tutorials/parallel_comp/" target="_blank" rel="noopener">Introduction to Parallel Computing</a>教程中快速了解概念.</li>
<li>通常, 为了能够利用 <code>Pthreads</code>, 程序必须能够组织成分散的可以并发执行的独立任务. 例如, 如果函数1和函数2可以被交替执行(实时交错和/或重叠), 它们将可以成为线程.</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/concurrent.gif" alt="concurrent"></p>
<ul>
<li>具有以下特征的程序可能非常适合 <code>Pthreads</code>:<ul>
<li>同时由多个任务执行的工作或操作的数据</li>
<li>因为长时间 <code>I/O</code> 产生的阻塞</li>
<li>一些地方消耗大量 <code>CPU</code> 周期, 其他地方不消耗(<code>CPU</code> 使用不均匀)</li>
<li>必须响应的异步事件</li>
<li>有些工作比其他工作更重要(优先中断)</li>
</ul>
</li>
<li>存在几种用于线程程序的常见模型<ul>
<li><code>Manager/worker</code>: 在一个线程(<code>manager</code>)中将工作分配给其他线程(<code>worker</code>). 通常, <code>manager</code> 处理所有输入和封装工作到其他任务中. 在 <code>manager/worker</code> 模式中至少有两种形式是常见的: 静态线程池和动态线程池.</li>
<li><code>Pipeline</code>: 任务被分解为一系列子操作, 每个子操作都是串行处理的, 但由不同的线程并行处理. 汽车装配线最能描述这种模型.</li>
<li><code>Peer</code>: 类似于 <code>manager/worker</code> 模型, </li>
</ul>
</li>
</ul>
<h4 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h4><ul>
<li>所有线程都可以访问相同的全局共享内存</li>
<li>线程也有自己的私有数据</li>
<li>程序员负责同步访问(保护)全局共享数据</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/shared_Memory_Model.gif" alt="Shared Memory Model"></p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul>
<li>线程安全: 简而言之, 指一个程序具有同时执行多个线程而不破坏共享数据或产生 <code>race conditions</code> 的能力.</li>
<li>例如, 假设你的应用程序创造几个线程, 每一个线程都调用同一个库函数:<ul>
<li>这个库函数访问或修改一个全局结构体或指针.</li>
<li>每一个线程可能会调用这个函数在同一时间去尝试修改这个全局结构体或指针.</li>
<li>如果函数不使用某种同步的修改方式来防止数据损坏, 那么这个它就不是线程安全的.</li>
</ul>
</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread_Unsafe.gif" alt="Thread Unsafe"></p>
<ul>
<li>这意味着使用外部库函数如果不能 <code>100%</code> 确定它是线程安全的, 那么就需要抓住机会解决可能出现的问题.</li>
<li>建议: 如果应用程序使用没有明确保证线程安全的库或对象, 请务必小心. 如果对线程安全有疑问, 那么除非另有证明, 否则假设它不是线程安全的. 可以通过有序访问有疑问的函数等方式保证线程安全.</li>
</ul>
<h4 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h4><ul>
<li>尽管 <code>Pthreads API</code> 是 <code>ANSI/IEEE</code> 标准, 但是它的实现方式标准并未指定, 通常在不同平台会有所变化.</li>
<li>因此, 在一个平台上运行良好的程序, 在另一个平台上运行可能失败或产生错误.</li>
<li>例如, 允许的最大线程数和默认线程堆栈大小是设计程序时要考虑的两个重要限制.</li>
<li>本教程后面将详细讨论几个线程的限制.</li>
</ul>
<h2 id="The-Pthreads-API"><a href="#The-Pthreads-API" class="headerlink" title="The Pthreads API"></a><code>The Pthreads API</code></h2><ul>
<li><code>ANSI / IEEE POSIX 1003.1-1995</code> 标准中定义了最初的 <code>Pthreads API</code>. <code>POSIX</code> 标准(包括 <code>Pthreads</code> 规范)在不断发展和修订.</li>
<li>标准的副本可以从IEEE购买或从其他网站免费下载.</li>
<li>组成 <code>Pthreads API</code> 的函数可以被非正式的划分为四个类别:<ul>
<li>线程管理: 直接作用于线程的函数 - <code>creating</code>, <code>detaching</code>, <code>joining</code>, 等. 还包括设置/查询线程属性的函数(<code>joinable</code>, <code>scheduling</code>, 等).</li>
<li>互斥锁: 处理同步的函数, 被称为 <code>mutex</code>, 是 <code>mutual exclusion</code> 的缩写. 互斥函数提供 <code>creating</code>, <code>destroying</code>, <code>locking</code> 和 <code>unlocking</code> 互斥锁功能. 还包括用于设置或修改与互斥锁相关联属性的互斥锁属性函数.</li>
<li>条件变量: 解决共享互斥锁的线程之间的通信问题的函数. 这基于程序员指定的条件. 这一类包括基于指定条件变量的 <code>create</code>, <code>destroy</code>, <code>wait</code> 和 <code>signal</code> 函数. 还包括用于设置/查询条件变量属性的函数.</li>
<li>同步: 管理读写锁和同步屏障(barriers)的函数.</li>
</ul>
</li>
<li>命名约定: 线程库以 <code>pthread_</code> 开头作为标识. 如下有一些例子:</li>
</ul>
<table>
<thead>
<tr>
<th>Routine Prefix</th>
<th>Functional Group</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_</td>
<td>线程本身和杂项的函数</td>
</tr>
<tr>
<td>pthread_attr_</td>
<td>线程属性对象</td>
</tr>
<tr>
<td>Pthread_mutex_</td>
<td>互斥锁</td>
</tr>
<tr>
<td>pthread_mutexattr_</td>
<td>互斥锁属性对象</td>
</tr>
<tr>
<td>pthread_cond_</td>
<td>环境变量</td>
</tr>
<tr>
<td>pthread_condattr_</td>
<td>环境变量属性对象</td>
</tr>
<tr>
<td>pthread_key_</td>
<td>用于特定线程的数据密钥</td>
</tr>
<tr>
<td>pthread_rwlock_</td>
<td>读写锁</td>
</tr>
<tr>
<td>pthread_barrier_</td>
<td>同步屏障</td>
</tr>
</tbody>
</table>
<ul>
<li>不透明对象的概念遍及API的设计. 基本调用用于创建或修改不透明对象 - 可以通过调用属性函数来修改和处理不透明对象.</li>
<li><code>Pthreads API</code> 包含大约100个子函数. 本教程将重点介绍其中的一部分 - 特别是那些对刚刚开始使用 <code>Pthreads</code> 的程序有用的内容.</li>
<li>为了可移植性, 在使用 <code>Pthreas</code> 库时应该将 <code>pthread.h</code> 包含在每个源文件中.</li>
<li>当前的 <code>POSIX</code> 标准仅针对 <code>C</code> 语言定义. <code>Fortran</code> 程序员可以使用 <code>C</code> 函数调用的封装. 一些 <code>Fortran</code> 编译器可能提供 <code>Fortran pthreads API</code>.</li>
<li>有很多关于Pthreads的优秀书籍. 其中一些列在本教程的<a href="#参考和更多信息">参考</a>部分中.</li>
</ul>
<h2 id="编译线程程序"><a href="#编译线程程序" class="headerlink" title="编译线程程序"></a>编译线程程序</h2><ul>
<li>下表列出了几个用于 <code>Pthreads</code> 代码的编译命令示例:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Compiling_Threaded_Programs.png" alt="Compiling Threaded Programs"></p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="创建和终止线程"><a href="#创建和终止线程" class="headerlink" title="创建和终止线程"></a>创建和终止线程</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul>
<li>最开始, <code>main()</code> 函数包含一个默认线程. 所有其他线程必须由程序员显式创建.</li>
<li><code>pthread_create</code> 创建一个新的线程并执行它. 这个函数可以在代码任何位置任意调用.</li>
<li><code>pthread_create</code> 参数:<ul>
<li><code>thread</code>: 输出参数, 新线程唯一的不透明标识符.</li>
<li><code>attr</code>: 可用于设置线程属性的不透明属性对象. 你可以指定一个线程属性对象或使用 <code>NULL</code> 的默认值.</li>
<li><code>start_routine</code>: 线程创建后执行的 <code>C</code> 函数.</li>
<li><code>arg</code>: 传递给 <code>start_routine</code> 的单个参数, 必须通过转换为 <code>void</code> 类型指针进行传递. 如果不传递参数, 可以使用 <code>NULL</code>.</li>
</ul>
</li>
<li>进程可以创建的最大线程数取决于系统设置. 尝试超出限制的程序可能会失败或产生错误的结果.</li>
<li>这里以 <code>Linux</code> 为例, 介绍查询和设置系统的线程限制. 下图演示查询默认线程(软)限制, 然后将最大进程(包括线程)数设置为硬限制, 验证设置是否成功.</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/process%28thread%29_num_limit.png" alt="Process(thread) Num Limit"></p>
<ul>
<li>一旦创建完成, 线程之间就是平等的, 并且可以创建其他线程. 线程之间没有隐含的层次结构或依赖关系.</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/peer_Threads.gif" alt="Peer Threads"></p>
<h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><ul>
<li>在默认情况下, 使用某些属性创建一个线程. 这些属性可以被程序员通过线程属性对象修改.</li>
<li><code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 初始化/销毁线程属性对象.</li>
<li>之后使用其他函数查询/设置线程属性对象中的特定属性. 属性包括:<ul>
<li><code>Detached</code>(已分离)或 <code>joinable</code>(可合并)状态</li>
<li><code>Scheduling inheritance</code></li>
<li><code>Scheduling policy</code>(调度策略)</li>
<li><code>Scheduling parameters</code>(调度参数)</li>
<li><code>Scheduling contention scope</code></li>
<li>栈大小</li>
<li>栈地址</li>
<li><code>Stack guard (overflow) size</code></li>
</ul>
</li>
<li>其中一些属性将在后面讨论.</li>
</ul>
<h4 id="线程的绑定和调度"><a href="#线程的绑定和调度" class="headerlink" title="线程的绑定和调度"></a>线程的绑定和调度</h4><ul>
<li><strong>问题</strong>: 当一个线程被创建后, 你如何知道:<ul>
<li>操作系统何时调度它运行?</li>
<li>它将运行在哪个 <code>CPU/core</code>?</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>答案: 除非你使用 <code>Pthreads</code> 调度机制, 否则线程的执行位置和时间将由操作系统和系统设置决定. 健壮的程序不应该依赖于以特定顺序或在特定 <code>CPU/core</code> 执行的线程.</em></p>
</blockquote>
<ul>
<li><code>Pthreads API</code> 提供了几个用于指定线程执行调度方式的函数. 例如, 可以将线程以 <code>FIFO</code>(先进先出), <code>RR</code>(循环), <code>OTHER</code>(操作系统确定) 等方式调度. 它还提供了设置线程调度优先级的功能.</li>
<li>本教程没有涉及这个话题, 但是在 <code>man page</code> 的 <a href="https://computing.llnl.gov/tutorials/pthreads/man/sched_setscheduler.txt" target="_blank" rel="noopener"><code>sched_setscheduler</code></a> 中有它 <code>工作原理</code> 的概述.</li>
<li><code>Pthreads API</code> 不提供将线程绑定到特定 <code>CPU/core</code> 的函数. 但系统的线程库可能提供了自己实现的这个功能 - 例如提供一个非标准的 <a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt" target="_blank" rel="noopener"><code>pthread_setaffinity_np</code></a> 函数. 请注意, 名称中的 <code>_np</code> 代表 <code>非便携式</code>.</li>
<li>此外, 操作系统自身也提供这种功能的方法, 例如 <code>Linux</code> 提供了 <a href="https://computing.llnl.gov/tutorials/pthreads/man/sched_setaffinity.txt" target="_blank" rel="noopener"><code>sched_setaffinity</code></a> 函数.</li>
</ul>
<h4 id="终止线程-amp-exit"><a href="#终止线程-amp-exit" class="headerlink" title="终止线程 &amp; exit()"></a>终止线程 &amp; <code>exit()</code></h4><ul>
<li>有几种方法可以终止一个线程:<ul>
<li>线程执行完启动函数正常退出, 它已经完成工作.</li>
<li>线程调用 <code>pthread_exit</code> 子函数 - 无论其工作是否完成都会退出.</li>
<li>线程由另一个线程通过 <code>pthread_cancel</code> 函数取消.</li>
<li>线程调用 <code>exec()</code> 整个进程将终止被替换为另一个进程; 调用 <code>exit()</code> 这个进程将终止.</li>
<li>主线程 <code>main()</code> 首先完成, 其他线程将在没有调用 <code>pthread_exit</code> 的情况下终止.</li>
</ul>
</li>
<li><code>pthread_exit()</code> 函数允许程序员指定一个可选的终止 <code>retval</code> 参数. 此可选参数通常返回到 <code>joining</code> 终止线程的线程中(稍后介绍).</li>
<li>除非想要传回可选参数, 否则在正常执行完成的子程序中, 可以省去调用 <code>pthread_exit()</code>.</li>
<li>清理: <code>pthread_exit()</code> 函数不会关闭文件; 在线程终止后, 线程内打开的任何文件都将保持打开状态.</li>
<li>在 <code>main()</code> 中调用 <code>pthread_exit()</code> 的讨论:<ul>
<li>如果你没有显式调用 <code>pthread_exit()</code>, 但是 <code>main()</code> 函数先于它创建的线程退出, 那么肯定存在问题. <code>main()</code> 创建的所有线程都将终止, 因为它已经退出, 不在支持其他线程.</li>
<li><code>main()</code> 可以通过在最后显式调用 <code>pthread_exit()</code>, <code>main()</code> 将阻塞并保持活跃状态以支持它创建的线程, 直到它们完成为止.</li>
</ul>
</li>
</ul>
<h4 id="示例-线程的创建和终止"><a href="#示例-线程的创建和终止" class="headerlink" title="示例: 线程的创建和终止"></a>示例: 线程的创建和终止</h4><ul>
<li>这是使用 <code>pthread_create()</code> 函数创建 5 个线程的简单示例代码. 每个线程输出 <code>Hello World!</code> 消息, 然后调用 <code>pthread_exit()</code> 退出.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program.  Demonstrates thread creation and</span></span><br><span class="line"><span class="comment">*   termination.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 08/09/11</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS	5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">   tid = (<span class="keyword">long</span>)threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello World! It's me, thread #%ld!\n"</span>, tid);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">long</span> t;</span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In main: creating thread %ld\n"</span>, t);</span><br><span class="line">     rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *)t);</span><br><span class="line">     <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello.out" target="_blank" rel="noopener">output</a></p>
<h3 id="将参数传递给线程"><a href="#将参数传递给线程" class="headerlink" title="将参数传递给线程"></a>将参数传递给线程</h3><ul>
<li><code>pthread_create()</code> 线程允许程序员将一个参数传递给线程的启动函数. 对于必须传递多个参数的情况, 可以创建一个包含所有参数的结构体, 在 <code>pthread_create()</code> 函数中传递这个结构体的指针实现.</li>
<li>所有参数必须通过引用传递并转换为 <code>(void *)</code> 类型.</li>
<li><strong>问题</strong>: 考虑在不确定线程是否启动和调度的情况下, 如何将数据安全的传递给新创建的线程?</li>
</ul>
<blockquote>
<p><em>答案: 确保所有的数据都是线程安全的 - 数据不能被其他线程更改. 接下来的三个示例说明什么是可以做的, 什么是不能做的.</em></p>
</blockquote>
<h4 id="线程参数传递示例"><a href="#线程参数传递示例" class="headerlink" title="线程参数传递示例"></a>线程参数传递示例</h4><ul>
<li>这个代码展示了如何将简单的整型传递给每一个参数. 使用唯一的数据结构变量调用线程, 以确保每个线程的参数在整个程序中保持不变.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg1.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program which demonstrates one safe way</span></span><br><span class="line"><span class="comment">*   to pass arguments to threads during thread creation.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 08/04/15</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS	8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *messages[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> taskid;</span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   taskid = (<span class="keyword">long</span>) threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %d: %s\n"</span>, taskid, messages[taskid]);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">long</span> taskids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc, t;</span><br><span class="line"></span><br><span class="line">    messages[<span class="number">0</span>] = <span class="string">"English: Hello World!"</span>;</span><br><span class="line">    messages[<span class="number">1</span>] = <span class="string">"French: Bonjour, le monde!"</span>;</span><br><span class="line">    messages[<span class="number">2</span>] = <span class="string">"Spanish: Hola al mundo"</span>;</span><br><span class="line">    messages[<span class="number">3</span>] = <span class="string">"Klingon: Nuq neH!"</span>;</span><br><span class="line">    messages[<span class="number">4</span>] = <span class="string">"German: Guten Tag, Welt!"</span>; </span><br><span class="line">    messages[<span class="number">5</span>] = <span class="string">"Russian: Zdravstvuyte, mir!"</span>;</span><br><span class="line">    messages[<span class="number">6</span>] = <span class="string">"Japan: Sekai e konnichiwa!"</span>;</span><br><span class="line">    messages[<span class="number">7</span>] = <span class="string">"Latin: Orbis, te saluto!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        taskids[t] = t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %d\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) taskids[t]);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg1.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg1.out" target="_blank" rel="noopener">output</a></p>
<ul>
<li>这个示例显示了如何通过结构体设置/传递多个参数. 每个线程都接收一个唯一的结构体实例.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg2.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   A "hello world" Pthreads program which demonstrates another safe way</span></span><br><span class="line"><span class="comment">*   to pass arguments to threads during thread creation.  In this case,</span></span><br><span class="line"><span class="comment">*   a structure is used to pass multiple arguments.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 01/29/09</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS	8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *messages[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span>	thread_id;</span><br><span class="line">   <span class="keyword">int</span>  sum;</span><br><span class="line">   <span class="keyword">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">thread_data_array</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadarg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> taskid, sum;</span><br><span class="line">   <span class="keyword">char</span> *hello_msg;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> *<span class="title">my_data</span>;</span></span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line">   taskid = my_data-&gt;thread_id;</span><br><span class="line">   sum = my_data-&gt;sum;</span><br><span class="line">   hello_msg = my_data-&gt;message;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %d: %s  Sum=%d\n"</span>, taskid, hello_msg, sum);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> *taskids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc, t, sum;</span><br><span class="line"></span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    messages[<span class="number">0</span>] = <span class="string">"English: Hello World!"</span>;</span><br><span class="line">    messages[<span class="number">1</span>] = <span class="string">"French: Bonjour, le monde!"</span>;</span><br><span class="line">    messages[<span class="number">2</span>] = <span class="string">"Spanish: Hola al mundo"</span>;</span><br><span class="line">    messages[<span class="number">3</span>] = <span class="string">"Klingon: Nuq neH!"</span>;</span><br><span class="line">    messages[<span class="number">4</span>] = <span class="string">"German: Guten Tag, Welt!"</span>; </span><br><span class="line">    messages[<span class="number">5</span>] = <span class="string">"Russian: Zdravstvytye, mir!"</span>;</span><br><span class="line">    messages[<span class="number">6</span>] = <span class="string">"Japan: Sekai e konnichiwa!"</span>;</span><br><span class="line">    messages[<span class="number">7</span>] = <span class="string">"Latin: Orbis, te saluto!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        sum = sum + t;</span><br><span class="line">        thread_data_array[t].thread_id = t;</span><br><span class="line">        thread_data_array[t].sum = sum;</span><br><span class="line">        thread_data_array[t].message = messages[t];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %d\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) </span><br><span class="line">                            &amp;thread_data_array[t]);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg2.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg2.out" target="_blank" rel="noopener">output</a></p>
<ul>
<li>这个示例是不正确的参数传递方式. 传递变量 <code>t</code> 的地址会使所有线程可见并且共享内存地址空间.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: hello_arg3.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This "hello world" Pthreads program demonstrates an unsafe (incorrect)</span></span><br><span class="line"><span class="comment">*   way to pass thread arguments at thread creation.  In this case, the</span></span><br><span class="line"><span class="comment">*   argument variable is changed by the main thread as it creates new threads.</span></span><br><span class="line"><span class="comment">* AUTHOR: Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED: 07/16/14</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> taskid;</span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   taskid = *(<span class="keyword">long</span> *)threadid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld\n"</span>, taskid);</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_THREADS;t++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Creating thread %ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="keyword">void</span> *) &amp;t);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg3.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/hello_arg3.out" target="_blank" rel="noopener">output</a></p>
<h3 id="合并和分离线程"><a href="#合并和分离线程" class="headerlink" title="合并和分离线程"></a>合并和分离线程</h3><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> threadid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> threadid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="合并-Joining"><a href="#合并-Joining" class="headerlink" title="合并(Joining)"></a>合并(<code>Joining</code>)</h4><ul>
<li>“Joining” 是一种完成后的线程与其他线程同步的方式. 例如:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/joining.gif" alt="joining"></p>
<ul>
<li><code>pthread_join()</code> 子函数会阻塞当前的线程执行, 直到 <code>threadid</code> 指定的线程终止.</li>
<li>如果 <code>status</code> 参数在 <code>threadid</code> 指定的目标线程调用 <code>pthread_exit()</code> 中被设置, 那么程序员可以在目标线程终止时获取到 <code>status</code>.</li>
<li>一个合并的线程可以匹配一个 <code>pthread_join()</code> 调用. 尝试多次合并同一个线程是一个逻辑错误.</li>
<li>另外两种同步方式互斥和条件变量将在后面讨论.</li>
</ul>
<h4 id="是否为可合并的"><a href="#是否为可合并的" class="headerlink" title="是否为可合并的"></a>是否为可合并的</h4><ul>
<li>当一个线程被创建时, 它的其中一个属性的定义就是该线程是可合并的还是已分离的. 只有以可合并属性创建的线程才可以被合并. 如果一个线程以已分离属性创建, 那么它将永远不能被合并.</li>
<li><code>POSIX</code> 标准的最终草案规定默认情况下线程应该以可合并属性创建.</li>
<li>想要显式的以可合并或已分离属性创建一个线程, 要使用 <code>pthread_create()</code> 函数中的 <code>attr</code> 参数. 典型的 4 步流程是:<ol>
<li>声明一个 <code>pthread_attr_t</code> 数据类型的线程属性变量.</li>
<li>使用 <code>pthread_attr_init()</code> 初始化属性变量.</li>
<li>使用 <code>pthread_attr_setdetachstate()</code> 设置属性分离状态.</li>
<li>当设置完成时, 使用 <code>pthread_attr_destroy()</code> 释放使用的库资源.</li>
</ol>
</li>
</ul>
<h4 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h4><ul>
<li><code>pthread_detach()</code> 函数可以显式分离一个线程, 即使这个线程以可合并属性被创建.</li>
<li>没有作用相反的函数.</li>
</ul>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>如果一个线程需要合并, 请考虑显式的以可合并属性创建它. 这样做到了可移植性, 因为并非所有实现方式都是默认以可合并属性创建线程.</li>
<li>如果你提前知道一个线程将永远不会需要合并到另一个线程, 请考虑使用已分离状态创建它. 这样可以释放一些系统资源.</li>
</ul>
<h4 id="线程合并示例"><a href="#线程合并示例" class="headerlink" title="线程合并示例"></a>线程合并示例</h4><ul>
<li>这个示例演示了如何使用 <code>Pthread join</code> 函数”等待”线程完成.</li>
<li>因为一些 <code>Pthread</code> 的实现可能不是默认使用可合并状态创建线程, 所以这个示例中的线程是显式的使用可合并状态去创建, 以便后面进行合并.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: join.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This example demonstrates how to "wait" for thread completions by using</span></span><br><span class="line"><span class="comment">*   the Pthread join routine.  Threads are explicitly created in a joinable</span></span><br><span class="line"><span class="comment">*   state for portability reasons. Use of the pthread_exit status argument is </span></span><br><span class="line"><span class="comment">*   also shown. Compare to detached.c</span></span><br><span class="line"><span class="comment">* AUTHOR: 8/98 Blaise Barney</span></span><br><span class="line"><span class="comment">* LAST REVISED:  01/30/09</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS	4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">BusyWork</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line">   <span class="keyword">double</span> result=<span class="number">0.0</span>;</span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %ld starting...\n"</span>,tid);</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      result = result + <span class="built_in">sin</span>(i) * <span class="built_in">tan</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Thread %ld done. Result = %e\n"</span>,tid, result);</span><br><span class="line">   pthread_exit((<span class="keyword">void</span>*) t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread[NUM_THREADS];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="keyword">void</span> *status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize and set thread detached attribute */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NUM_THREADS; t++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: creating thread %ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (<span class="keyword">void</span> *)t); </span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free attribute and wait for the other threads */</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NUM_THREADS; t++) &#123;</span><br><span class="line">        rc = pthread_join(thread[t], &amp;status);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_join() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: completed join with thread %ld having a status of %ld\n"</span>,t,(<span class="keyword">long</span>)status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main: program completed. Exiting.\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/join.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/join.out" target="_blank" rel="noopener">output</a></p>
<h3 id="栈空间管理"><a href="#栈空间管理" class="headerlink" title="栈空间管理"></a>栈空间管理</h3><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstackaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstackaddr</span><span class="params">(<span class="keyword">pthread_addr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="防止栈空间出错"><a href="#防止栈空间出错" class="headerlink" title="防止栈空间出错"></a>防止栈空间出错</h4><ul>
<li><code>POSIX</code> 标准没有规定一个线程的栈空间大小, 它取决于 <code>POSIX</code> 的实现和系统设置的变化.</li>
<li>超出默认栈空间限制经常是很容易出现的, 产生的后果是: 程序终止和/或数据被破坏.</li>
<li>具有安全性和可移植性的程序不能依赖于默认的栈空间大小, 而是通过 <code>pthread_attr_setstacksize</code> 为每个线程显式分配足够的栈空间.</li>
<li><code>pthread_attr_getstackaddr</code> 和 <code>pthread_addrgetstackaddr</code> 函数可以由特定环境中运行的应用程序使用, 在该环境中线程栈空间必须在放某个特定的内存区域中.</li>
</ul>
<h4 id="LC-的一些实际例子"><a href="#LC-的一些实际例子" class="headerlink" title="LC 的一些实际例子"></a>LC 的一些实际例子</h4><ul>
<li>默认线程栈空间大小变化很大. 可以获取到的最大栈空间大小变化也很大, 且这也依赖于每个系统可以创建的线程数.</li>
<li>过去和现在的体系结构都显示出默认线程堆空间大小的广泛变化.</li>
</ul>
<table>
<thead>
<tr>
<th>系统体系结构</th>
<th>#CPUs</th>
<th>Memory(GB)</th>
<th>Default Size(bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intel Xeon E5-2670</td>
<td>16</td>
<td>32</td>
<td>2,097,152</td>
</tr>
<tr>
<td>Intel Xeon 5660</td>
<td>12</td>
<td>24</td>
<td>2,097,152</td>
</tr>
<tr>
<td>AMD Opteron</td>
<td>8</td>
<td>16</td>
<td>2,097,152</td>
</tr>
<tr>
<td>Intel IA64</td>
<td>4</td>
<td>8</td>
<td>33,554,432</td>
</tr>
<tr>
<td>Intel IA32</td>
<td>2</td>
<td>4</td>
<td>2,097,152</td>
</tr>
<tr>
<td>IBM Power5</td>
<td>8</td>
<td>32</td>
<td>196,608</td>
</tr>
<tr>
<td>IBM Power4</td>
<td>8</td>
<td>16</td>
<td>196,608</td>
</tr>
<tr>
<td>IBM Power3</td>
<td>16</td>
<td>16</td>
<td>98,304</td>
</tr>
</tbody>
</table>
<h4 id="栈空间管理示例"><a href="#栈空间管理示例" class="headerlink" title="栈空间管理示例"></a>栈空间管理示例</h4><ul>
<li>这个示例演示了如何获取和设置一个线程的栈空间大小.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEGEXTRA 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dowork</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A[N][N];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">long</span> tid;</span><br><span class="line">    <span class="keyword">size_t</span> mystacksize;</span><br><span class="line"></span><br><span class="line">    tid = (<span class="keyword">long</span>)threadid;</span><br><span class="line">    pthread_attr_getstacksize (&amp;attr, &amp;mystacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld: stack size = %li bytes \n"</span>, tid, mystacksize);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">            A[i][j] = ((i*j)/<span class="number">3.452</span>) + (N-i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NTHREADS];</span><br><span class="line">    <span class="keyword">size_t</span> stacksize;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstacksize (&amp;attr, &amp;stacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Default stack size = %li\n"</span>, stacksize);</span><br><span class="line">    stacksize = <span class="keyword">sizeof</span>(<span class="keyword">double</span>)*N*N+MEGEXTRA;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Amount of stack needed per thread = %li\n"</span>,stacksize);</span><br><span class="line">    pthread_attr_setstacksize (&amp;attr, stacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Creating threads with stack size = %li bytes\n"</span>,stacksize);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NTHREADS; t++)&#123;</span><br><span class="line">        rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (<span class="keyword">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Created %ld threads.\n"</span>, t);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="杂项函数"><a href="#杂项函数" class="headerlink" title="杂项函数"></a>杂项函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pthread_self</code> 返回一个系统分配的唯一的当前调用线程的线程 <code>ID</code>(线程描述符).</li>
<li><code>pthread_equal</code> 对比两个线程 <code>ID</code>. 如果两个线程 <code>ID</code> 不同则返回 <code>0</code>, 否则返回一个非零整数.</li>
<li>注意: 对于这两个函数所使用的线程 <code>ID</code> 对象都是不透明的, 无法轻松检查. 因为线程 <code>ID</code> 是不透明的, 所以不应该使用 <code>C</code> 语言相等运算符 <code>==</code> 来比较两个线程 <code>ID</code> 或者将单个线程 <code>ID</code> 与另一个值进行比较.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pthread_once</code> 在一个进程中只执行一次 <code>init_routine</code>. 由进程中的任何线程第一次调用该函数是执行给定的没有参数的 <code>init_routine</code>. 任何后续的调用都将是无效的.</li>
<li><code>init_routine</code> 函数通常是一个初始化的函数.</li>
<li><code>once_control</code> 参数是一个同步控制结构体，需要在调用 <code>pthread_once</code> 之前进行初始化. 例如:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure>
<h2 id="线程练习一"><a href="#线程练习一" class="headerlink" title="线程练习一"></a>线程练习一</h2><h3 id="入门和线程管理函数"><a href="#入门和线程管理函数" class="headerlink" title="入门和线程管理函数"></a>入门和线程管理函数</h3><blockquote>
<p>概述:</p>
<ul>
<li>使用你的用户名和OTP令牌登录一个LC集群</li>
<li>将练习文件复制到家目录</li>
<li>熟悉 LC 的 <code>Pthreads</code> 环境</li>
<li>写一个简单的“Hello World” <code>Pthreads</code> 程序</li>
<li>成功编译程序</li>
<li>成功运行程序 - 使用几种不同的方式</li>
<li>查看, 编译, 运行和/或调试一些相关的 <code>Pthreads</code> 程序(已提供)</li>
</ul>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/exercise.html#Exercise1" target="_blank" rel="noopener"><strong>在这里练习</strong></a></p>
</blockquote>
<h2 id="互斥变量"><a href="#互斥变量" class="headerlink" title="互斥变量"></a>互斥变量</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><code>Mutex</code> 是 <code>mutual exclusion</code> 的缩写. 互斥变量是实现线程同步和发生多次写入时保护共享数据的方法之一.</li>
<li>互斥变量的行为类似以”锁定”的方式保护对共享数据资源的访问, 一般称作互斥锁. 在 <code>Pthread</code> 中使用互斥的基本概念指在任何时间内只有一个线程能锁定(或拥有[^1])一个互斥变量. 因此, 即使多个线程试图锁定互斥锁, 只有一个线程会成功. 在拥有该互斥锁的线程解锁该互斥锁之前，没有其他线程可以拥有该互斥锁.</li>
<li>互斥锁可以用于防止”竞争(race)”条件. 涉及银行交易竞争条件没有进行同步的示例如下所示:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/race_conditions.png" alt="race conditions"></p>
<ul>
<li>在上面的示例中, 当线程使用共享数据资源时应该使用互斥锁来锁定”balance”.</li>
<li>通常, 拥有互斥锁的线程回去更新全局变量. 这是确保多个线程更新同一个变量时,一个安全的方法. 最终的结果与只有一个线程执行所有更新的结果是相同的. 正在更新的变量属于应该加锁的”关键部分”.</li>
<li>使用互斥锁的典型顺序如下:<ul>
<li>创建并初始化互斥变量</li>
<li>几个线程试图锁定互斥锁</li>
<li>只有一个成功, 该线程拥有互斥锁</li>
<li>拥有锁的线程执行一些操作</li>
<li>拥有者解锁互斥锁</li>
<li>另一个线程获取互斥锁并重复该过程</li>
<li>最后互斥锁被销毁</li>
</ul>
</li>
<li>当多个线程去竞争一个互斥锁时, 失败者将阻塞在 <code>lock</code> 调用处 - 通过 <code>trylock</code> 而不是 <code>lock</code> 可以做到非阻塞调用.</li>
<li>在保护共享数据时, 程序员的责任是确保每个需要使用互斥锁的线程都是这样做的. 例如, 如果4个线程正在更新同一个数据, 但只有一个线程使用了互斥锁, 那么数据仍然可能被破坏.</li>
</ul>
<h3 id="创建和销毁互斥锁"><a href="#创建和销毁互斥锁" class="headerlink" title="创建和销毁互斥锁"></a>创建和销毁互斥锁</h3><h4 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul>
<li><p>必须使用 <code>pthread_mutex_t</code> 类型声明互斥变量并且初始化后才能使用. 有两种方法可以初始化一个变量:</p>
<ol>
<li><p>静态, 声明时初始化. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态, 使用 <code>pthread_mutex_init()</code> 函数初始化. 这个方法允许设置互斥对象属性 <code>attr</code>.</p>
</li>
</ol>
<p>互斥锁初始化后默认是解锁的.</p>
</li>
<li><p><code>pthread_mutex_init</code> 中的 <code>attr</code> 对象用于为互斥对象设置属性, 如果使用必须是 <code>pthread_mutexattr_t</code> 类型(可以指定为 <code>NULL</code> 以使用默认值). <code>Pthread</code> 标准定义了三个可选的互斥锁属性:</p>
<ul>
<li><code>Protocol</code>(协议): 指定用于防止互斥锁的优先级反转的协议.</li>
<li><code>prioceiling</code>: 指定已初始化的互斥锁的优先级上限.</li>
<li><code>Process-shared</code>: 指定互斥锁的进程共享.</li>
</ul>
<p>请注意, 不是所有实现都可以提供了这三个可选的互斥锁属性.</p>
</li>
<li><p><code>pthread_mutexattr_init</code> 和 <code>pthread_mutexattr_destroy</code> 函数分别用于创建和销毁互斥锁属性对象.</p>
</li>
<li><p>应该使用 <code>pthread_mutex_destroy</code> 来释放不再需要的互斥对象.</p>
</li>
</ul>
<h3 id="锁定和解锁互斥锁"><a href="#锁定和解锁互斥锁" class="headerlink" title="锁定和解锁互斥锁"></a>锁定和解锁互斥锁</h3><h4 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ul>
<li>线程使用 <code>pthread_mutex_lock()</code> 对指定参数 <code>mutex</code> 变量进行锁定. 如果这个互斥锁已经被其他线程锁定了, 那么调用这个函数的线程将会阻塞在这个调用处直到这个互斥锁被其他线程解锁.</li>
<li><code>pthread_mutex_trylock()</code> 会去尝试锁定一个互斥锁. 然而, 如果这个互斥锁已经锁定, 这个函数将立即返回一个”忙碌”的错误代码. 这个函数可能会被用来防止死锁条件, 例如在优先级倒置的情况下.</li>
<li><code>pthread_mutex_unlock</code> 被拥有互斥锁的线程调用会解锁这个互斥锁. 如果其他线程获取正在包含数据的互斥锁(处于被锁定), 那么在线程完成对被保护数据的访问后需要调用这个函数. 如果出现以下错误, <code>pthread_mutex_unlock</code> 将返回错误:<ul>
<li>如果互斥锁已经被解锁</li>
<li>如果互斥锁被另一个线程拥有</li>
</ul>
</li>
<li>互斥锁并没有什么”神奇”的. 事实上, 它类似于所有参与共享数据访问的线程之间的”绅士协议”. 程序员需要确保必要的线程都能正确的使用锁定和解锁调用. 以下方案演示了一个逻辑错误:</li>
</ul>
<p><img src="http://7xlaf3.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/%E7%BF%BB%E8%AF%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/error_lock_unlock.png" alt="Error lock and unlock"></p>
<ul>
<li><strong>问题</strong>: 当多个线程正在等待一个被锁定的互斥锁时, 那个线程在释放后将首先锁定这个互斥锁?</li>
</ul>
<blockquote>
<p><em>答案: 除非使用线程优先级调度(未被覆盖), 否则分配的权利将留给本机系统调度程序, 并且可能或多或少是随机的</em>.</p>
</blockquote>
<h3 id="使用互斥锁的示例"><a href="#使用互斥锁的示例" class="headerlink" title="使用互斥锁的示例"></a>使用互斥锁的示例</h3><ul>
<li>这个示例程序展示了在一个计算点积的线程程序中使用互斥变量.</li>
<li>主要的数据通过全局可访问的结构体提供给所有线程.</li>
<li>每个线程处理不同的一部分数据.</li>
<li>主线程等待所有线程完成计算, 然后打印结果总和.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: dotprod_mutex.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   This example program illustrates the use of mutex variables </span></span><br><span class="line"><span class="comment">*   in a threads program. This version was obtained by modifying the</span></span><br><span class="line"><span class="comment">*   serial version of the program (dotprod_serial.c) which performs a </span></span><br><span class="line"><span class="comment">*   dot product. The main data is made available to all threads through </span></span><br><span class="line"><span class="comment">*   a globally accessible  structure. Each thread works on a different </span></span><br><span class="line"><span class="comment">*   part of the data. The main thread waits for all the threads to complete </span></span><br><span class="line"><span class="comment">*   their computations, and then it prints the resulting sum.</span></span><br><span class="line"><span class="comment">* SOURCE: Vijay Sonnad, IBM</span></span><br><span class="line"><span class="comment">* LAST REVISED: 01/29/09 Blaise Barney</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">The following structure contains the necessary information  </span></span><br><span class="line"><span class="comment">to allow the function "dotprod" to access its input data and </span></span><br><span class="line"><span class="comment">place its output into the structure.  This structure is </span></span><br><span class="line"><span class="comment">unchanged from the sequential version.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span>      *a;</span><br><span class="line">    <span class="keyword">double</span>      *b;</span><br><span class="line">    <span class="keyword">double</span>     sum; </span><br><span class="line">    <span class="keyword">int</span>     veclen; </span><br><span class="line">&#125; DOTDATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define globally accessible variables and a mutex */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMTHRDS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECLEN 100000</span></span><br><span class="line">DOTDATA dotstr; </span><br><span class="line"><span class="keyword">pthread_t</span> callThd[NUMTHRDS];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutexsum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The function dotprod is activated when the thread is created.</span></span><br><span class="line"><span class="comment">As before, all input to this routine is obtained from a structure </span></span><br><span class="line"><span class="comment">of type DOTDATA and all output from this function is written into</span></span><br><span class="line"><span class="comment">this structure. The benefit of this approach is apparent for the </span></span><br><span class="line"><span class="comment">multi-threaded program: when a thread is created we pass a single</span></span><br><span class="line"><span class="comment">argument to the activated function - typically this argument</span></span><br><span class="line"><span class="comment">is a thread number. All  the other information required by the </span></span><br><span class="line"><span class="comment">function is accessed from the globally accessible structure. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dotprod</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Define and use local variables for convenience */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, start, end, len ;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">double</span> mysum, *x, *y;</span><br><span class="line">    offset = (<span class="keyword">long</span>)arg;</span><br><span class="line"></span><br><span class="line">    len = dotstr.veclen;</span><br><span class="line">    start = offset*len;</span><br><span class="line">    end   = start + len;</span><br><span class="line">    x = dotstr.a;</span><br><span class="line">    y = dotstr.b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Perform the dot product and assign result</span></span><br><span class="line"><span class="comment">to the appropriate variable in the structure. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    mysum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=start; i&lt;end ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        mysum += (x[i] * y[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Lock a mutex prior to updating the value in the shared</span></span><br><span class="line"><span class="comment">structure, and unlock it upon updating.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    pthread_mutex_lock (&amp;mutexsum);</span><br><span class="line">    dotstr.sum += mysum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld did %d to %d:  mysum=%f global sum=%f\n"</span>,offset,start,end,mysum,dotstr.sum);</span><br><span class="line">    pthread_mutex_unlock (&amp;mutexsum);</span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">The main program creates threads which do all the work and then </span></span><br><span class="line"><span class="comment">print out result upon completion. Before creating the threads,</span></span><br><span class="line"><span class="comment">The input data is created. Since all threads update a shared structure, we</span></span><br><span class="line"><span class="comment">need a mutex for mutual exclusion. The main thread needs to wait for</span></span><br><span class="line"><span class="comment">all threads to complete, it waits for each one of the threads. We specify</span></span><br><span class="line"><span class="comment">a thread attribute value that allow the main thread to join with the</span></span><br><span class="line"><span class="comment">threads it creates. Note also that we free up handles  when they are</span></span><br><span class="line"><span class="comment">no longer needed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">double</span> *a, *b;</span><br><span class="line">    <span class="keyword">void</span> *status;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign storage and initialize values */</span></span><br><span class="line"></span><br><span class="line">    a = (<span class="keyword">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    b = (<span class="keyword">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;VECLEN*NUMTHRDS; i++) &#123;</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dotstr.veclen = VECLEN; </span><br><span class="line">    dotstr.a = a; </span><br><span class="line">    dotstr.b = b; </span><br><span class="line">    dotstr.sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutexsum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads to perform the dotproduct  */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUMTHRDS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Each thread works on a different set of data.</span></span><br><span class="line"><span class="comment">   * The offset is specified by 'i'. The size of</span></span><br><span class="line"><span class="comment">   * the data for each thread is indicated by VECLEN.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">        pthread_create(&amp;callThd[i], &amp;attr, dotprod, (<span class="keyword">void</span> *)i); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">/* Wait on the other threads */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUMTHRDS;i++) &#123;</span><br><span class="line">        pthread_join(callThd[i], &amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* After joining, print out the results and cleanup */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Sum =  %f \n"</span>, dotstr.sum);</span><br><span class="line">    <span class="built_in">free</span> (a);</span><br><span class="line">    <span class="built_in">free</span> (b);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutexsum);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/dotprod_serial.c" target="_blank" rel="noopener">Serial version source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/dotprod_mutex.c" target="_blank" rel="noopener">Pthreads version source</a></p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>条件变量为线程提供了另一种同步方式. 互斥锁通过控制对数据的线程访问来实现同步, 而条件变量允许线程根据数据的实际值进行同步.</li>
<li>如果没有条件变量, 程序员需要让线程去不断轮询(可能在关键部分)检查条件是否得到满足. 这可能是非常消耗资源的, 因为线程将在这个过程中持续忙碌. 条件变量是一种在不用轮询的情况下达到同一效果的方法.</li>
<li>条件变量始终与互斥锁一起使用.</li>
<li>使用条件变量的典型顺序如下所示:</li>
</ul>
<blockquote>
<p>Main Thread</p>
<ul>
<li>声明并初始化需要同步的全局数据/变量(例如“count”)</li>
<li>声明并初始化条件变量对象</li>
<li>声明并初始化关联的互斥锁</li>
<li>创建线程A和B来完成工作</li>
</ul>
<blockquote>
<p>Thread A</p>
<ul>
<li>工作直到必须发生某种情况(例如“计数”必须达到指定值)</li>
<li>锁定关联的互斥锁并检查全局变量的值</li>
<li>全局变量的值不满足条件, 调用 <code>pthread_cond_wait()</code> 阻塞在这里等待 <code>Thread B</code> 的信号. 注意: 对 <code>pthread_cond_wait()</code> 的调用会自动并原子的解锁与条件变量关联的互斥锁, 以便 <code>Thread B</code> 可以使用它</li>
<li>收到信号后, 线程会从阻塞状态被唤醒. 与条件变量关联的互斥锁会自动并原子的锁定</li>
<li>明确的解锁互斥锁</li>
<li>继续</li>
</ul>
</blockquote>
<blockquote>
<p>Thread B</p>
<ul>
<li>工作</li>
<li>锁定与条件变量关联的互斥锁</li>
<li>更改 <code>Thread A</code> 正在等待的全局变量的值</li>
<li>检查 <code>Thread A</code> 等待的全局变量的值, 如果它满足所需条件，则向 <code>Thread A</code> 发出信号</li>
<li>解锁互斥锁</li>
<li>继续</li>
</ul>
</blockquote>
<p><code>Thread A</code> 与 <code>Thread B</code> 并行运行.</p>
<p>Main Thread</p>
<p>​    合并/继续</p>
</blockquote>
<h3 id="创建和销毁条件变量"><a href="#创建和销毁条件变量" class="headerlink" title="创建和销毁条件变量"></a>创建和销毁条件变量</h3><h4 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><ul>
<li><p>必须使用 <code>pthread_cond_t</code> 类型声明条件变量并且初始化后才能使用. 有两种方法可以初始化条件变量:</p>
<ol>
<li><p>静态, 声明时初始化. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> myconvar = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态, 使用 <code>pthread_cond_init()</code> 函数初始化. 创建的条件变量的 <code>ID</code> 通过 <code>condition</code> 参数返回给调用线程. 这个方法允许设置条件变量对象属性 <code>attr</code>.</p>
</li>
</ol>
</li>
<li><p>可选的参数 <code>attr</code> 对象用于设置条件变量属性. 条件变量只定义了一个属性: <code>process-shared</code>, 它允许条件变量被其他进程中的线程看到. 如果使用属性对象, 它必须是 <code>pthread_condattr_t</code> 类型(可以指定为 <code>NULL</code> 以使用默认值).</p>
<p>请注意, 并非所有实现都提供了 <code>process-shared</code> 属性.</p>
</li>
<li><p><code>pthread_condattr_init</code> 和 <code>pthread_condattr_destroy</code> 函数用于创建和销毁条件变量属性对象.</p>
</li>
<li><p>应该使用 <code>pthread_cond_destroy</code> 来释放不再需要的条件变量.</p>
</li>
</ul>
<h3 id="条件变量等待和发信号"><a href="#条件变量等待和发信号" class="headerlink" title="条件变量等待和发信号"></a>条件变量等待和发信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>pthread_cond_wait()</code> 在收到达到规定条件的信号之前会一直阻塞调用线程. 这个函数应该在锁定互斥锁后调用, 它会在等待时自动释放互斥锁. 当收到信号后会线程会被唤醒, 互斥锁将会被自动锁定以供线程使用. 然后程序员负责在线程处理完成后解锁互斥锁.</p>
<p><strong>建议</strong>: 调用 <code>pthread_cond_wait()</code> 时使用 <code>WHILE</code> 循环而不是 <code>IF</code> 语句(可以参考下面示例中的 <code>watch_count</code> 函数)来检查等待的条件, 这样可以帮助处理几个潜在的问题, 例如:</p>
<ul>
<li>如果多个线程在等待同一个唤醒信号, 当收到信号时, 它们将轮流获取互斥锁, 然后它们中的任何一个线程都可以修改它们等待条件.</li>
<li>如果线程由于程序错误而收到错误的信号.</li>
<li>线程库允许在不违反标准的情况下向等待的线程发出虚假唤醒.</li>
</ul>
</li>
<li><p><code>pthread_cond_signal()</code> 函数用于发送信号给(或唤醒)另一个正在使用条件变量等待的线程. 必须在与 <code>pthread_cond_wait()</code> 参数 <code>mutex</code> 相同的互斥锁锁定后才能调用它, 同时为了 <code>pthread_cond_wait()</code> 自动加锁能够执行完成必须要对参数 <code>mutex</code> 相同的互斥锁进行解锁.</p>
</li>
<li><p>如果多个线程处于阻塞等待状态, 那么应该使用 <code>pthread_cond_broadcast()</code> 函数而不是 <code>pthread_cond_signal()</code>.</p>
</li>
<li><p>在调用 <code>pthread_cond_wait()</code> 之前调用 <code>pthread_cond_signal()</code> 是一个逻辑错误.</p>
</li>
</ul>
<blockquote>
<p><strong>警告</strong>: 当使用这些函数时, 必须正确锁定和解锁相关联的互斥锁变量. 例如:</p>
<ul>
<li>调用 <code>pthread_cond_wait()</code> 之前没有锁定互斥锁可能导致它<strong>不</strong>被阻塞.</li>
<li>调用 <code>pthread_cond_signal</code> 后没有解锁互斥锁可能不允许对应的 <code>pthread_cond_wait</code> 函数完成(它将保持阻塞状态).</li>
</ul>
</blockquote>
<h3 id="使用条件变量的示例"><a href="#使用条件变量的示例" class="headerlink" title="使用条件变量的示例"></a>使用条件变量的示例</h3><ul>
<li>这个简单的示例代码演示了几个 <code>Pthread</code> 条件变量相关函数的使用.</li>
<li><code>main</code> 函数创建了三个线程.</li>
<li>其中两个线程执行工作并更新 <code>count</code> 变量.</li>
<li>第三个线程等待, 直到 <code>count</code> 变量达到指定值.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">* FILE: condvar.c</span></span><br><span class="line"><span class="comment">* DESCRIPTION:</span></span><br><span class="line"><span class="comment">*   Example code for using Pthreads condition variables.  The main thread</span></span><br><span class="line"><span class="comment">*   creates three threads.  Two of those threads increment a "count" variable,</span></span><br><span class="line"><span class="comment">*   while the third thread watches the value of "count".  When "count" </span></span><br><span class="line"><span class="comment">*   reaches a predefined limit, the waiting thread is signaled by one of the</span></span><br><span class="line"><span class="comment">*   incrementing threads. The waiting thread "awakens" and then modifies</span></span><br><span class="line"><span class="comment">*   count. The program continues until the incrementing threads reach</span></span><br><span class="line"><span class="comment">*   TCOUNT. The main program prints the final value of count.</span></span><br><span class="line"><span class="comment">* SOURCE: Adapted from example code in "Pthreads Programming", B. Nichols</span></span><br><span class="line"><span class="comment">*   et al. O'Reilly and Associates. </span></span><br><span class="line"><span class="comment">* LAST REVISED: 03/07/17  Blaise Barney</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCOUNT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_LIMIT 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>     count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_threshold_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">inc_count</span><span class="params">(<span class="keyword">void</span> *t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; TCOUNT; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">    Check the value of count and signal waiting thread when condition is</span></span><br><span class="line"><span class="comment">    reached.  Note that this occurs while mutex is locked. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (count == COUNT_LIMIT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d  Threshold reached. "</span>,</span><br><span class="line">                   my_id, count);</span><br><span class="line">            pthread_cond_signal(&amp;count_threshold_cv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Just sent signal.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d, unlocking mutex\n"</span>, </span><br><span class="line">               my_id, count);</span><br><span class="line">        pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do some work so threads can alternate on mutex lock */</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">watch_count</span><span class="params">(<span class="keyword">void</span> *t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Starting watch_count(): thread %ld\n"</span>, my_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Lock mutex and wait for signal.  Note that the pthread_cond_wait routine</span></span><br><span class="line"><span class="comment">  will automatically and atomically unlock mutex while it waits. </span></span><br><span class="line"><span class="comment">  Also, note that if COUNT_LIMIT is reached before this routine is run by</span></span><br><span class="line"><span class="comment">  the waiting thread, the loop will be skipped to prevent pthread_cond_wait</span></span><br><span class="line"><span class="comment">  from never returning.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">    <span class="keyword">while</span> (count &lt; COUNT_LIMIT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Count= %d. Going into wait...\n"</span>, my_id,count);</span><br><span class="line">        pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Condition signal received. Count= %d\n"</span>, my_id,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Updating the value of count...\n"</span>, my_id);</span><br><span class="line">    count += <span class="number">125</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld count now = %d.\n"</span>, my_id, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Unlocking mutex.\n"</span>, my_id);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, rc; </span><br><span class="line">    <span class="keyword">long</span> t1=<span class="number">1</span>, t2=<span class="number">2</span>, t3=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize mutex and condition variable objects */</span></span><br><span class="line">    pthread_mutex_init(&amp;count_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init (&amp;count_threshold_cv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For portability, explicitly create threads in a joinable state */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">0</span>], &amp;attr, watch_count, (<span class="keyword">void</span> *)t1);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">1</span>], &amp;attr, inc_count, (<span class="keyword">void</span> *)t2);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">2</span>], &amp;attr, inc_count, (<span class="keyword">void</span> *)t3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all threads to complete */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n"</span>, </span><br><span class="line">            NUM_THREADS, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up and exit */</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    pthread_mutex_destroy(&amp;count_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;count_threshold_cv);</span><br><span class="line">    pthread_exit (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/samples/condvar.c" target="_blank" rel="noopener">source</a> <a href="https://computing.llnl.gov/tutorials/pthreads/samples/condvar.out" target="_blank" rel="noopener">output</a></p>
<h2 id="Pthreads的监控，调试和性能分析工具"><a href="#Pthreads的监控，调试和性能分析工具" class="headerlink" title="Pthreads的监控，调试和性能分析工具"></a>Pthreads的监控，调试和性能分析工具</h2><p>略</p>
<h2 id="LLNL特定信息和建议"><a href="#LLNL特定信息和建议" class="headerlink" title="LLNL特定信息和建议"></a>LLNL特定信息和建议</h2><p>略</p>
<h2 id="未涵盖的主题"><a href="#未涵盖的主题" class="headerlink" title="未涵盖的主题"></a>未涵盖的主题</h2><p>Pthreads API有几个功能本教程未涉及. 这些列在下面. 有关详细信息, 请参考<a href="#`Pthread` 库函数参考"><code>Pthread</code> 库函数参考</a>部分.</p>
<ul>
<li>线程调度<ul>
<li>线程调度方式不同实现将导致线程的运行方式上有所不同. 在大多数情况下, 默认机制就足够了.</li>
<li><code>Pthreads API</code> 提供了显式设置线程调度策略和优先级的函数, 这些策略和优先级可能会覆盖默认机制.</li>
<li><code>API</code> 不需要特定的实现来支持这些功能.</li>
</ul>
</li>
<li><code>Keys</code>: 线程特定数据(<code>TSD</code>)<ul>
<li>当线程调用不同的函数或从不同的函数中返回时, 线程堆空间上的本地数据不断创建和销毁.</li>
<li>为了保留堆空间上的数据, 你通常需要将其作为参数从一个函数传递到下一个函数, 或者将数据存储在与线程关联的一个全局变量中.</li>
<li><code>Pthread</code> 提供了另一种通过 <code>Keys</code> 实现这个目的的方法, 这种方法可能更方便, 更多用途.</li>
</ul>
</li>
<li>用于处理“优先级倒置”问题的互斥锁 <code>Protocol</code> 属性和互斥锁优先级管理.</li>
<li>条件变量共享 - 跨进程</li>
<li>线程取消(<code>Thread Cancellation</code>)</li>
<li>线程和信号</li>
<li>同步构造 - 屏障(<code>barriers</code>)和锁定</li>
</ul>
<h2 id="线程练习二"><a href="#线程练习二" class="headerlink" title="线程练习二"></a>线程练习二</h2><h3 id="互斥锁-条件变量和带Pthreads的混合MPI"><a href="#互斥锁-条件变量和带Pthreads的混合MPI" class="headerlink" title="互斥锁, 条件变量和带Pthreads的混合MPI"></a>互斥锁, 条件变量和带Pthreads的混合MPI</h3><blockquote>
<p>概述:</p>
<ul>
<li>使用你的用户名和OTP令牌登录一个LC集群</li>
<li>将练习文件复制到家目录</li>
<li>熟悉 LC 的 <code>Pthreads</code> 环境</li>
<li>写一个简单的“Hello World” <code>Pthreads</code> 程序</li>
<li>成功编译程序</li>
<li>成功运行程序 - 使用几种不同的方式</li>
<li>查看, 编译, 运行和/或调试一些相关的 <code>Pthreads</code> 程序(已提供)</li>
</ul>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/exercise.html#Exercise2" target="_blank" rel="noopener"><strong>在这里练习</strong></a></p>
</blockquote>
<h2 id="参考和更多信息"><a href="#参考和更多信息" class="headerlink" title="参考和更多信息"></a>参考和更多信息</h2><ul>
<li>作者: <a href="mailto:blaiseb@llnl.gov" target="_blank" rel="noopener">Blaise Barney</a>, Livermore Computing.</li>
<li><code>POSIX</code> 标准: <a href="http://www.unix.org/version3/ieee_std.html" target="_blank" rel="noopener">www.unix.org/version3/ieee_std.html</a></li>
<li><code>Pthreads Programming</code>. B. Nichols et al. O’Reilly and Associates.</li>
<li><code>Programming With POSIX Threads</code>. D. Butenhof. Addison Wesley</li>
<li><code>Programming With Threads</code>. S. Kleiman et al. Prentice Hall</li>
</ul>
<h2 id="Pthread-库函数参考"><a href="#Pthread-库函数参考" class="headerlink" title="Pthread 库函数参考"></a><code>Pthread</code> 库函数参考</h2><p>为方便起见, 下面提供了按字母顺序排列的Pthread函数列表, 并链接到了相应的手册页.</p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_atfork.txt" target="_blank" rel="noopener">pthread_atfork</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_destroy.txt" target="_blank" rel="noopener">pthread_attr_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getdetachstate.txt" target="_blank" rel="noopener">pthread_attr_getdetachstate</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getguardsize.txt" target="_blank" rel="noopener">pthread_attr_getguardsize</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getinheritsched.txt" target="_blank" rel="noopener">pthread_attr_getinheritsched</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedparam.txt" target="_blank" rel="noopener">pthread_attr_getschedparam</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedpolicy.txt" target="_blank" rel="noopener">pthread_attr_getschedpolicy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getscope.txt" target="_blank" rel="noopener">pthread_attr_getscope</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstack.txt" target="_blank" rel="noopener">pthread_attr_getstack</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstackaddr.txt" target="_blank" rel="noopener">pthread_attr_getstackaddr</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstacksize.txt" target="_blank" rel="noopener">pthread_attr_getstacksize</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_init.txt" target="_blank" rel="noopener">pthread_attr_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setdetachstate.txt" target="_blank" rel="noopener">pthread_attr_setdetachstate</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setguardsize.txt" target="_blank" rel="noopener">pthread_attr_setguardsize</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setinheritsched.txt" target="_blank" rel="noopener">pthread_attr_setinheritsched</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedparam.txt" target="_blank" rel="noopener">pthread_attr_setschedparam</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedpolicy.txt" target="_blank" rel="noopener">pthread_attr_setschedpolicy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setscope.txt" target="_blank" rel="noopener">pthread_attr_setscope</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstack.txt" target="_blank" rel="noopener">pthread_attr_setstack</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstackaddr.txt" target="_blank" rel="noopener">pthread_attr_setstackaddr</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstacksize.txt" target="_blank" rel="noopener">pthread_attr_setstacksize</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_destroy.txt" target="_blank" rel="noopener">pthread_barrier_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_init.txt" target="_blank" rel="noopener">pthread_barrier_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_wait.txt" target="_blank" rel="noopener">pthread_barrier_wait</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_destroy.txt" target="_blank" rel="noopener">pthread_barrierattr_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_getpshared.txt" target="_blank" rel="noopener">pthread_barrierattr_getpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_init.txt" target="_blank" rel="noopener">pthread_barrierattr_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_setpshared.txt" target="_blank" rel="noopener">pthread_barrierattr_setpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cancel.txt" target="_blank" rel="noopener">pthread_cancel</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_pop.txt" target="_blank" rel="noopener">pthread_cleanup_pop</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_push.txt" target="_blank" rel="noopener">pthread_cleanup_push</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_broadcast.txt" target="_blank" rel="noopener">pthread_cond_broadcast</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt" target="_blank" rel="noopener">pthread_cond_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt" target="_blank" rel="noopener">pthread_cond_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_signal.txt" target="_blank" rel="noopener">pthread_cond_signal</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_timedwait.txt" target="_blank" rel="noopener">pthread_cond_timedwait</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_wait.txt" target="_blank" rel="noopener">pthread_cond_wait</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt" target="_blank" rel="noopener">pthread_condattr_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getclock.txt" target="_blank" rel="noopener">pthread_condattr_getclock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getpshared.txt" target="_blank" rel="noopener">pthread_condattr_getpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt" target="_blank" rel="noopener">pthread_condattr_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setclock.txt" target="_blank" rel="noopener">pthread_condattr_setclock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setpshared.txt" target="_blank" rel="noopener">pthread_condattr_setpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt" target="_blank" rel="noopener">pthread_create</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_detach.txt" target="_blank" rel="noopener">pthread_detach</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_equal.txt" target="_blank" rel="noopener">pthread_equal</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_exit.txt" target="_blank" rel="noopener">pthread_exit</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getconcurrency.txt" target="_blank" rel="noopener">pthread_getconcurrency</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getcpuclockid.txt" target="_blank" rel="noopener">pthread_getcpuclockid</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getschedparam.txt" target="_blank" rel="noopener">pthread_getschedparam</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getspecific.txt" target="_blank" rel="noopener">pthread_getspecific</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_join.txt" target="_blank" rel="noopener">pthread_join</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_create.txt" target="_blank" rel="noopener">pthread_key_create</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_delete.txt" target="_blank" rel="noopener">pthread_key_delete</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_kill.txt" target="_blank" rel="noopener">pthread_kill</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_destroy.txt" target="_blank" rel="noopener">pthread_mutex_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_getprioceiling.txt" target="_blank" rel="noopener">pthread_mutex_getprioceiling</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_init.txt" target="_blank" rel="noopener">pthread_mutex_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_lock.txt" target="_blank" rel="noopener">pthread_mutex_lock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_setprioceiling.txt" target="_blank" rel="noopener">pthread_mutex_setprioceiling</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_timedlock.txt" target="_blank" rel="noopener">pthread_mutex_timedlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_trylock.txt" target="_blank" rel="noopener">pthread_mutex_trylock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt" target="_blank" rel="noopener">pthread_mutex_unlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_destroy.txt" target="_blank" rel="noopener">pthread_mutexattr_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprioceiling.txt" target="_blank" rel="noopener">pthread_mutexattr_getprioceiling</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprotocol.txt" target="_blank" rel="noopener">pthread_mutexattr_getprotocol</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getpshared.txt" target="_blank" rel="noopener">pthread_mutexattr_getpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_gettype.txt" target="_blank" rel="noopener">pthread_mutexattr_gettype</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt" target="_blank" rel="noopener">pthread_mutexattr_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprioceiling.txt" target="_blank" rel="noopener">pthread_mutexattr_setprioceiling</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprotocol.txt" target="_blank" rel="noopener">pthread_mutexattr_setprotocol</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setpshared.txt" target="_blank" rel="noopener">pthread_mutexattr_setpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_settype.txt" target="_blank" rel="noopener">pthread_mutexattr_settype</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_once.txt" target="_blank" rel="noopener">pthread_once</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_destroy.txt" target="_blank" rel="noopener">pthread_rwlock_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_init.txt" target="_blank" rel="noopener">pthread_rwlock_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_rdlock.txt" target="_blank" rel="noopener">pthread_rwlock_rdlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedrdlock.txt" target="_blank" rel="noopener">pthread_rwlock_timedrdlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedwrlock.txt" target="_blank" rel="noopener">pthread_rwlock_timedwrlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_tryrdlock.txt" target="_blank" rel="noopener">pthread_rwlock_tryrdlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_trywrlock.txt" target="_blank" rel="noopener">pthread_rwlock_trywrlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_unlock.txt" target="_blank" rel="noopener">pthread_rwlock_unlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_wrlock.txt" target="_blank" rel="noopener">pthread_rwlock_wrlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_destroy.txt" target="_blank" rel="noopener">pthread_rwlockattr_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_getpshared.txt" target="_blank" rel="noopener">pthread_rwlockattr_getpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_init.txt" target="_blank" rel="noopener">pthread_rwlockattr_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_setpshared.txt" target="_blank" rel="noopener">pthread_rwlockattr_setpshared</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_self.txt" target="_blank" rel="noopener">pthread_self</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcancelstate.txt" target="_blank" rel="noopener">pthread_setcancelstate</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcanceltype.txt" target="_blank" rel="noopener">pthread_setcanceltype</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setconcurrency.txt" target="_blank" rel="noopener">pthread_setconcurrency</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedparam.txt" target="_blank" rel="noopener">pthread_setschedparam</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedprio.txt" target="_blank" rel="noopener">pthread_setschedprio</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setspecific.txt" target="_blank" rel="noopener">pthread_setspecific</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_sigmask.txt" target="_blank" rel="noopener">pthread_sigmask</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_destroy.txt" target="_blank" rel="noopener">pthread_spin_destroy</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_init.txt" target="_blank" rel="noopener">pthread_spin_init</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_lock.txt" target="_blank" rel="noopener">pthread_spin_lock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_trylock.txt" target="_blank" rel="noopener">pthread_spin_trylock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_unlock.txt" target="_blank" rel="noopener">pthread_spin_unlock</a></p>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_testcancel.txt" target="_blank" rel="noopener">pthread_testcancel</a></p>
<p>[^1]: 译者注: 这里拥有的意思是当一个互斥变量被锁定时, 锁定的线程占有这个互斥变量的使用权, 其他线程无法使用.</p>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享, 您的支持将鼓励我继续创作!</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="chunqiulfq 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="chunqiulfq 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>chunqiulfq</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://chunqiublog.github.io/POSIX_Threads_Programming.html" title="POSIX Threads Programming">http://chunqiublog.github.io/POSIX_Threads_Programming.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
			<a href="/tags/翻译/" rel="tag"><i class="fa fa-tag"></i> 翻译</a>
          
			<a href="/tags/线程/" rel="tag"><i class="fa fa-tag"></i> 线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Linux_memoryout_user_stack_extension.html" rel="next" title="Linux 内存用户堆栈扩展">
                <i class="fa fa-chevron-left"></i> Linux 内存用户堆栈扩展
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/function_open_creat_and_openat.html" rel="prev" title="函数 open(), creat() 和 openat()">
                函数 open(), creat() 和 openat() <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container"></div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="chunqiulfq" />
            
              <p class="site-author-name" itemprop="name">chunqiulfq</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲 不破楼兰终不还</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/chunqiulfq" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:chunqiu.lfq@gmail.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://redisbook.com/" title="Redis 设计与实现" target="_blank">Redis 设计与实现</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pthreads-Overview-Pthreads-概述"><span class="nav-number">2.</span> <span class="nav-text">Pthreads Overview(Pthreads 概述)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程"><span class="nav-number">2.1.</span> <span class="nav-text">什么是线程?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Pthreads"><span class="nav-number">2.2.</span> <span class="nav-text">什么是 Pthreads?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么选择-Pthreads"><span class="nav-number">2.3.</span> <span class="nav-text">为什么选择 Pthreads?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级"><span class="nav-number">2.3.1.</span> <span class="nav-text">轻量级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高效的通信-数据交换"><span class="nav-number">2.3.2.</span> <span class="nav-text">高效的通信/数据交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他常见原因"><span class="nav-number">2.3.3.</span> <span class="nav-text">其他常见原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计线程程序"><span class="nav-number">2.4.</span> <span class="nav-text">设计线程程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并行编程"><span class="nav-number">2.4.1.</span> <span class="nav-text">并行编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存模型"><span class="nav-number">2.4.2.</span> <span class="nav-text">共享内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">2.4.3.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程限制"><span class="nav-number">2.4.4.</span> <span class="nav-text">线程限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Pthreads-API"><span class="nav-number">3.</span> <span class="nav-text">The Pthreads API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译线程程序"><span class="nav-number">4.</span> <span class="nav-text">编译线程程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程管理"><span class="nav-number">5.</span> <span class="nav-text">线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和终止线程"><span class="nav-number">5.1.</span> <span class="nav-text">创建和终止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数"><span class="nav-number">5.1.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程"><span class="nav-number">5.1.2.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程属性"><span class="nav-number">5.1.3.</span> <span class="nav-text">线程属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的绑定和调度"><span class="nav-number">5.1.4.</span> <span class="nav-text">线程的绑定和调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止线程-amp-exit"><span class="nav-number">5.1.5.</span> <span class="nav-text">终止线程 &amp; exit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-线程的创建和终止"><span class="nav-number">5.1.6.</span> <span class="nav-text">示例: 线程的创建和终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将参数传递给线程"><span class="nav-number">5.2.</span> <span class="nav-text">将参数传递给线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程参数传递示例"><span class="nav-number">5.2.1.</span> <span class="nav-text">线程参数传递示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并和分离线程"><span class="nav-number">5.3.</span> <span class="nav-text">合并和分离线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并-Joining"><span class="nav-number">5.3.2.</span> <span class="nav-text">合并(Joining)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#是否为可合并的"><span class="nav-number">5.3.3.</span> <span class="nav-text">是否为可合并的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分离"><span class="nav-number">5.3.4.</span> <span class="nav-text">分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建议"><span class="nav-number">5.3.5.</span> <span class="nav-text">建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程合并示例"><span class="nav-number">5.3.6.</span> <span class="nav-text">线程合并示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈空间管理"><span class="nav-number">5.4.</span> <span class="nav-text">栈空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数-2"><span class="nav-number">5.4.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防止栈空间出错"><span class="nav-number">5.4.2.</span> <span class="nav-text">防止栈空间出错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LC-的一些实际例子"><span class="nav-number">5.4.3.</span> <span class="nav-text">LC 的一些实际例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈空间管理示例"><span class="nav-number">5.4.4.</span> <span class="nav-text">栈空间管理示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#杂项函数"><span class="nav-number">5.5.</span> <span class="nav-text">杂项函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程练习一"><span class="nav-number">6.</span> <span class="nav-text">线程练习一</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#入门和线程管理函数"><span class="nav-number">6.1.</span> <span class="nav-text">入门和线程管理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥变量"><span class="nav-number">7.</span> <span class="nav-text">互斥变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和销毁互斥锁"><span class="nav-number">7.2.</span> <span class="nav-text">创建和销毁互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数-3"><span class="nav-number">7.2.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用法"><span class="nav-number">7.2.2.</span> <span class="nav-text">用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁定和解锁互斥锁"><span class="nav-number">7.3.</span> <span class="nav-text">锁定和解锁互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数-4"><span class="nav-number">7.3.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用法-1"><span class="nav-number">7.3.2.</span> <span class="nav-text">用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用互斥锁的示例"><span class="nav-number">7.4.</span> <span class="nav-text">使用互斥锁的示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件变量"><span class="nav-number">8.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和销毁条件变量"><span class="nav-number">8.2.</span> <span class="nav-text">创建和销毁条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数-5"><span class="nav-number">8.2.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用法-2"><span class="nav-number">8.2.2.</span> <span class="nav-text">用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量等待和发信号"><span class="nav-number">8.3.</span> <span class="nav-text">条件变量等待和发信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用条件变量的示例"><span class="nav-number">8.4.</span> <span class="nav-text">使用条件变量的示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pthreads的监控，调试和性能分析工具"><span class="nav-number">9.</span> <span class="nav-text">Pthreads的监控，调试和性能分析工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLNL特定信息和建议"><span class="nav-number">10.</span> <span class="nav-text">LLNL特定信息和建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未涵盖的主题"><span class="nav-number">11.</span> <span class="nav-text">未涵盖的主题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程练习二"><span class="nav-number">12.</span> <span class="nav-text">线程练习二</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁-条件变量和带Pthreads的混合MPI"><span class="nav-number">12.1.</span> <span class="nav-text">互斥锁, 条件变量和带Pthreads的混合MPI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考和更多信息"><span class="nav-number">13.</span> <span class="nav-text">参考和更多信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pthread-库函数参考"><span class="nav-number">14.</span> <span class="nav-text">Pthread 库函数参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chunqiulfq</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  






  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '208433c9fd56b4c87620',
          clientSecret: '5822b2d2a9ff16ec2e5f3471f23521b7d8d43912',
          repo: 'gitalk',
          owner: 'chunqiulfq',
          admin: ['chunqiulfq'],
          id: window.location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.4.2"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.4.2"></script>


  

  
  
  
    
  
  <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js"></script>
  <script type="text/javascript">
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
